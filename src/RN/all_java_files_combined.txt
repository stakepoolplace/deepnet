package RN.algoactivations;


/**
 * @author Eric Marchand
 *
 */
public class ActivationFx {

	private ActivationFx instance;
	private String name;
	private EActivation fx;
	
	public ActivationFx(String name, EActivation fx){
		this.name = name;
		this.fx = fx;
		this.instance = this;
	}

	@Override
	public String toString(){
		return this.name;
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public EActivation getFx() {
		return fx;
	}

	public void setFx(EActivation fx) {
		this.fx = fx;
	}
	
	public ActivationFx getByEnum(EActivation fx){
		if(instance.getFx() == fx)
			return instance;
		return null;
	}
	
	
}
package RN.algoactivations;

import java.io.Serializable;

import RN.algoactivations.utils.BoundMath;


/**
 * @author Eric Marchand
 *
 */
public class CosinusPerformer implements Serializable, IActivation {

	@Override
	public double perform(double... value) throws Exception {
		return BoundMath.cos(value[0]);
		
	}

	@Override
	public double performDerivative(double... value) {
		return -BoundMath.sin(value[0]);
	}

}
package RN.algoactivations;

import java.io.Serializable;

/**
 * @author Eric Marchand
 *
 */
public class DoubleSygmoidPerformer implements Serializable, IActivation {

	@Override
	public double perform(double... value) throws Exception {
		
		// y = sgn(x - d) ( 1 - exp(-(x-d / s)^2))
		
		return  0;//1.0D / (1.0D + BoundMath.exp(-value));
	}

	@Override
	public double performDerivative(double... value) throws Exception {
		
		return 0;  //(BoundMath.exp(value)) / ( (BoundMath.exp(value) + 1.0D) * (BoundMath.exp(value) + 1.0D));
	}

}
package RN.algoactivations;

/**
 * @author Eric Marchand
 *
 */
public enum EActivation {

	
	COS, SIN, IDENTITY, HEAVISIDE, SYGMOID_0_1, SYGMOID_1_1, TANH, LINEAR, SYGMOID_0_1_INVERSE, SYGMOID_0_1_NEGATIVE, NEGATIVE, RLU, LEAKY_RELU;
	
	public static EActivation getEnum(String function){
	
		if (function.equalsIgnoreCase(EActivation.HEAVISIDE.name()))
		return EActivation.HEAVISIDE;
	else if (function.equalsIgnoreCase(EActivation.SYGMOID_0_1.name()))
		return EActivation.SYGMOID_0_1;
	else if (function.equalsIgnoreCase(EActivation.SYGMOID_0_1_INVERSE.name()))
		return EActivation.SYGMOID_0_1_INVERSE;
	else if (function.equalsIgnoreCase(EActivation.SYGMOID_1_1.name()))
		return EActivation.SYGMOID_1_1;
	else if (function.equalsIgnoreCase(EActivation.TANH.name()))
		return EActivation.TANH;
	else if (function.equalsIgnoreCase(EActivation.IDENTITY.name()))
		return EActivation.IDENTITY;
	else if (function.equalsIgnoreCase(EActivation.SIN.name()))
		return EActivation.SIN;
	else if (function.equalsIgnoreCase(EActivation.COS.name()))
		return EActivation.COS;
	else if (function.equalsIgnoreCase(EActivation.LINEAR.name()))
		return EActivation.LINEAR;		
	else if (function.equalsIgnoreCase(EActivation.NEGATIVE.name()))
		return EActivation.NEGATIVE;
	else if (function.equalsIgnoreCase(EActivation.SYGMOID_0_1_NEGATIVE.name()))
		return EActivation.SYGMOID_0_1_NEGATIVE;
	else if (function.equalsIgnoreCase(EActivation.RLU.name()))
		return EActivation.RLU;
	else if (function.equalsIgnoreCase(EActivation.LEAKY_RELU.name()))
		return EActivation.LEAKY_RELU;		
		
		
		return null;
	
	}

	public static IActivation getPerformer(EActivation function) {
		
		IActivation performer = null;
		
		if (function == EActivation.HEAVISIDE)
			performer = new HeaviSidePerformer();
		else if (function == EActivation.SYGMOID_0_1)
			performer = new SygmoidPerformer();
		else if (function == EActivation.SYGMOID_0_1_INVERSE)
			performer = new SygmoidInversePerformer();
		else if (function == EActivation.SYGMOID_1_1)
			performer = new SygmoidPerformer2();
		else if (function == EActivation.TANH)
			performer = new TanHPerformer();
		else if (function == EActivation.IDENTITY)
			performer = new IdentityPerformer();
		else if (function == EActivation.SIN)
			performer = new SinusPerformer();
		else if (function == EActivation.COS)
			performer = new CosinusPerformer();	
		else if (function == EActivation.LINEAR)
			performer = new LinearPerformer();
		else if (function == EActivation.NEGATIVE)
			performer = new NegativePerformer();
		else if (function == EActivation.SYGMOID_0_1_NEGATIVE)
			performer = new SygmoidNegativePerformer();
		else if (function == EActivation.RLU)
			performer = new ReLUPerformer();
		else if (function == EActivation.LEAKY_RELU)
			performer = new LeakyReLUPerformer();		
		
		
		return performer;
	}
	
}
package RN.algoactivations;

import java.io.Serializable;

/**
 * @author Eric Marchand
 *
 */
public class GaussianPerformer implements Serializable, IActivation {

	@Override
	public double perform(double... value) throws Exception {

		return 0;
	}

	@Override
	public double performDerivative(double... value) throws Exception {
		
		
		return  0;
	}

}
package RN.algoactivations;

import java.io.Serializable;

/**
 * 
 * Remarque : L'application de descente du gradient ne fonctionne pas
 * car Heaviside n'est pas dérivable.
 * 
 * @author Eric
 *
 */
public class HeaviSidePerformer implements Serializable, IActivation {

	@Override
	public double perform(double... value) throws Exception {

		if(value[0] > 0D)
			return 1.0D;
		else
			return 0.0D;
		
	}

	@Override
	public double performDerivative(double... value) {
		return 1.0D;
	}

}
package RN.algoactivations;

/**
 * Interface IPerformer Perform a task for statistics Used in AdapterStatistics
 * 
 * @author emarchand
 * 
 */
public interface IActivation {
   
   double perform(double... value) throws Exception;
   
   double performDerivative(double... value) throws Exception;
   
}
package RN.algoactivations;

import java.io.Serializable;

import RN.algoactivations.utils.BoundNumbers;

/**
 * @author Eric Marchand
 *
 */
public class IdentityPerformer implements Serializable, IActivation{

	@Override
	public double perform(double... value) throws Exception {
		return BoundNumbers.bound(value[0]);
	}

	@Override
	public double performDerivative(double... value) throws Exception {
		return 1;
	}

}
package RN.algoactivations;

import java.io.Serializable;

/**
 * @author Eric Marchand
 *
 */
public class LeakyReLUPerformer implements Serializable, IActivation{
	
	public static Double alpha = 0.01D;

	@Override
	public double perform(double... value) throws Exception {
		
		if(value[0] > 0D)
			return value[0];
		else
			return alpha * value[0];
		
	}

	@Override
	public double performDerivative(double... value) throws Exception {
		
		if(value[0] > 0D)
			return 1.0D;
		else
			return alpha;
	}

}
package RN.algoactivations;

import java.io.Serializable;

/**
 * @author Eric Marchand
 *
 */
public class LinearPerformer implements Serializable, IActivation{

	@Override
	public double perform(double... value) throws Exception {
		
		return  value[0];
	}

	@Override
	public double performDerivative(double... value) throws Exception {
		
		return 1;
	}

}
package RN.algoactivations;

import java.io.Serializable;

/**
 * @author Eric Marchand
 *
 */
public class NegativePerformer implements Serializable, IActivation {

	@Override
	public double perform(double... value) throws Exception {
		
		return -value[0];
	}

	@Override
	public double performDerivative(double... value) throws Exception {
		
		return  -1;
	}

}
package RN.algoactivations;

import java.io.Serializable;

/**
 * @author Eric Marchand
 *
 */
public class ReLUPerformer implements Serializable, IActivation{

	@Override
	public double perform(double... value) throws Exception {
		
		return Math.max(0D, value[0]);
	}

	@Override
	public double performDerivative(double... value) throws Exception {
		
		if(value[0] > 0D)
			return 1.0D;
		else
			return 0.0D;
	}

}
package RN.algoactivations;

import java.io.Serializable;

import RN.algoactivations.utils.BoundMath;


/**
 * @author Eric Marchand
 *
 */
public class SinusPerformer implements Serializable, IActivation {

	@Override
	public double perform(double... value) throws Exception {
		
		return BoundMath.sin(value[0]);
		
	}

	@Override
	public double performDerivative(double... value) {
		
		
		return BoundMath.cos(value[0]);
	}

}
package RN.algoactivations;

import java.io.Serializable;

/**
 * @author Eric Marchand
 *
 */
public class SoftMaxPerformer implements Serializable{

}
package RN.algoactivations;

import java.io.Serializable;

import RN.algoactivations.utils.BoundMath;


/**
 * @author Eric Marchand
 *
 */
public class SygmoidInversePerformer implements Serializable, IActivation {

	@Override
	public double perform(double... value) throws Exception {
		
		return -1.0D / (1.0D + BoundMath.exp(-value[0]));
	}

	@Override
	public double performDerivative(double... value) throws Exception {
		
		return  -BoundMath.exp(value[0]) / ( Math.pow(BoundMath.exp(value[0]) + 1.0D, 2D) );
	}

}
package RN.algoactivations;

import java.io.Serializable;

import RN.algoactivations.utils.BoundMath;


/**
 * @author Eric Marchand
 *
 */
public class SygmoidNegativePerformer implements Serializable, IActivation {

	@Override
	public double perform(double... value) throws Exception {
		
		return (1.0D / (1.0D + BoundMath.exp(-value[0]))) - 1;
	}

	@Override
	public double performDerivative(double... value) throws Exception {
		
		return  -BoundMath.exp(value[0]) / ( Math.pow(BoundMath.exp(value[0]) + 1.0D, 2D) );
	}

}
package RN.algoactivations;

import java.io.Serializable;

import RN.algoactivations.utils.BoundMath;


/**
 * @author Eric Marchand
 *
 */
public class SygmoidPerformer implements Serializable, IActivation {

	@Override
	public double perform(double... value) throws Exception {
		
		
		return 1.0D / (1.0D + BoundMath.exp(-value[0]));
	}

	@Override
	public double performDerivative(double... value) throws Exception {
		
		return  BoundMath.exp(value[0]) / ( Math.pow(BoundMath.exp(value[0]) + 1.0D, 2D) );
	}

}
package RN.algoactivations;

import java.io.Serializable;

/**
 * @author Eric Marchand
 *
 */
public class SygmoidPerformer2 implements Serializable, IActivation {

	@Override
	public double perform(double... value) throws Exception {
		
		//return (2.0D / (1.0D + BoundMath.exp(-5*value))) - 1D;
		return (2.0D / (1.0D + Math.exp(-value[0]))) - 1D;
	}

	@Override
	public double performDerivative(double... value) throws Exception {
		
		//return  (10 * BoundMath.exp( 5 * value))  /  (Math.pow( 1.0D + BoundMath.exp(5 * value) , 2D)) ;
		return  (2D * Math.exp(value[0]))  /  (Math.pow( 1.0D + Math.exp(value[0]) , 2D)) ;
	}

}
package RN.algoactivations;

import java.io.Serializable;

import RN.algoactivations.utils.BoundMath;


/**
 * @author Eric Marchand
 *
 */
public class TanHPerformer implements Serializable, IActivation {

	
	@Override
	public double perform(double... value) throws Exception {
		return 1.7159D * BoundMath.tanh(value[0]);
	}

	@Override
	public double performDerivative(double... value) throws Exception {

		double coshx = BoundMath.cosh(value[0]);
		double denom = BoundMath.cosh(2*value[0]) + 1;
		return (1.7159D * 4D * coshx * coshx) / (denom * denom);
	}

}
package RN.algoactivations.tests;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

import RN.algoactivations.SygmoidPerformer;

/**
 * @author Eric Marchand
 *
 */
public class TestSygmoid {

	@Test
	public void testPerform() throws Exception {
		SygmoidPerformer syg = new SygmoidPerformer();
		assertEquals(0.5D, syg.perform(0.0D), 0.1);
	}

	@Test
	public void testPerformDerivative() throws Exception {
		SygmoidPerformer syg = new SygmoidPerformer();
		assertEquals(0.25D, syg.performDerivative(0.0D), 0.1);
	}

}
package RN.algoactivations.tests;

import static org.junit.Assert.assertEquals;

import org.junit.Test;

import RN.algoactivations.SygmoidPerformer2;

/**
 * @author Eric Marchand
 *
 */
public class TestSygmoid2 {

	@Test
	public void testPerform() throws Exception {
		SygmoidPerformer2 syg = new SygmoidPerformer2();
		assertEquals(0.0D, syg.perform(0.0D), 0D);
		assertEquals(0.5005D, syg.perform(0.1D), 0.00005D);
		assertEquals(-0.5005D, syg.perform(-0.1D), 0.00005D);
	}

	@Test
	public void testPerformDerivative() throws Exception {
		SygmoidPerformer2 syg = new SygmoidPerformer2();
		assertEquals(5.5D, syg.performDerivative(0.0D), 0D);
		assertEquals(0.01D, syg.performDerivative(0.7D), 0.0001D);
		assertEquals(0.01D, syg.performDerivative(-0.7D), 0.0001D);
	}

}
package RN.algoactivations.utils;

/**
 * Avoid Math.Nan
 * @author Eric Marchand
 */
public final class BoundMath {

	/**
	 * Calculate the cos.
	 * 
	 * @param a
	 *            The value passed to the function.
	 * @return The result of the function.
	 */
	public static double cos(final double a) {
		return BoundNumbers.bound(Math.cos(a));
	}

	/**
	 * Calculate the exp.
	 * 
	 * @param a
	 *            The value passed to the function.
	 * @return The result of the function.
	 */
	public static double exp(final double a) {
		return BoundNumbers.bound(Math.exp(a));
	}

	/**
	 * Calculate the log.
	 * 
	 * @param a
	 *            The value passed to the function.
	 * @return The result of the function.
	 */
	public static double log(final double a) {
		return BoundNumbers.bound(Math.log(a));
	}

	/**
	 * Calculate the power of a number.
	 * 
	 * @param a
	 *            The base.
	 * @param b
	 *            The exponent.
	 * @return The result of the function.
	 */
	public static double pow(final double a, final double b) {
		return BoundNumbers.bound(Math.pow(a, b));
	}

	/**
	 * Calculate the sin.
	 * 
	 * @param a
	 *            The value passed to the function.
	 * @return The result of the function.
	 */
	public static double sin(final double a) {
		return BoundNumbers.bound(Math.sin(a));
	}

	/**
	 * Calculate the square root.
	 * 
	 * @param a
	 *            The value passed to the function.
	 * @return The result of the function.
	 */
	public static double sqrt(final double a) {
		return Math.sqrt(a);
	}

	/**
	 * Private constructor.
	 */
	private BoundMath() {

	}

	/**
	 * Calculate TANH, within bounds.
	 * @param d The value to calculate for.
	 * @return The result.
	 */
	public static double tanh(final double d) {
		return BoundNumbers.bound(Math.tanh(d));
	}
	
	/**
	 * Calculate COSH, within bounds.
	 * @param d The value to calculate for.
	 * @return The result.
	 */
	public static double cosh(final double d) {
		return BoundNumbers.bound(Math.cosh(d));
	}
	
	
}
package RN.algoactivations.utils;

/**
 * A simple class that prevents numbers from getting either too big or too
 * small.
 */
public final class BoundNumbers {

	/**
	 * Too small of a number.
	 */
	public static final double TOO_SMALL = -1.0E20;

	/**
	 * Too big of a number.
	 */
	public static final double TOO_BIG = 1.0E20;

	/**
	 * Bound the number so that it does not become too big or too small.
	 * 
	 * @param d
	 *            The number to check.
	 * @return The new number. Only changed if it was too big or too small.
	 */
	public static double bound(final double d) {
		if (d < BoundNumbers.TOO_SMALL) {
			return BoundNumbers.TOO_SMALL;
		} else if (d > BoundNumbers.TOO_BIG) {
			return BoundNumbers.TOO_BIG;
		} else {
			return d;
		}
	}

	/**
	 * Private constructor.
	 */
	private BoundNumbers() {

	}
}
package RN.algotrainings;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

import RN.DataSeries;
import RN.ENetworkImplementation;
import RN.ILayer;
import RN.INetwork;
import RN.TestNetwork;
import RN.dataset.InputData;
import RN.dataset.OutputData;
import RN.links.ELinkType;
import RN.links.Link;
import RN.nodes.ENodeType;
import RN.nodes.INode;
import RN.strategy.EStrategy;
import RN.strategy.Strategy;
import RN.strategy.StrategyFactory;
import javafx.scene.chart.LineChart;
import javafx.scene.control.TextArea;

/**
 * @author Eric Marchand
 *
 */
public class BackPropagationTrainer implements ITrainer {

	private static int maxTrainingCycles = 500;

	private double errorRate;
	private double absoluteError = 0.0D;

	private volatile boolean breakTraining = false;

	private ListIterator<InputData> inputDataSetIterator = null;
	private List<LineChart.Data<Number, Number>> errorLevel = new ArrayList<LineChart.Data<Number, Number>>(maxTrainingCycles);

	private static int trainCycleAbsolute = 0;

	private double learningRate = 0.5D;
	private double alphaDeltaWeight = 0.0D;
	private int meanPeriodCount = 0;

	private double delta = 0.05;
	private double delay = 0.1;
	
	private InputData currentEntry = null;
	private OutputData currentOutputData = null;

	public BackPropagationTrainer() {
		errorRate = 0;
	}

	public void initTrainer() {
		trainCycleAbsolute = 0;
		errorLevel.clear();
	}

	
	@Override
	public void launchTrain() throws Exception {
		launchTrain(true, null);
	}
	
	/*
	 * (non-Javadoc)
	 * 
	 * @see RN.ITester#lauchTrain(java.lang.Long, java.lang.Long)
	 */
	@Override
	public void launchTrain(boolean verbose, TextArea console) throws Exception {

		int samplesNb = DataSeries.getInstance().getInputDataSet().size();
		breakTraining = false;
		
		if (samplesNb > 0) {

			int trainCycle = 0;
			absoluteError = 0.0D;
			double sigmaAbsoluteError = 0.0D;
			Strategy strategy = StrategyFactory.create(getNetwork(), EStrategy.AUTO_GROWING_HIDDENS);
			do {
				
				long start = System.currentTimeMillis();
				
				absoluteError = 0.0D;
				getNetwork().newLearningCycle(trainCycleAbsolute);
				for (int ind = 1; ind <= samplesNb; ind++) {
					train();
					absoluteError += getErrorRate();
				}
				absoluteError =  Math.sqrt(absoluteError / samplesNb);
				getNetwork().setAbsoluteError(absoluteError);

				// Sampling 1/10 de l'affichage de l'erreur
				if(trainCycle % (maxTrainingCycles / 100) == 0)
					errorLevel.add(new LineChart.Data<Number, Number>(trainCycleAbsolute, absoluteError));
				
//				if(ViewerFX.growingHiddens.isSelected() && (trainCycle % 20 == 0) && sigmaAbsoluteError > 0.0D && ((sigmaAbsoluteError / (trainCycle + 1)) <= absoluteError * 1.1D))
//					strategy.apply();
//				
				long stop = System.currentTimeMillis();
				if (verbose) {
					if(console != null)
						console.appendText("Stage #" + trainCycleAbsolute + "    Error: " + absoluteError + "    Error mean: " + (sigmaAbsoluteError / (trainCycle + 1)) + "    Duration: "+ (stop-start)/1000 + " second(s)"+ "\n");
					else
						System.out.println("Stage #" + trainCycleAbsolute + "    Error: " + absoluteError + "    Error mean: " + (sigmaAbsoluteError / (trainCycle + 1)) + "    Duration: "+ (stop-start)/1000 + " second(s)");
				}
				
				trainCycleAbsolute++;
				trainCycle++;
				sigmaAbsoluteError += absoluteError;
				// }while(train.getErrorRate() > 0.00001);
			} while (!breakTraining && trainCycle < maxTrainingCycles && absoluteError > 0.001);

		}
	}

	public void train() throws Exception {

			boolean playAgain = iterateHasNext();
			
			// feed forward
			currentOutputData = getNetwork().propagation(playAgain);
	
			backPropagateError();
			

	}

	private boolean iterateHasNext() {
		
		DataSeries data = DataSeries.getInstance();
		ILayer firstLayer = getNetwork().getFirstLayer();
		ILayer lastLayer = getNetwork().getLastLayer();
		Iterator<INode> outputNodeIter = null;
		Iterator<Double> inputIter = null;
		
		boolean isSameTrainingInputs = true;
		

		// init de l'erreur totale sur la couche de sortie
		setErrorRate(0.0);

		// si l'iterator n'existe pas on le cree
		if (inputDataSetIterator == null) {
			inputDataSetIterator = data.getInputDataSet().listIterator(0);
		}
		
		if (!inputDataSetIterator.hasNext()) {
			
			if(data.getInputDataSet().size() == 1){
				return true;
			}
			
			inputDataSetIterator = data.getInputDataSet().listIterator(0);
		}

		// prochain jeu de test
		if (inputDataSetIterator.hasNext()) {
			
			int nextIndex = inputDataSetIterator.nextIndex();
			currentEntry = inputDataSetIterator.next();

			inputIter = currentEntry.getInput().iterator();
			Integer offset = getNetwork().getTimeSeriesOffset();
			Double inputValue = null;
			int dataSetSize = data.getInputDataSet().size();
			int n = 1;

			ListIterator<InputData> tmpItr = null;

			List<INode> firstLayerNodes = firstLayer.getLayerNodes();
			for (INode node : firstLayerNodes) {

				if (node.getNodeType() == ENodeType.TIMESERIE) {

					if (tmpItr != null && tmpItr.hasNext()) {
						InputData indata = (InputData) tmpItr.next();
						inputIter = indata.getInput().listIterator();
					}

					if (inputIter.hasNext()) {
						inputValue = inputIter.next();
						node.setEntry(inputValue);

						if ((nextIndex + (n * offset)) < dataSetSize - 1)
							tmpItr = DataSeries.getInstance().getInputDataSet().listIterator(nextIndex + (n * offset));
						else {
							nextIndex = nextIndex - dataSetSize + 1;
							tmpItr = DataSeries.getInstance().getInputDataSet().listIterator(nextIndex + (n * offset));
						}

					} else {
						node.setEntry(0.0D);
					}

				}else if(node.getNodeType() == ENodeType.REGULAR || node.getNodeType() == ENodeType.PIXEL){
					
					inputValue = currentEntry.getInput().get(node.getNodeId());
					
					if(!inputValue.equals(node.getEntry()))
						isSameTrainingInputs = false;
					
					node.setEntry(inputValue);
					
				}else{
					continue;
				}
				
				n++;

			}

			// for sur une sortie ideale du jeu
			INode node = null;
			outputNodeIter = lastLayer.getLayerNodes(ENodeType.REGULAR).iterator();
			for (Double ideal : currentEntry.getIdeal()) {
				if (outputNodeIter.hasNext()) {
					node = outputNodeIter.next();
					node.setIdealOutput(ideal);
				}
			}

		}
		
		return isSameTrainingInputs;
	}

	public void nextTrainInputValues() {

		DataSeries data = DataSeries.getInstance();
		ILayer lastLayer = getNetwork().getLastLayer();
		Iterator<INode> outputNodeIter = null;

		// init de l'erreur totale sur la couche de sortie
		setErrorRate(0.0);

		if (inputDataSetIterator == null) {
			inputDataSetIterator = data.getInputDataSet().listIterator();
		}
		if (!inputDataSetIterator.hasNext()) {
			inputDataSetIterator = data.getInputDataSet().listIterator();
		}

		// prochain jeu de test
		if (inputDataSetIterator.hasNext()) {
			int nextIndex = inputDataSetIterator.nextIndex();
			InputData entries = inputDataSetIterator.next();

			Iterator<Double> inputIter = entries.getInput().iterator();
			Integer offset = getNetwork().getTimeSeriesOffset();
			Double inputValue = null;
			
			int dataSetSize = data.getInputDataSet().size();
			int n = 1;

			ListIterator<InputData> tmpItr = null;

			List<INode> firstLayerNodes = getNetwork().getFirstLayer().getLayerNodes();
			for (INode node : firstLayerNodes) {

				if (node.getNodeType() == ENodeType.TIMESERIE) {

					if (tmpItr != null && tmpItr.hasNext()) {
						InputData indata = (InputData) tmpItr.next();
						inputIter = indata.getInput().listIterator();
					}

					if (inputIter.hasNext()) {
						inputValue = inputIter.next();
						node.setEntry(inputValue);

						if ((nextIndex + (n * offset)) < dataSetSize - 1)
							tmpItr = DataSeries.getInstance().getInputDataSet().listIterator(nextIndex + (n * offset));
						else {
							nextIndex = nextIndex - dataSetSize + 1;
							tmpItr = DataSeries.getInstance().getInputDataSet().listIterator(nextIndex + (n * offset));
						}

					} else {
						node.setEntry(0.0D);
					}

				}else if(node.getNodeType() == ENodeType.REGULAR  ||
						node.getNodeType() == ENodeType.PIXEL){
					inputValue = entries.getInput().get(node.getNodeId());
					node.setEntry(inputValue);
				}else{
					continue;
				}
				
				n++;

			}


			// for sur une sortie ideale du jeu
			INode node = null;
			outputNodeIter = lastLayer.getLayerNodes(ENodeType.REGULAR).iterator();
			for (double ideal : entries.getIdeal()) {
				if (outputNodeIter.hasNext()) {
					node = outputNodeIter.next();
					node.setIdealOutput(ideal);
				}
			}

		}

		initError();

	}


	public void initError() {
		for (INode node : getNetwork().getAllNodes()) {
			node.setDerivatedError(0.0);
		}
	}

	public void feedForward() {
		// feed forward
		try {
			getNetwork().propagation(false);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}


	private boolean backPropagateError() throws Exception {

		List<ILayer> layers = getNetwork().getLayers();
		int layerCount = layers.size();
		ILayer layer = null;

		setErrorRate(0.0D);

		for (int ind = layerCount - 1; ind >= 0; ind--) {
			
			layer = layers.get(ind);
			layer.setLayerError(0.0D);
			
			for (final INode node : layer.getLayerNodes(ENodeType.REGULAR, ENodeType.PIXEL)) {

				if(!node.getArea().getLinkage().isWeightModifiable())
					continue;
				
				double derivatedError = 0.0D;

				// la valeur dérivée à été calculée lors du feedforward
				
				if (layer.isLastLayer()) {
					// on defini l'erreur totale de la couche de sortie
					derivatedError = node.getError() * node.getDerivativeValue();
					// on se dirige vers les minimum locaux (TODO a modifier)
					// Backpropagation in-line (not batch), algo LMS (Least Mean Squared)
					errorRate += Math.pow(node.getError(), 2.0D);

				} else {

					// somme pondérés du produit des poids des noeuds reliés sur
					// la couche précédente et de l'erreur du noeud reliés sur
					// la couche precedente
					if(getNetwork().getImpl() == ENetworkImplementation.LINKED){
						
						for (Link link : node.getOutputs()) {
							if(link != null && (link.getType() == ELinkType.REGULAR || link.getType() == ELinkType.SHARED)){
								derivatedError += link.getWeight() * link.getTargetNode().getDerivatedError();
							}
						}
						
					}else{
						
						// TODO Optimiser la methode
						derivatedError = node.getDerivatedErrorSum();
						
					}
					
					node.setError(derivatedError);
					
					derivatedError *= node.getDerivativeValue();

				}

				// on defini l'erreur aggregé sur le node
				// node.setDerivatedError(node.getDerivatedError() + derivatedError);
				// la backpropagation in-line ne cumule pas les erreurs sur les
				// differents jeux de test
				
				node.setDerivatedError(derivatedError);
				
				layer.setLayerError(layer.getLayerError() + derivatedError);
				
				node.updateWeights(learningRate, alphaDeltaWeight);
					
			}

			// on ne calcul pas le delta des poids si la sortie et egale au
			// resultat désiré, on sort dés la première itération
			if (layer.isLastLayer() && getErrorRate() == 0.0D)
				return false;

		}

		return true;

	}
	
	


	/*
	 * (non-Javadoc)
	 * 
	 * @see RN.ITester#getLearningRate()
	 */
	@Override
	public double getLearningRate() {
		return learningRate;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see RN.ITester#getAlphaDeltaWeight()
	 */
	@Override
	public double getAlphaDeltaWeight() {
		return alphaDeltaWeight;
	}

	@Override
	public double getErrorRate() {
		return this.errorRate;
	}

	public void setErrorRate(double errorRate) {
		this.errorRate = errorRate;
	}

	public void setLearningRate(double learningRate) {
		this.learningRate = learningRate;
	}

	public void setAlphaDeltaWeight(double alphaDeltaWeight) {
		this.alphaDeltaWeight = alphaDeltaWeight;
	}

	@Override
	public double getDelay() {
		return delay;
	}

	@Override
	public double getDelta() {
		return delta;
	}

	public INetwork getNetwork() {
		return TestNetwork.network;
	}

	public Iterator<InputData> getInputDataSetIterator() {
		return inputDataSetIterator;
	}

	public void setInputDataSetIterator(ListIterator<InputData> inputDataSetIterator) {
		this.inputDataSetIterator = inputDataSetIterator;
	}

	public List<LineChart.Data<Number, Number>> getErrorLevelLines() {
		return errorLevel;
	}

	public void setErrorLevelLines(List<LineChart.Data<Number, Number>> errorLevel) {
		this.errorLevel = errorLevel;
	}

	public InputData getCurrentEntry() {
		return currentEntry;
	}

	public void setCurrentEntry(InputData currentEntry) {
		this.currentEntry = currentEntry;
	}

	public OutputData getCurrentOutputData() {
		return currentOutputData;
	}

	public void setCurrentOutputData(OutputData currentOutputData) {
		this.currentOutputData = currentOutputData;
	}

	public boolean isBreakTraining() {
		return breakTraining;
	}

	public void setBreakTraining(boolean breakTraining) {
		this.breakTraining = breakTraining;
	}

	public double getAbsoluteError() {
		return absoluteError;
	}

	public void setAbsoluteError(double absoluteError) {
		this.absoluteError = absoluteError;
	}

	public int getMaxTrainingCycles() {
		return maxTrainingCycles;
	}

	public void setMaxTrainingCycles(int maxTrainingCycles) {
		BackPropagationTrainer.maxTrainingCycles = maxTrainingCycles;
	}


	
}
package RN.algotrainings;

import java.util.List;
import java.util.ListIterator;

import javafx.scene.chart.LineChart;
import RN.dataset.InputData;
import RN.dataset.OutputData;


/**
 * @author Eric Marchand
 *
 */
public interface ITrain {

	void train() throws Exception;

	double getErrorRate();

	public abstract void nextTrainInputValues();

	public abstract void launchTrain() throws Exception;

	public abstract double getDelay();
	
	public abstract double getDelta();

	public abstract double getLearningRate();

	public abstract void setLearningRate(double learningRate);

	public abstract double getAlphaDeltaWeight();

	public abstract void setAlphaDeltaWeight(double alphaDeltaWeight);

	void feedForward() throws Exception;

	void setInputDataSetIterator(ListIterator<InputData> inputDataSetIterator);
	
	List<LineChart.Data<Number, Number>> getLines();
	
	void setLines(List<LineChart.Data<Number, Number>> lines);

	void initTrainer();

	InputData getCurrentEntry();

	OutputData getCurrentOutputData();
	
	void setBreakTraining(boolean breakTraining);
	
	double getAbsoluteError();

	void setMaxTrainingCycles(int maxTrainingCycles);

}
package RN.algotrainings;

import java.util.List;
import java.util.ListIterator;

import RN.dataset.InputData;
import RN.dataset.OutputData;
import javafx.scene.chart.LineChart;
import javafx.scene.control.TextArea;


/**
 * @author Eric Marchand
 *
 */
public interface ITrainer {

	void train() throws Exception;

	double getErrorRate();

	public abstract void nextTrainInputValues();

	void launchTrain() throws Exception;
	
	void launchTrain(boolean verbose, TextArea console) throws Exception;

	public abstract double getDelay();
	
	public abstract double getDelta();

	public abstract double getLearningRate();

	public abstract void setLearningRate(double learningRate);

	public abstract double getAlphaDeltaWeight();

	public abstract void setAlphaDeltaWeight(double alphaDeltaWeight);

	void feedForward() throws Exception;

	void setInputDataSetIterator(ListIterator<InputData> inputDataSetIterator);
	
	List<LineChart.Data<Number, Number>> getErrorLevelLines();
	
	void setErrorLevelLines(List<LineChart.Data<Number, Number>> lines);

	void initTrainer();

	InputData getCurrentEntry();

	OutputData getCurrentOutputData();
	
	void setBreakTraining(boolean breakTraining);
	
	double getAbsoluteError();

	void setMaxTrainingCycles(int maxTrainingCycles);

}
package RN.algotrainings;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

import RN.DataSeries;
import RN.ILayer;
import RN.INetwork;
import RN.TestNetwork;
import RN.dataset.InputData;
import RN.dataset.OutputData;
import RN.links.ELinkType;
import RN.links.Link;
import RN.nodes.ENodeType;
import RN.nodes.INode;
import RN.nodes.LSTMNode;
import RN.strategy.EStrategy;
import RN.strategy.Strategy;
import RN.strategy.StrategyFactory;
import javafx.scene.chart.LineChart;
import javafx.scene.control.TextArea;

/**
 * @author Eric Marchand
 *
 */
public class LSTMBackwardPassTraining implements ITrainer {

	private static int maxTrainingCycles = 500;

	private double errorRate;
	private double absoluteError = 0.0D;

	private volatile boolean breakTraining = false;

	private ListIterator<InputData> inputDataSetIterator = null;
	private List<LineChart.Data<Number, Number>> lines = new ArrayList<LineChart.Data<Number, Number>>(maxTrainingCycles);

	private static int trainCycleAbsolute = 0;

	private double learningRate = 1.0D;
	private double alphaDeltaWeight = 0.0D;
	private int meanPeriodCount = 0;

	private double delta = 0.05;
	private double delay = 0.1;
	
	private InputData currentEntry = null;
	private OutputData currentOutputData = null;

	public LSTMBackwardPassTraining() {
		errorRate = 0;
	}

	public void initTrainer() {
		trainCycleAbsolute = 0;
		lines.clear();
	}

	@Override
	public void launchTrain() throws Exception {
		launchTrain(true, null);
	}
	
	/*
	 * (non-Javadoc)
	 * 
	 * @see RN.ITester#lauchTrain(java.lang.Long, java.lang.Long)
	 */
	@Override
	public void launchTrain(boolean verbose, TextArea console) throws Exception {

		int samplesNb = DataSeries.getInstance().getInputDataSet().size();
		breakTraining = false;
		
		if (samplesNb > 0) {

			int trainCycle = 0;
			absoluteError = 0.0D;
			double sigmaAbsoluteError = 0.0D;
			Strategy strategy = StrategyFactory.create(getNetwork(), EStrategy.AUTO_GROWING_HIDDENS);
			do {
				absoluteError = 0.0D;
				for (int ind = 1; ind <= samplesNb; ind++) {
					train();
					absoluteError += getErrorRate();
				}
				absoluteError =  Math.sqrt(absoluteError / samplesNb);
				getNetwork().setAbsoluteError(absoluteError);

				// Sampling 1/10 de l'affichage de l'erreur
				if(trainCycle % (maxTrainingCycles / 100) == 0)
					lines.add(new LineChart.Data<Number, Number>(trainCycleAbsolute, absoluteError));
				
//				if(ViewerFX.growingHiddens.isSelected() && (trainCycle % 20 == 0) && sigmaAbsoluteError > 0.0D && ((sigmaAbsoluteError / (trainCycle + 1)) <= absoluteError * 1.1D))
//					strategy.apply();
//				
				
				if (verbose && (trainCycle % 100 == 0)) {
					if(console != null)
						console.appendText("Stage #" + trainCycleAbsolute + " Error:" + absoluteError + "  Error mean:" + (sigmaAbsoluteError / (trainCycle + 1)) + "\n");
					else
						System.out.println("Stage #" + trainCycleAbsolute + " Error:" + absoluteError + "  Error mean:" + (sigmaAbsoluteError / (trainCycle + 1)));
				}
				
				
				
				trainCycleAbsolute++;
				trainCycle++;
				sigmaAbsoluteError += absoluteError;
				// }while(train.getErrorRate() > 0.00001);
			} while (!breakTraining && trainCycle < maxTrainingCycles && absoluteError > 0.001);

		}
	}

	public void train() throws Exception {

		if(iterateHasNext()){
		
			// feed forward
			currentOutputData = getNetwork().propagation(true);
	
			backPropagateError();
			
		}

	}

	private boolean iterateHasNext() {
		DataSeries data = DataSeries.getInstance();
		ILayer firstLayer = getNetwork().getFirstLayer();
		ILayer lastLayer = getNetwork().getLastLayer();
		Iterator<INode> outputNodeIter = null;
		Iterator<Double> inputIter = null;
		boolean hasNext = false;
		

		// init de l'erreur totale sur la couche de sortie
		setErrorRate(0.0);

		// si l'iterator n'existe pas on le cree
		if (inputDataSetIterator == null) {
			inputDataSetIterator = data.getInputDataSet().listIterator(0);
		}
		if (!inputDataSetIterator.hasNext()) {
			// return;
			inputDataSetIterator = data.getInputDataSet().listIterator(0);
		}

		// prochain jeu de test
		if (inputDataSetIterator.hasNext()) {
			hasNext = true;
			int nextIndex = inputDataSetIterator.nextIndex();
			currentEntry = inputDataSetIterator.next();

			inputIter = currentEntry.getInput().iterator();
			Integer offset = getNetwork().getTimeSeriesOffset();
			Double inputValue = null;
			int dataSetSize = data.getInputDataSet().size();
			int n = 1;

			ListIterator<InputData> tmpItr = null;

			List<INode> firstLayerNodes = firstLayer.getLayerNodes();
			for (INode node : firstLayerNodes) {

				if (node.getNodeType() == ENodeType.TIMESERIE) {

					if (tmpItr != null && tmpItr.hasNext()) {
						InputData indata = (InputData) tmpItr.next();
						inputIter = indata.getInput().listIterator();
					}

					if (inputIter.hasNext()) {
						inputValue = inputIter.next();
						node.setEntry(inputValue);

						if ((nextIndex + (n * offset)) < dataSetSize - 1)
							tmpItr = DataSeries.getInstance().getInputDataSet().listIterator(nextIndex + (n * offset));
						else {
							nextIndex = nextIndex - dataSetSize + 1;
							tmpItr = DataSeries.getInstance().getInputDataSet().listIterator(nextIndex + (n * offset));
						}

					} else {
						node.setEntry(0.0D);
					}

				}else if(node.getNodeType() == ENodeType.REGULAR){
					inputValue = currentEntry.getInput().get(node.getNodeId());
					node.setEntry(inputValue);
				}else{
					continue;
				}
				
				n++;

			}

			// for sur une sortie ideale du jeu
			INode node = null;
			outputNodeIter = lastLayer.getLayerNodes(ENodeType.REGULAR).iterator();
			for (Double ideal : currentEntry.getIdeal()) {
				if (outputNodeIter.hasNext()) {
					node = outputNodeIter.next();
					node.setIdealOutput(ideal);
				}
			}

		}
		
		return hasNext;
	}

	public void nextTrainInputValues() {

		DataSeries data = DataSeries.getInstance();
		ILayer firstLayer = getNetwork().getFirstLayer();
		ILayer lastLayer = getNetwork().getLastLayer();
		Iterator<INode> outputNodeIter = null;

		// init de l'erreur totale sur la couche de sortie
		setErrorRate(0.0);

		if (inputDataSetIterator == null) {
			inputDataSetIterator = data.getInputDataSet().listIterator();
		}
		if (!inputDataSetIterator.hasNext()) {
			inputDataSetIterator = data.getInputDataSet().listIterator();
		}

		// prochain jeu de test
		if (inputDataSetIterator.hasNext()) {
			int nextIndex = inputDataSetIterator.nextIndex();
			InputData entries = inputDataSetIterator.next();

			Iterator<Double> inputIter = entries.getInput().iterator();
			Integer offset = getNetwork().getTimeSeriesOffset();
			Double inputValue = null;
			
			int dataSetSize = data.getInputDataSet().size();
			int n = 1;

			ListIterator<InputData> tmpItr = null;

			List<INode> firstLayerNodes = getNetwork().getFirstLayer().getLayerNodes();
			for (INode node : firstLayerNodes) {

				if (node.getNodeType() == ENodeType.TIMESERIE) {

					if (tmpItr != null && tmpItr.hasNext()) {
						InputData indata = (InputData) tmpItr.next();
						inputIter = indata.getInput().listIterator();
					}

					if (inputIter.hasNext()) {
						inputValue = inputIter.next();
						node.setEntry(inputValue);

						if ((nextIndex + (n * offset)) < dataSetSize - 1)
							tmpItr = DataSeries.getInstance().getInputDataSet().listIterator(nextIndex + (n * offset));
						else {
							nextIndex = nextIndex - dataSetSize + 1;
							tmpItr = DataSeries.getInstance().getInputDataSet().listIterator(nextIndex + (n * offset));
						}

					} else {
						node.setEntry(0.0D);
					}

				}else if(node.getNodeType() == ENodeType.REGULAR){
					inputValue = entries.getInput().get(node.getNodeId());
					node.setEntry(inputValue);
				}else{
					continue;
				}
				
				n++;

			}


			// for sur une sortie ideale du jeu
			INode node = null;
			outputNodeIter = lastLayer.getLayerNodes(ENodeType.REGULAR).iterator();
			for (double ideal : entries.getIdeal()) {
				if (outputNodeIter.hasNext()) {
					node = outputNodeIter.next();
					node.setIdealOutput(ideal);
				}
			}

		}

		initError();

	}

	//
	// public void nextTrainInputValues(InputData entries) {
	//
	// // set input values
	// Layer firstLayer = getNetwork().getFirstLayer();
	// Layer lastLayer = getNetwork().getLastLayer();
	// Iterator<Node> outputNodeIter = null;
	//
	// // init de l'erreur totale sur la couche de sortie
	// setErrorRate(0.0);
	//
	// // prochain jeu de test
	// if (entries != null) {
	//
	// outputNodeIter = lastLayer.getLayerNodes(ENodeType.REGULAR).iterator();
	//
	// List<Node> firstLayerNodes = firstLayer.getLayerNodes(ENodeType.REGULAR);
	// Iterator<Double> inputIter = entries.getInput().iterator();
	//
	// Double inputValue;
	// for (Node node : firstLayerNodes) {
	//
	// if (inputIter.hasNext()) {
	// inputValue = inputIter.next();
	// node.getInputs().get(0).setValue(inputValue);
	// // pas de fonction de transfert pour la couche d'entree
	// // node.getOutput().setValue(entry);
	//
	// }
	//
	// }
	//
	// // for sur une sortie ideale du jeu
	// Node node = null;
	// for (double ideal : entries.getIdeal()) {
	// if (outputNodeIter.hasNext()) {
	// node = outputNodeIter.next();
	// node.setIdealOutput(ideal);
	// }
	// }
	//
	// }
	//
	// initError();
	//
	// }

	public void initError() {
		for (INode node : getNetwork().getAllNodes()) {
			node.setDerivatedError(0.0);
		}
	}

	public void feedForward() {
		// feed forward
		try {
			getNetwork().propagation(true);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}


	private boolean backPropagateError() throws Exception {

		List<ILayer> layers = getNetwork().getLayers();
		int layerCount = layers.size();
		ILayer layer = null;

		setErrorRate(0.0D);

		for (int ind = layerCount - 1; ind >= 0; ind--) {
			layer = layers.get(ind);
			layer.setLayerError(0.0D);
			for (final INode node : layer.getLayerNodes()) {
				
				if(node.getNodeType() == ENodeType.REGULAR){

				double derivativeGx = 0.0D;
				double derivatedError = 0.0D;

				// la valeur dérivée à été calculée lors du feedforward, on la
				// récupere.
				derivativeGx = node.getDerivativeValue();

				if (layer.isLastLayer()) {
					// on defini l'erreur totale de la couche de sortie
					derivatedError = node.getError() * derivativeGx;
					// on se dirige vers les minimum locaux : TODO a modifier
					// backpropagation in-line (not batch), algo LMS (Least Mean
					// Squared)
					errorRate += Math.pow(node.getError(), 2.0D);

				} else {

					// somme pondérés du produit des poids des noeuds reliés sur
					// la couche précédente et de l'erreur du noeud reliés sur
					// la couche precedente
					for (Link link : node.getOutputs()) {
						if(link.getType() == ELinkType.REGULAR){
							derivatedError += link.getWeight() * link.getTargetNode().getDerivatedError();
						}
					}
					derivatedError *= derivativeGx;

				}

				// on defini l'erreur aggregé sur le node
				// node.setDerivatedError(node.getDerivatedError() + derivatedError);
				// la backpropagation in-line ne cumule pas les erreurs sur les
				// differents jeux de test
				node.setDerivatedError(derivatedError);
				layer.setLayerError(layer.getLayerError() + derivatedError);
				
				
				node.updateWeights(learningRate, alphaDeltaWeight);
				
				} else if(node.getNodeType() == ENodeType.LSTM){

					LSTMNode lstm = (LSTMNode) node;
					double derivativeGx = 0.0D;
					double derivatedError = 0.0D;

					for (Link link : node.getOutputs()) {
						if(link.getType() == ELinkType.REGULAR){
							derivatedError = link.getWeight() * link.getTargetNode().getDerivatedError();
						}
						
						INode piOutputNode = link.getSourceNode();
						derivatedError *= node.getDerivativeValue();
						
						
					}
					
					
//					lstm.
					
					
					
				}
					
			}

			// on ne calcul pas le delta des poids si la sortie et egale au
			// resultat désiré
			if (layer.isLastLayer() && getErrorRate() == 0.0)
				return false;

		}

		return true;

	}


	/*
	 * (non-Javadoc)
	 * 
	 * @see RN.ITester#getLearningRate()
	 */
	@Override
	public double getLearningRate() {
		return learningRate;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see RN.ITester#getAlphaDeltaWeight()
	 */
	@Override
	public double getAlphaDeltaWeight() {
		return alphaDeltaWeight;
	}

	@Override
	public double getErrorRate() {
		return this.errorRate;
	}

	public void setErrorRate(double errorRate) {
		this.errorRate = errorRate;
	}

	public void setLearningRate(double learningRate) {
		this.learningRate = learningRate;
	}

	public void setAlphaDeltaWeight(double alphaDeltaWeight) {
		this.alphaDeltaWeight = alphaDeltaWeight;
	}

	@Override
	public double getDelay() {
		return delay;
	}

	@Override
	public double getDelta() {
		return delta;
	}

	public INetwork getNetwork() {
		return TestNetwork.network;
	}

	public Iterator<InputData> getInputDataSetIterator() {
		return inputDataSetIterator;
	}

	public void setInputDataSetIterator(ListIterator<InputData> inputDataSetIterator) {
		this.inputDataSetIterator = inputDataSetIterator;
	}

	public List<LineChart.Data<Number, Number>> getErrorLevelLines() {
		return lines;
	}

	public void setErrorLevelLines(List<LineChart.Data<Number, Number>> lines) {
		this.lines = lines;
	}

	public InputData getCurrentEntry() {
		return currentEntry;
	}

	public void setCurrentEntry(InputData currentEntry) {
		this.currentEntry = currentEntry;
	}

	public OutputData getCurrentOutputData() {
		return currentOutputData;
	}

	public void setCurrentOutputData(OutputData currentOutputData) {
		this.currentOutputData = currentOutputData;
	}

	public boolean isBreakTraining() {
		return breakTraining;
	}

	public void setBreakTraining(boolean breakTraining) {
		this.breakTraining = breakTraining;
	}

	public double getAbsoluteError() {
		return absoluteError;
	}

	public void setAbsoluteError(double absoluteError) {
		this.absoluteError = absoluteError;
	}

	public int getMaxTrainingCycles() {
		return maxTrainingCycles;
	}

	public void setMaxTrainingCycles(int maxTrainingCycles) {
		LSTMBackwardPassTraining.maxTrainingCycles = maxTrainingCycles;
	}


	
}
package RN.algotrainings;

import java.io.IOException;
import java.util.List;
import java.util.ListIterator;

import RN.DataSeries;
import RN.TestLSTMNetwork;
import RN.ViewerFX;
import RN.dataset.InputData;
import RN.dataset.OutputData;
import dmonner.xlbp.Network;
import dmonner.xlbp.compound.InputCompound;
import dmonner.xlbp.compound.XEntropyTargetCompound;
import javafx.collections.FXCollections;
import javafx.scene.chart.LineChart;
import javafx.scene.chart.ScatterChart;
import javafx.scene.chart.XYChart;
import javafx.scene.chart.XYChart.Data;
import javafx.scene.control.TextArea;

/**
 * @author Eric Marchand
 *
 */
public class LSTMTrainer implements ITrainer {

	private static LSTMTrainer instance;
	
	private double errorRate;
	
	final public static double delta = 0.0;
	
	final public static double delay = 0.0;	
	
	static int trainCycleAbsolute = 0;
	
	public static LSTMTrainer getInstance() {
		if (instance == null) {
			instance = new LSTMTrainer();
		}

		return instance;
	}
	
	@Override
	public void train() throws Exception {
		launchTrain();
	}
	
	@Override
	public void launchTrain() throws IOException {
		launchTrain(true, null);
	}
	

	@Override
	public void launchTrain(boolean verbose, TextArea console) throws IOException {

		DataSeries dataSeries = DataSeries.getInstance();
		InputCompound in = TestLSTMNetwork.getInstance().getIn();
		XEntropyTargetCompound out = TestLSTMNetwork.getInstance().getOut();
		Network net = (Network) TestLSTMNetwork.getNet();
		
		
		LineChart<Number, Number> sc = ViewerFX.lineChart;
		if (sc.getData() == null)
			sc.setData(FXCollections.<XYChart.Series<Number, Number>> observableArrayList());
		LineChart.Series<Number, Number> series = new LineChart.Series<Number, Number>();
		series.setName("Train " + (sc.getData().size() + 1));

		
		int trainCycle = 0;
		double absoluteError = 0.0D;
		double squaredError = 0.0D;
		do {
			absoluteError = 0.0D;
			
			// prochain jeu de test
			for (InputData entries : dataSeries.getInputDataSet()) {

				// init de l'erreur totale sur la couche de sortie
				setErrorRate(0.0);
				
				// Clears the network, setting all units to their default
				// activation levels
				// net.clear();

				// for(int i = 0; i < insize; i++)
				// input[i] = (float) Math.random();

				// Impose an input vector on the units of the input layer
				in.setInput(entries.getInputArray());

				// Activate the layers of the network, caching information
				// necessary for weight updates;
				// If we're not updating weights on this trial, activateTest()
				// is faster.
				net.activateTrain();

				// If we're going to update weights, we need to update each
				// unit's eligibility.
				net.updateEligibilities();

				// for(int i = 0; i < outsize; i++)
				// target[i] = (float) Math.random();

				// Set the target vector that the output layer should be trying
				// to obtain, for training.
				out.setTarget(entries.getIdealArray());

				// Propagate unit responsibilities backwards from the output
				// according to LSTM-g
				net.updateResponsibilities();

				// Update the weights according to LSTM-g
				net.updateWeights();

				for(int idx = 0 ; idx < entries.getIdealArray().length; idx++){
					squaredError =  Math.pow(entries.getIdealArray()[idx] - out.getOutput().getActivations()[idx], 2.0D) / 2.0D;
					errorRate += squaredError;
					absoluteError += squaredError;
				}
//				if(trainCycleAbsolute % 100 == 0)
//					System.out.println("X#" + trainCycleAbsolute + " Error:" + absoluteError + " ideal:" + entries.getIdealArray()[0] + " res:"+ out.getOutput().getActivations()[0]);
				
			}
			
			if (verbose && trainCycleAbsolute % 100 == 0) {
				if(console != null)
					console.appendText("Stage #" + trainCycleAbsolute + " Error:" + absoluteError + "\n");
				else
					System.out.println("Stage #" + trainCycleAbsolute + " Error:" + absoluteError);
			}
			
			series.getData().add(new ScatterChart.Data<Number, Number>(trainCycle++, absoluteError));
			trainCycleAbsolute++;
		} while (trainCycle < 500);

		sc.getData().add(series);
		// System.out.println(net.toString("NICXW"));

	}

	
	public double getDelta() {
		return delta;
	}

	public double getDelay() {
		return delay;
	}
	

	@Override
	public double getErrorRate() {
		// TODO Auto-generated method stub
		return this.errorRate;
	}
	
	private void setErrorRate(double d) {
		this.errorRate = d;
	}	

	@Override
	public void nextTrainInputValues() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void feedForward() {
		// TODO Auto-generated method stub
		
	}

	public void computeDeltaWeights() {
		// TODO Auto-generated method stub
		
	}

	public void updateAllWeights() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void setLearningRate(double learningRate) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void setAlphaDeltaWeight(double alphaDeltaWeight) {
		// TODO Auto-generated method stub
		
	}


	@Override
	public double getLearningRate() {
		// TODO Auto-generated method stub
		return 0;
	}


	@Override
	public double getAlphaDeltaWeight() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void setInputDataSetIterator(ListIterator<InputData> inputDataSetIterator) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public List<Data<Number, Number>> getErrorLevelLines() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setErrorLevelLines(List<Data<Number, Number>> lines) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void initTrainer() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public InputData getCurrentEntry() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public OutputData getCurrentOutputData() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setBreakTraining(boolean breakTraining) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public double getAbsoluteError() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void setMaxTrainingCycles(int maxTrainingCycles) {
		// TODO Auto-generated method stub
		
	}



}
package RN.algotrainings.tests;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import RN.INetwork;
import RN.ITester;
import RN.TestNetwork;
import RN.algotrainings.BackPropagationTrainer;
import RN.algotrainings.ITrainer;
import RN.dataset.inputsamples.InputSample;
import javafx.application.Application;
import javafx.stage.Stage;

/**
 * @author Eric Marchand
 *
 */
public class BackPropagationTrainingTest extends Application{

	public static ITester tester = null;
	public static ITrainer trainer = null;
	public static INetwork network = null;
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		
		Thread t = new Thread("JavaFX Init Thread") {
	        public void run() {
	        	
	        	Application.launch(BackPropagationTrainingTest.class, new String[0]);
	        	
	        }
	    };
	    t.setDaemon(true);
	    t.start();
	    Thread.sleep(1000);
		
		
		tester = TestNetwork.getInstance();
		trainer = new BackPropagationTrainer();
		InputSample.setFileSample(tester, tester.getFilePath(), 5);
		network = tester.getNetwork();
		System.out.println(network.getString());
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
	}

	@Before
	public void setUp() throws Exception {
	}

	@After
	public void tearDown() throws Exception {
	}

	@Test
	public final void testInitTrainer() {
		trainer.initTrainer();
	}

	@Test
	public final void testLaunchTrain() throws Exception {
		trainer.launchTrain();
		System.out.println(network.getString());
	}
	

	@Test
	public final void testTrain() throws Exception {
		trainer.train();
	}

	@Test
	public final void testNextTrainInputValues() {
		trainer.nextTrainInputValues();
	}

	@Test
	public final void testInitError() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testFeedForward() throws Exception {
		trainer.feedForward();
	}

	@Test
	public final void testGetLearningRate() {
		assertTrue(trainer.getLearningRate() == 0.5D);
	}

	@Test
	public final void testGetAlphaDeltaWeight() {
		assertTrue(trainer.getAlphaDeltaWeight() == 0.0D);
	}

	@Test
	public final void testGetErrorRate() {
		trainer.getErrorRate();
	}

	@Test
	public final void testSetErrorRate() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testSetLearningRate() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testSetAlphaDeltaWeight() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testGetDelay() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testGetDelta() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testGetNetwork() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testGetInputDataSetIterator() {
	}

	@Test
	public final void testSetInputDataSetIterator() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testGetLines() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testSetLines() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testGetCurrentEntry() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testSetCurrentEntry() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testGetCurrentOutputData() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testSetCurrentOutputData() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testIsBreakTraining() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testSetBreakTraining() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testGetAbsoluteError() {
		trainer.getAbsoluteError();
	}

	@Test
	public final void testSetAbsoluteError() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testGetMaxTrainingCycles() {
		fail("Not yet implemented"); // TODO
	}

	@Test
	public final void testSetMaxTrainingCycles() {
		fail("Not yet implemented"); // TODO
	}

	@Override
	public void start(Stage primaryStage) throws Exception {
		
	}

}
package RN;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import RN.algoactivations.EActivation;
import RN.dataset.inputsamples.ESamples;
import RN.linkage.DefaultLinkage;
import RN.linkage.EFilterPosition;
import RN.linkage.ELinkage;
import RN.linkage.ELinkageBetweenAreas;
import RN.linkage.FilterLinkage.FilterIndex;
import RN.linkage.IFilterLinkage;
import RN.linkage.ILinkage;
import RN.linkage.SigmaWi;
import RN.links.ELinkType;
import RN.nodes.ENodeType;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import RN.nodes.ImageNode;
import RN.nodes.LSTMNode;
import RN.nodes.Node;
import RN.nodes.PixelNode;
import RN.nodes.RecurrentNode;
import RN.utils.ReflexionUtils;

/**
 * @author Eric Marchand
 * 
 */
public class Area extends NetworkElement implements IArea{

	protected int areaId = 0;
	
	protected List<INode> nodes;

	protected ILayer layer;
	
	protected Boolean showImage = Boolean.FALSE;
	
	protected ImageNode imageArea = null;
	
	protected Integer widthPx = null;
	
	protected Integer heightPx = null;

	protected Integer nodeCenterX = null;
	
	protected Integer nodeCenterY = null;
	
	protected String comment = "";
	
	protected NodeFactory nodeFactory = new NodeFactory();
	
	protected ILinkage linkage = new DefaultLinkage();
	
	protected EActivation activation = EActivation.IDENTITY;
	
	Area(){
	}
	
	public Area(int nodeCount) {
	
		this.nodes = new ArrayList<INode>(nodeCount);
		
	}
	
	public Area(int nodeCount, boolean showImage) {
		
		this.nodes = new ArrayList<INode>(nodeCount);
		this.showImage = showImage;
		initWidthPx(nodeCount);
		if(showImage){
			this.imageArea = new ImageNode(EActivation.IDENTITY, this.widthPx, this.heightPx);
			this.imageArea.setArea(this);
		}

	}
	
	public void initWidthPx(int pixSize){
		
		if(pixSize == 0D)
			throw new RuntimeException("Le nombre de neurones dans la liste est vide.");
		
		// Colonne
		this.widthPx = 1;
		this.heightPx = pixSize;
		this.nodeCenterX = 1;
		this.nodeCenterY = pixSize / 2;
	}
	
	public void showImageArea() {
		comment = ": " + this.widthPx + "x" + this.heightPx;
		imageArea.getStage().setTitle((layer != null ? "Layer #" + layer.getLayerId() : "") + " Area #" + areaId + " " + comment);
		imageArea.initImageData();
		imageArea.insertDataArea();
		imageArea.drawImageData(null);

	}
	

	public List<INode> createNodes(int nodeCount){
		
		if(this.nodes != null && !this.nodes.isEmpty())
			this.nodes.addAll(nodeFactory.createNodes(this, nodeCount));
		else
			this.nodes = nodeFactory.createNodes(this, nodeCount);
		
		return this.nodes;
		
	}
	
	public IArea configureLinkage(ELinkage linkage, ELinkageBetweenAreas linkageAreas, Integer[] targetedAreas, ESamples eSampleFunction, boolean linkageWeightModifiable, Double... optParams){
		
		this.linkage = instantiateLinkage(linkage, this, linkageAreas, targetedAreas, eSampleFunction, linkageWeightModifiable, optParams);
		
		return this;
	}
	

	
	public IArea configureLinkage(ELinkage linkage, ELinkageBetweenAreas linkageAreas, Integer[] targetedAreas, ESamples eSampleFunction, Integer sampling, boolean linkageWeightModifiable, Double... optParams){
		
		this.linkage = instantiateLinkage(linkage, this, linkageAreas, targetedAreas, eSampleFunction, linkageWeightModifiable, optParams);
		this.linkage.setSampling(sampling);
		
		return this;
	}
	
	public IArea configureLinkage(ELinkage linkage, ELinkageBetweenAreas linkageAreas, ESamples eSampleFunction, Integer sampling, boolean linkageWeightModifiable, Double... optParams){
		
		this.linkage = instantiateLinkage(linkage, this, linkageAreas, null, eSampleFunction, linkageWeightModifiable, optParams);
		this.linkage.setSampling(sampling);
		
		return this;
	}
	
	public IArea configureLinkage(ELinkage linkage, ELinkageBetweenAreas linkageAreas, ESamples eSampleFunction, boolean linkageWeightModifiable, Double... optParams){
		
		this.linkage = instantiateLinkage(linkage, this, linkageAreas, null, eSampleFunction, linkageWeightModifiable, optParams);
		
		return this;
	}
	
	public IArea configureLinkage(ELinkage linkage, ESamples eSampleFunction, Integer sampling, boolean linkageWeightModifiable,  Double... optParams){
		
		this.linkage = instantiateLinkage(linkage, this, null, null, eSampleFunction, linkageWeightModifiable, optParams);
		this.linkage.setSampling(sampling);
		
		return this;
	}
	
	public IArea configureLinkage(ELinkage linkage, ESamples eSampleFunction, boolean linkageWeightModifiable, Double... optParams){
		
		this.linkage = instantiateLinkage(linkage, this, null, null, eSampleFunction, linkageWeightModifiable, optParams);
		
		return this;
	}
	
	public IArea configureNode(boolean bias, EActivation activation, ENodeType type){
		
		this.activation = activation;
		
		this.nodeFactory.configureNode(bias, activation,  type);
		
		return this;
		
	}
	
	public IArea configureNode(boolean bias, ENodeType... types){
		
		this.nodeFactory.configureNode(bias, types);
		
		return this;
		
	}
	
	
	private ILinkage instantiateLinkage(ELinkage linkageType, Area thisArea, ELinkageBetweenAreas linkageAreas, Integer[] targetedAreas, ESamples eSampleFunction, boolean weightModifiable, Double[] params) {
		
		ILinkage linkage = ReflexionUtils.newClass(linkageType.getClassPath(), new Class[]{}, new Object[]{});
		
		linkage.setArea(thisArea);
		
		linkage.setLinkageType(linkageType);
		
		if(linkageAreas != null){
			linkage.setLinkageAreas(linkageAreas);
		}
		
		if(targetedAreas != null){
			linkage.setTargetedAreas(Arrays.asList(targetedAreas));
		}
		
		linkage.setWeightModifiable(weightModifiable);
		
		if(params != null){
			linkage.setParams(params);
		}
		linkage.initParameters();
		
		if(eSampleFunction != null)
			((IFilterLinkage)linkage).setESampleFunction(eSampleFunction);
		
		return linkage;
	}
	
	
	public void initBiasWeights(double value) {

		
			List<INode> areaNodes = this.getNodes();
			for (INode node : areaNodes) {
				
				if(network == null || network.getImpl() == null || network.getImpl() == ENetworkImplementation.LINKED)
					node.getBiasInput().initWeight(value);
				else
					node.setBiasWeightValue(value);
			}


	}
	
	
	public Double[] propagation(boolean playAgain, Double[] outputValues) throws Exception {
		
		List<INode> nodes = (List<INode>) this.getNodes();
		
		if (getLayer().isLastLayer()){
			outputValues = new Double[nodes.size()];
		}
		
		if(!playAgain || getLinkage().isWeightModifiable() || getLayer().isFirstLayer()){
			
			for (INode node : nodes) {
				
				node.computeOutput(playAgain);
				
				if (getLayer().isLastLayer()) {
					outputValues[node.getNodeId()] = node.getComputedOutput();
					node.setError(node.getIdealOutput() - node.getComputedOutput());
				}
			}
		}
		
		return outputValues;
	}
	
	

	/**
	 * 
	 */
	public void finalizeConnections() {
		
		
		if (network.getImpl() == ENetworkImplementation.LINKED) {
			
			INode lastRecurrent = null;
			INode lastTimeSerie = null;
			List<INode> nodes = (List<INode>) this.getNodes();
			
			for (INode node : nodes) {
				if (getLayer().getNetwork().isRecurrentNodesLinked() && node.getNodeType() == ENodeType.RECURRENT) {
					
					if (lastRecurrent != null)
						lastRecurrent.doubleLink((RecurrentNode) node, ELinkType.RECURRENT_LATERAL_LINK);
					
					lastRecurrent = node;
				}
				
				if(node.getNodeType() == ENodeType.TIMESERIE){
					if (lastTimeSerie != null)
						lastTimeSerie.link(node, ELinkType.RECURRENT_LATERAL_LINK);
					
					lastTimeSerie = node;
				}
			}
			
		
			LSTMNode lastLSTMNode = null;
			for (INode node : nodes) {
				if(node.getNodeType() == ENodeType.LSTM){
					LSTMNode currentLSTMNode = (LSTMNode) node;
					if (lastLSTMNode != null){
						for(Node memory : lastLSTMNode.getMemories()){
							memory.link(currentLSTMNode.getInputGate(), ELinkType.RECURRENT_LINK);
							memory.link(currentLSTMNode.getForgetGate(), ELinkType.RECURRENT_LINK);
							memory.link(currentLSTMNode.getOutputGate(), ELinkType.RECURRENT_LINK);
						}
						
						lastLSTMNode.getOutputProductUnit().link(currentLSTMNode.getInput(), ELinkType.RECURRENT_LINK);
						lastLSTMNode.getOutputProductUnit().link(currentLSTMNode.getInputGate(), ELinkType.RECURRENT_LINK);
						lastLSTMNode.getOutputProductUnit().link(currentLSTMNode.getForgetGate(), ELinkType.RECURRENT_LINK);
						lastLSTMNode.getOutputProductUnit().link(currentLSTMNode.getOutputGate(), ELinkType.RECURRENT_LINK);
					}
					
					lastLSTMNode = currentLSTMNode;
				}
			}
			
			for (INode node : nodes) {
				
				// We fan out links on nodes between layers (cross links)
				// also we create links for recurrent nodes.
				node.finalizeConnections();
					

			}
		
		}
		
		
	}
	
	
	
	public void applyFilter(IFilterLinkage linkage, int idFilter, IPixelNode thisNode, Float ecartType){
		
		double weight = 0D;
		
		FilterIndex index = new FilterIndex(thisNode.getAreaSquare().getIdentification(), idFilter);
		INode sourceNode = this.getNode(thisNode.getNodeId());
		
		if(sourceNode != null){	
				// on connecte les neurones suivant la dérivée seconde de la gaussienne
				// réalisant ainsi le filtre de Marr ou Laplacien de Gaussienne ou chapeau mexicain
				weight = linkage.getFilterValue(index, EFilterPosition.CENTER, thisNode, (IPixelNode) sourceNode);
				if(Math.abs(weight) > ecartType){
					sourceNode.link((INode) thisNode, ELinkType.REGULAR, linkage.isWeightModifiable(), weight);
				}
		}
				
		
	}
	
	public void applyFilter(IFilterLinkage linkage, int idFilter, IPixelNode thisNode, SigmaWi sigmaWI) {
		
		FilterIndex index = new FilterIndex(thisNode.getAreaSquare().getIdentification(), idFilter);
		INode sourceNode = this.getNode(thisNode.getNodeId());
		
		if(sourceNode != null){	
			
				sigmaWI.sum(sourceNode.getComputedOutput() * linkage.getFilterValue(index, EFilterPosition.CENTER, thisNode, (IPixelNode) sourceNode));
			
		}
		
		sigmaWI.sum(-thisNode.getBiasWeightValue());
		
		
	}
	
	
	public int getNodeCount() {
		return nodes.size();
	}

	public int getNodeCountMinusRecurrentOnes() {
		return nodes.size() - getRecurrentNodeCount();
	}

	public int getRecurrentNodeCount() {
		int recurrentNodesCount = 0;
		List<INode> nodes = (List<INode>) this.getNodes();
		
		for (INode node : nodes) {
			if (node.getNodeType() == ENodeType.RECURRENT)
				recurrentNodesCount++;
		}
		return recurrentNodesCount;
	}

	public List<INode> getNodes() {
		return nodes;
	}
	
	public List<INode> getNodes(Integer sampling) {
		
		List<INode> nodes =  this.getNodes();
		
		if(sampling == 1)
			return nodes;
		
		return nodes.stream().filter(node -> ((PixelNode) node).getX() % sampling == 0 ).filter(node -> ((PixelNode) node).getY() % sampling == 0).collect(Collectors.toList());
	}

	public INode getNode(int index) {
		return nodes.get(index);
	}
	
	

	public void setNodes(List<INode> nodes) {
		this.nodes = nodes;
	}

	public void addNode(INode node) {
		node.setNodeId(nodes.size());
		nodes.add(node);
		node.setArea(this);
		node.initGraphics();
	}
	
	public void removeNode(INode node){
		nodes.remove(node);
	}
	
	public void removeNodes(List<INode> nodes){
		nodes.removeAll(nodes);
	}

	public String toString() {
		return " Area id : " + areaId;
	}

	public Integer getAreaId() {
		return areaId;
	}

	public void setAreaId(int areaId) {
		this.areaId = areaId;
	}

	public ILayer getLayer() {
		return layer;
	}
	
	public ILayer getNextLayer() {
		return network.getLayer(layer.getLayerId() + 1);
	}
	
	public ILayer getPreviousLayer() {
		if(getLayer().isFirstLayer())
			return null;
		return network.getLayer(layer.getLayerId() - 1);
	}
	

	public IArea getLeftSibilingArea(){
		
		return getPreviousLayer().getArea(this.areaId);
	}
	
	public IArea getRightSibilingArea(){
		
		return getNextLayer().getArea(this.areaId);
	}

	public void setLayer(ILayer layer) {
		this.layer = layer;
	}
	
	

	public IArea deepCopy() {
		Area copy_area = new Area(nodes.size());
		List<INode> copy_nodes = new ArrayList<INode>(nodes);
		Collections.copy(copy_nodes, nodes);
		
		copy_area.setNodes(copy_nodes);
		copy_area.setAreaId(areaId);
		copy_area.setLayer(layer);
		
		int idx = 0;
		for(INode node : nodes){
			node.setArea(copy_area);
			copy_nodes.set(idx++, node.deepCopy());
		}
		
		return copy_area;
	}
	
	public void initGraphics() {
		if(Graphics3D.graphics3DActive)
			Graphics3D.createArea(this);
	}

	
	public String getComment() {
		return comment;
	}

	public void setComment(String comment) {
		this.comment = comment;
	}

	public EActivation getActivation() {
		return activation;
	}

	public void setActivation(EActivation activation) {
		this.activation = activation;
	}

	public ILinkage getLinkage() {
		return linkage;
	}
	
	public IFilterLinkage getFilterLinkage() {
		return (IFilterLinkage) linkage;
	}
	

	public void setLinkage(ILinkage linkage) {
		this.linkage = linkage;
	}

	public Identification getIdentification() {
		
		Integer layerId = null;
		if(this.getLayer() != null)
			layerId = this.getLayer().getLayerId();
		
		return new Identification(layerId, areaId);
	}

	@Override
	public void prePropagation() {
		getLinkage().prePropagation();
		
	}

	@Override
	public void postPropagation() {
		getLinkage().postPropagation();
		
	}
	
	public Boolean isShowImage() {
		return showImage;
	}


}
package RN;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.function.Supplier;
import java.util.stream.Stream;

import RN.algoactivations.EActivation;
import RN.dataset.inputsamples.ESamples;
import RN.linkage.EFilterPosition;
import RN.linkage.Filter;
import RN.linkage.FilterLinkage.FilterIndex;
import RN.linkage.IFilterLinkage;
import RN.linkage.SigmaWi;
import RN.linkage.vision.Gradient;
import RN.links.ELinkType;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import RN.nodes.ImageNode;
import RN.nodes.Node;
import RN.nodes.PixelNode;
import javafx.scene.paint.Color;

/**
 * @author Eric Marchand
 * 
 */public class AreaSquare extends Area implements IAreaSquare, IArea{
	
	private Integer nodeCount = null;
	
	
	protected AreaSquare(){
	}
	
	public AreaSquare(int nodeCount) {
		
		this.nodes = new ArrayList<INode>(nodeCount);
		initWidthPx(nodeCount);
		this.nodeCount = nodeCount;
	}
	

	public AreaSquare(int nodeCount, boolean showImage) {
		
		this.nodes = new ArrayList<INode>(nodeCount);
		this.showImage = showImage;
		initWidthPx(nodeCount);
		if(showImage){
			this.imageArea = new ImageNode(EActivation.IDENTITY, this.widthPx, this.heightPx);
			this.imageArea.setArea(this);
		}
		this.nodeCount = nodeCount;
	}
	
	public AreaSquare(int nodeCountX, int nodeCountY, boolean showImage) {
		int count = nodeCountX * nodeCountY;
		this.nodes = new ArrayList<INode>(count);
		this.showImage = showImage;
		initWidthHeightPx(nodeCountX, nodeCountY);
		if(showImage){
			this.imageArea = new ImageNode(EActivation.IDENTITY, this.widthPx, this.heightPx);
			this.imageArea.setArea(this);
		}
		this.nodeCount = count;
	}

	public AreaSquare(int nodeCount, boolean showImage, String comment) {
		
		this.nodes = new ArrayList<INode>(nodeCount);
		this.showImage = showImage;
		this.comment += comment;
		initWidthPx(nodeCount);
		this.nodeCount = nodeCount;
	}

	
	public PixelNode getNode(int index) {
		return (PixelNode) nodes.get(index);
	}

	@Override
	public int getNodeCount() {
		return this.nodes.size();
	}
	
	
	public Filter getFilter(int filterId){
		FilterIndex idx = new FilterIndex(getIdentification(), filterId);
		return getFilterLinkage().getFilter(idx);
	}


	@Override
	public IPixelNode getNodeXY(int x, int y) {
		try{
			int id = nodeXYToNodeId(x, y);
			if(id < 0 || id > nodes.size() - 1)
				return null;
			
			return (IPixelNode) nodes.get(id);
			
		} catch (Exception ignore) {
		}
		
		return null;
	}
	
	@Override
	public IPixelNode getNodeXY(int x, int y, int sampling) {
		
		if(sampling == 1)
			return getNodeXY(x, y);
		
		try{
			return (IPixelNode) nodes.get(nodeXYToNodeId(x, y, sampling));
		} catch (Exception ignore) {
			ignore.printStackTrace();
		}
		
		return null;
	}
	

	
	/**
	 * Retourne le node à la position (x,y) avec comme point d'origine (x0,y0) après une rotation d'angle theta
	 * @param x
	 * @param y
	 * @param theta en radian
	 */
	public IPixelNode getNodeXY(int x, int y, int x0, int y0, double theta) {
		
		IPixelNode node = null;
		
		try{
			node = (IPixelNode) nodes.get(nodeXYToNodeId(x, y, x0, y0, theta));
		} catch (Exception ignore) {
		}
		
		return node;
	}

	
	/**
	 * Return nodes in square zone 
	 * @param x0 x at top left point 
	 * @param y0 y at top left point
	 * @param width
	 * @param height
	 * @return
	 * @throws Exception
	 */
	public List<IPixelNode> getNodesInSquareZone(int x0, int y0, int width, int height) {
		
		List<IPixelNode> nodes = new ArrayList<IPixelNode>();
		IPixelNode pix = null;
		
		for(int y = y0; y < y0 + height; y++){
			for(int x = x0; x < x0 + width; x++){
				try {
					pix = getNodeXY(x,y);
					if(pix != null)
						nodes.add(pix);
				} catch (Exception ignore) {
				}
			}
		}
		return nodes;
	}
	
	/**
	 * Return nodes in a circlar zone
	 * @param x0 x center point
	 * @param y0 y center point
	 * @param radius
	 * @return
	 * @throws Exception
	 */
	public List<IPixelNode> getNodesInCirclarZone(int x0, int y0, int radius) {
		
		List<IPixelNode> nodes = new ArrayList<IPixelNode>();
		IPixelNode node = null;
		
		for(int y = y0 - radius; y <= y0 + radius; y++){
			for(int x = x0 - radius; x <= x0 + radius; x++){
				
				double distance = Math.sqrt(Math.pow(x0 - x, 2D) + Math.pow(y0 - y, 2D));
				
				if(distance <= radius){
					node = getNodeXY(x,y);
					if(node != null){
						nodes.add(node);
					}
				}
			}
		}
		
		return nodes;
	}
	
	public List<IPixelNode> getNodesOnCirclarPerimeter(int x0, int y0, int radius) {
		
		List<IPixelNode> nodes = new ArrayList<IPixelNode>();
		IPixelNode node = null;
		
		for(int y = y0 - radius; y <= y0 + radius; y++){
			for(int x = x0 - radius; x <= x0 + radius; x++){
				
				double distance = Math.sqrt(Math.pow(x0 - x, 2D) + Math.pow(y0 - y, 2D));
				
				if(Math.abs(distance - radius) < 0.5D ){
					node = getNodeXY(x,y);
					if(node != null){
						nodes.add(node);
					}
				}
			}
		}
		
		return nodes;
	}
	
	public void initWidthPx(int pixSize){
		
		Double width = Math.sqrt(pixSize);
		
		if(width == 0D)
			throw new RuntimeException("Le nombre de neurones dans la liste est vide.");
		
		if(width.intValue() - width.doubleValue() != 0)
			throw new RuntimeException("Le nombre de neurones doit être un carré d'un entier. nbr=" + pixSize);
		
		// Carré
		this.widthPx = width.intValue();
		this.heightPx = this.widthPx;
		this.nodeCenterX = widthPx / 2;
		this.nodeCenterY = heightPx / 2;
	}
	
	public void initWidthHeightPx(int pixSizeX, int pixSizeY){
		
		
		if(pixSizeX == 0)
			throw new RuntimeException("Le nombre de neurones dans la liste est vide.");
		
		
		// Rectangle
		this.widthPx = pixSizeX;
		this.heightPx = pixSizeY;
		this.nodeCenterX = widthPx / 2;
		this.nodeCenterY = heightPx / 2;
	}
	
	public Integer getWidthPx(){
		return this.widthPx;
	}
	
	public IPixelNode getNodeCenterXY() {
		return (IPixelNode) nodes.get(nodeXYToNodeId(nodeCenterX, nodeCenterY));
	}
	
	
	public Integer nodeXYToNodeId(int x, int y) {
		
		if(x < 0 || x > widthPx - 1 || y < 0 || y > heightPx - 1)
			return -1;
		
		return x + y * widthPx ;
		
	}
	
	public Integer nodeXYToNodeId(int x, int y, int sampling) {
		
		x = x * sampling;
		y = y * sampling;
		
		if(x < 0 || x > widthPx - 1 || y < 0 || y > heightPx - 1)
			return -1;
		
		return x + y * widthPx ;
		
	}
	
	public Integer nodeXYToNodeId(int x, int y, int x0, int y0, double theta) {
		
		if(x < 0 || x > widthPx - 1 || y < 0 || y > heightPx - 1
				|| x0 < 0 || x0 > widthPx - 1 || y0 < 0 || y0 > heightPx - 1)
			return -1;
		
		int newX = (int) Math.round((x-x0) * Math.cos(theta) - (y-y0) * Math.sin(theta)) + x0 ;
		int newY = (int) Math.round((x-x0) * Math.sin(theta) + (y-y0) * Math.cos(theta)) + y0 ;
		
		
		return newX + newY * widthPx ;
		
	}
	
	
	public int[] nodeIdToNodeXY(int id) {
		
		int x;
		int y;
		
		Double val = new Double(id / widthPx);
		y = val.intValue();
		x = id - y * widthPx;
		
		return new int[] { x, y };

	}
	
	
	public void applyConvolutionFilter(IFilterLinkage linkage, int idFilter, IPixelNode thisNode, Float ecartType){
		
		double weight = 0D;
		
		FilterIndex index = new FilterIndex(thisNode.getAreaSquare().getIdentification(), idFilter);
		Filter filter = linkage.getFilter(index);
		
		IPixelNode sourceNode = null;
		
		int centerX = thisNode.getX();
		int centerY = thisNode.getY();
		int halfHeightFilter = (filter.getHeight() - 1) / 2; 
		int halfWidthFilter = (filter.getWidth() - 1) / 2;
		int y0 = Math.max(0, (centerY - halfHeightFilter) * linkage.getSampling());
		int x0 = Math.max(0, (centerX - halfWidthFilter) * linkage.getSampling());
		int ystop = Math.min(this.getHeightPx() - 1, (centerY + halfHeightFilter) * linkage.getSampling());
		int xstop = Math.min(this.getWidthPx() - 1, (centerX + halfWidthFilter) * linkage.getSampling());
		
		for(int y = y0 ; y <= ystop; y += linkage.getSampling()){
			for(int x = x0; x <= xstop; x += linkage.getSampling()){
				
				sourceNode = this.getNodeXY(x, y);
				
				weight = linkage.getFilterValue(index, EFilterPosition.CENTER, thisNode, sourceNode);
				
				if(Math.abs(weight) > ecartType){
					sourceNode.link((INode) thisNode, ELinkType.REGULAR, linkage.isWeightModifiable(), weight);
				}
				
			}
			
		}
		
	}
	
	public void applyMaxPoolingFilter(IFilterLinkage linkage, int width, int stride, IPixelNode thisNode){
		
		double value = 0D;
		
		int sampling = linkage.getSampling();
		int topLeftX = thisNode.getX();
		int topLeftY = thisNode.getY();
		int y0 = topLeftY * sampling * stride;
		int x0 = topLeftX * sampling * stride;
		int ystop = y0 + width - 1;
		int xstop = x0 + width - 1;
		
		IPixelNode sourceNode = null;
		IPixelNode maxSourceNode = null;
		
		Double maxValue = null;
		
		for(int y = y0 ; y <= ystop; y += sampling){
			for(int x = x0; x <= xstop; x += sampling){
				
				if(x >= 0 && x <= this.getWidthPx() - 1 && y >=0 && y <= this.getHeightPx() - 1){
					
					sourceNode = this.getNodeXY(x, y);
					value = sourceNode.getComputedOutput();
					
					if(maxValue == null || maxValue < value){
						maxValue = value;
						maxSourceNode = sourceNode;
					}
				}
				
			}
			
		}
		
		if(maxSourceNode != null){
			thisNode.getInputs().clear();
			maxSourceNode.link((INode) thisNode, ELinkType.REGULAR, linkage.isWeightModifiable(), maxValue);
		}
		
		
	}
	
	public void applyMaxPoolingFilter(IFilterLinkage linkage, int width, int stride, IPixelNode thisNode, SigmaWi sigmaWI){
		
		
		int sampling = linkage.getSampling();
		int topLeftX = thisNode.getX();
		int topLeftY = thisNode.getY();
		int y0 = topLeftY * sampling * stride;
		int x0 = topLeftX * sampling * stride;
		int ystop = y0 + width - 1;
		int xstop = x0 + width - 1;
		
		IPixelNode sourceNode = null;
		
		Double value = null;
		
		for(int y = y0 ; y <= ystop; y += sampling){
			for(int x = x0; x <= xstop; x += sampling){
				
				if(x >= 0 && x <= this.getWidthPx() - 1 && y >=0 && y <= this.getHeightPx() - 1){
					
					sourceNode = this.getNodeXY(x, y);
					value = sourceNode.getComputedOutput();
					
					if(value > sigmaWI.value() ){
						sigmaWI.setSigmaWi(value);
					}
				}
				
			}
			
		}
		
	}
	
	public void applyConvolutionCompositeFilter(IFilterLinkage linkage, int idFilter1, int idFilter2, ESamples op, IPixelNode thisNode, Float ecartType){
		
		double weight = 0D;
		double weight1 = 0D;
		double weight2 = 0D;
		
		FilterIndex index1 = new FilterIndex(thisNode.getAreaSquare().getIdentification(), idFilter1);
		FilterIndex index2 = new FilterIndex(thisNode.getAreaSquare().getIdentification(), idFilter2);
		Filter filter1 = linkage.getFilter(index1);
		Filter filter2 = linkage.getFilter(index2);
		
		IPixelNode sourceNode = null;
		
		int centerX = thisNode.getX();
		int centerY = thisNode.getY();
		int heightMax = Math.max(filter1.getHeight(), filter2.getHeight());
		int widthMax = Math.max(filter1.getWidth(), filter2.getWidth());
		int halfHeightFilter = (heightMax - 1) / 2; 
		int halfWidthFilter = (widthMax - 1) / 2;
		int y0 = Math.max(0, (centerY - halfHeightFilter) * linkage.getSampling());
		int x0 = Math.max(0, (centerX - halfWidthFilter) * linkage.getSampling());
		int ystop = Math.min(this.getHeightPx() - 1, (centerY + halfHeightFilter) * linkage.getSampling());
		int xstop = Math.min(this.getWidthPx() - 1, (centerX + halfWidthFilter) * linkage.getSampling());
		
		for(int y = y0 ; y <= ystop; y += linkage.getSampling()){
			for(int x = x0; x <= xstop; x += linkage.getSampling()){
				
				sourceNode = this.getNodeXY(x, y);
				
				weight1 = linkage.getFilterValue(index1, EFilterPosition.CENTER, thisNode, sourceNode);
				weight2 = linkage.getFilterValue(index2, EFilterPosition.CENTER, thisNode, sourceNode);
				
				if(op == ESamples.SUBSTRACT)
					weight = weight1 - weight2;
				else if(op == ESamples.ADD)
					weight = weight1 + weight2;
				else if(op == ESamples.MULTIPLY)
					weight = weight1 * weight2;
				
				if(Math.abs(weight) > ecartType){
					sourceNode.link((INode) thisNode, ELinkType.REGULAR, linkage.isWeightModifiable(), weight);
				}
				
			}
			
		}
		
	}
	
	public void applyConvolutionFilter(IFilterLinkage linkage, int idFilter, IPixelNode thisNode, SigmaWi sigmaWI) {
		
		
		FilterIndex index = new FilterIndex(thisNode.getAreaSquare().getIdentification(), idFilter);
		Filter filter = linkage.getFilter(index);
		
		IPixelNode sourceNode = null;
		
		int centerX = thisNode.getX();
		int centerY = thisNode.getY();
		int halfHeightFilter = (filter.getHeight() - 1) / 2; 
		int halfWidthFilter = (filter.getWidth() - 1) / 2;
		int y0 = Math.max(0, (centerY - halfHeightFilter) * linkage.getSampling());
		int x0 = Math.max(0, (centerX - halfWidthFilter) * linkage.getSampling());
		int ystop = Math.min(this.getHeightPx() - 1, (centerY + halfHeightFilter) * linkage.getSampling());
		int xstop = Math.min(this.getWidthPx() - 1, (centerX + halfWidthFilter) * linkage.getSampling());
		
		for(int y = y0 ; y <= ystop; y += linkage.getSampling()){
			for(int x = x0; x <= xstop; x += linkage.getSampling()){
				
				sourceNode = this.getNodeXY(x, y);
				sigmaWI.sum(sourceNode.getComputedOutput() * linkage.getFilterValue(index, EFilterPosition.CENTER, thisNode, sourceNode));
			}
		}
		
		sigmaWI.sum(-thisNode.getBiasWeightValue());
		
	}
	
	

	
	public void applyConvolutionCompositeFilter(IFilterLinkage linkage, int idFilter1, int idFilter2, ESamples op, IPixelNode thisNode, SigmaWi sigmaWI){
		
		double weight = 0D;
		double weight1 = 0D;
		double weight2 = 0D;
		
		FilterIndex index1 = new FilterIndex(thisNode.getAreaSquare().getIdentification(), idFilter1);
		FilterIndex index2 = new FilterIndex(thisNode.getAreaSquare().getIdentification(), idFilter2);
		
		Filter filter1 = linkage.getFilter(index1);
		Filter filter2 = linkage.getFilter(index2);
		
		IPixelNode sourceNode = null;
		
		int sampling = linkage.getSampling();
		int centerX = thisNode.getX();
		int centerY = thisNode.getY();
		int heightMax = Math.max(filter1.getHeight(), filter2.getHeight());
		int widthMax = Math.max(filter1.getWidth(), filter2.getWidth());
		int halfHeightFilter = (heightMax - 1) / 2; 
		int halfWidthFilter = (widthMax - 1) / 2;
		int y0 = Math.max(0, (centerY - halfHeightFilter) * sampling);
		int x0 = Math.max(0, (centerX - halfWidthFilter) * sampling);
		int ystop = Math.min(this.getHeightPx() - 1, (centerY + halfHeightFilter) * sampling);
		int xstop = Math.min(this.getWidthPx() - 1, (centerX + halfWidthFilter) * sampling);
		
		for(int y = y0 ; y <= ystop; y += sampling){
			for(int x = x0; x <= xstop; x += sampling){
				
				sourceNode = this.getNodeXY(x, y);
				
				weight1 = linkage.getFilterValue(index1, EFilterPosition.CENTER, thisNode, sourceNode);
				weight2 = linkage.getFilterValue(index2, EFilterPosition.CENTER, thisNode, sourceNode);
				
				if(op == ESamples.SUBSTRACT)
					weight = weight1 - weight2;
				else if(op == ESamples.ADD)
					weight = weight1 + weight2;
				else if(op == ESamples.MULTIPLY)
					weight = weight1 * weight2;
				
				sigmaWI.sum(sourceNode.getComputedOutput() * weight);
				
			}
			
		}
		
		sigmaWI.sum(-thisNode.getBiasWeightValue());
		
	}
	
	
	
	public String toString() {
		return " Area id : " + areaId  + "    heightPx :" + heightPx + "    widthPx : " + widthPx;
	}
	
	public void showGradients(double magnitudeFactor, double magnitudeThreshold, int sampling, Color color) {
		IPixelNode pix = null;
		for(int idx = 0; idx < nodeCount; idx++){
			pix = (PixelNode) getNode(idx);
			if(pix.getX() % sampling == 0 && pix.getY() % sampling == 0){
				try {
					Gradient subGradient = null;
					double magSum = 0D;
					double avgMagnitude = 0;
					double avgTheta = 0;
					double x = 0;
					double y = 0;
					int count = 0;
					for(IPixelNode subPix : getNodesInSquareZone(pix.getX() - (sampling / 2), pix.getY() - (sampling / 2), sampling, sampling)){
						subGradient = subPix.getGradient();
						if(subGradient != null){
							magSum += subGradient.getMagnitude();
							x += Math.cos(subGradient.getTheta());
							y += Math.sin(subGradient.getTheta());
							count++;
						}
					}
					avgMagnitude = magSum / count;
					avgTheta = Math.atan2(y / count, x / count);
					avgTheta = avgTheta < 0 ? avgTheta + (2D * Math.PI) : avgTheta;
					
					if(Math.abs(avgMagnitude) > magnitudeThreshold){
						new Gradient(pix, avgTheta, avgMagnitude, null).produceGradient(magnitudeFactor, color);
					}
				} catch (Exception e) {
				}
					//gradient.produceGradient(magnitudeFactor, color);
			}
			
		}
		
	}
	

	public void imageToString(){
		
		System.out.println("Image area #"+ areaId +" : "+ getWidthPx() + " x " + getHeightPx());
		
		for (int idy = 0; idy < getHeightPx(); idy++) {
			for (int idx = 0; idx < getWidthPx(); idx++) {
				Double value = null;
				try {
					value = getNodeXY(idx, idy).getComputedOutput();
					if(value == 0D)
						System.out.print(" . ");
					else if(value < 0D)
						System.out.printf(" %.2f ", value);
					else
						System.out.printf(" %.2f ", value);
				} catch (Exception e) {
					System.out.printf(" X ");
				}

				System.out.print("\t");
			}
			System.out.print("\n");
		}
			
	}
	
	public void pixelsToString(List<IPixelNode> pixels){
		
		System.out.println("Image area #"+ areaId +" : "+ getWidthPx() + " x " + getHeightPx());
		Optional<IPixelNode> pix = null;
		Supplier<Stream<IPixelNode>> streamSupplier = () -> pixels.stream();
		for (int idy = 0; idy < getHeightPx(); idy++) {
			for (int idx = 0; idx < getWidthPx(); idx++) {
				Double value = null;
				try {
					final int x = idx;
					final int y = idy;
					pix = streamSupplier.get().filter(node -> node.getX() == x && node.getY() == y).findFirst();
					if(pix.isPresent()){
						
						value = pix.get().getComputedOutput();
						
						if(value == 0D)
							System.out.print(" . ");
						else if(value > 0D)
							System.out.printf(" %.2f ", value);
						else 
							System.out.printf(" %.2f ", value);
					
					}else
						System.out.printf(" _ ");
					
				} catch (Exception e) {
					System.out.printf(" X ");
				}

				System.out.print("\t");
			}
			System.out.print("\n");
		}
			
	}
	
	public List<Double> compareArea(AreaSquare area2){
		
		List<Double> substract = new ArrayList<Double>(nodes.size());
		
		System.out.println("Compare area #" + areaId + " - " + area2.getAreaId() + ": "+ getWidthPx() + " x " + getHeightPx());
		
		boolean equal = true;
		
		for (int idy = 0; idy < getHeightPx(); idy++) {
			for (int idx = 0; idx < getWidthPx(); idx++) {
				Double value = null;
				try {
					value = getNodeXY(idx, idy).getComputedOutput() - area2.getNodeXY(idx, idy).getComputedOutput();
					substract.add(value);
					if(value == 0D)
						System.out.print(" . ");
					else if(value < 0D){
						equal = false;
						System.out.printf(" %.2f ", value);
					}else{
						equal = false;
						System.out.printf(" %.2f ", value);
					}
				} catch (Exception e) {
					System.out.printf(" X ");
				}
				System.out.print("\t");

			}
			System.out.print("\n");
		}
		
		if(equal)
			System.out.println("============IDENTIQUES=============");
		
		return substract;
	}
	
	
	public Integer getHeightPx() {
		return heightPx;
	}

	public Integer getNodeCenterX() {
		return nodeCenterX;
	}

	public void setNodeCenterX(Integer nodeCenterX) {
		this.nodeCenterX = nodeCenterX;
	}

	public Integer getNodeCenterY() {
		return nodeCenterY;
	}

	public void setNodeCenterY(Integer nodeCenterY) {
		this.nodeCenterY = nodeCenterY;
	}

	public int getX(Node node) {
		return nodeIdToNodeXY(node.getNodeId())[0];
	}
	
	public int getY(Node node) {
		return nodeIdToNodeXY(node.getNodeId())[1];
	}


	public void setShowImage(Boolean showImage) {
		this.showImage = showImage;
	}
	
	public ImageNode getImageArea() {
		return imageArea;
	}

	public void setImageArea(ImageNode imageArea) {
		this.imageArea = imageArea;
	}



	
}
package RN;

import java.util.List;

import RN.nodes.IPixelNode;
import RN.nodes.Node;

/**
 * @author Eric Marchand
 * 
 */public class AreaSquareSampled extends AreaSquare implements IAreaSquare, IArea{
	
	private Integer sampling = 1;
	
	private AreaSquare sourceArea = null;
	
	private Integer nodeCount = null;
	
	
	
	public AreaSquareSampled(AreaSquare area, Integer sampling){
		
		this.sourceArea = area;
		this.sampling = sampling;
		this.nodeCount = (int) Math.pow(area.getWidthPx() / sampling, 2);
		
		initWidthPx(nodeCount);
		
	}
	
	public void initWidthPx(int pixSize){
		
		Double width = Math.sqrt(pixSize);
		
		if(width == 0D)
			throw new RuntimeException("Le nombre de neurones dans la liste est vide.");
		
		if(width.intValue() - width.doubleValue() != 0)
			throw new RuntimeException("Le nombre de neurones doit être un carré d'un entier.");
		
		// Carré
		this.widthPx = width.intValue();
		this.heightPx = this.widthPx;
		this.nodeCenterX = width.intValue() / 2;
		this.nodeCenterY = width.intValue() / 2;
	}


	public int getNodeCount() {
		return this.nodeCount;
	}

//	public List<INode> getNodes() {
//		
//		AreaSquareSampled area = this;
//		
//		Supplier<Stream<INode>> streamSupplier = () -> sourceArea.getNodes().stream().parallel()
//															.filter(node -> ((PixelNode) node).getX() % sampling == 0 )
//															.filter(node -> ((PixelNode) node).getY() % sampling == 0 );
//		
//		List<INode> nodes = streamSupplier.get().collect(Collectors.toList());
//		
//		streamSupplier.get().parallel().sequential().forEach(new Consumer<INode>(){
//			
//			int idx = 0;
//			
//			@Override
//			public void accept(INode node) {
//				node.setArea(area);
//				node.setNodeId(idx++);
//			}
//		});
//		
//		return nodes;
//	}
	
	
	@Override
	public IPixelNode getNodeCenterXY() {
		return sourceArea.getNodeCenterXY();
	}


	public IPixelNode getNodeXY(int x, int y) {
		x *= sampling;
		y *= sampling;
		
		return sourceArea.getNodeXY( x,  y);
	}

	public IPixelNode getNodeXY(int x, int y, int x0, int y0, double theta) {
		
		x *= sampling;
		y *= sampling;
		x0 *= sampling;
		y0 *= sampling;
		
		return sourceArea.getNodeXY( x,  y,  x0,  y0,  theta);
	}

	public List<IPixelNode> getNodesInSquareZone(int x0, int y0, int width, int height)  {
		
		x0 *= sampling;
		y0 *= sampling;
		
		return sourceArea.getNodesInSquareZone( x0,  y0,  width, height);
	}

	public List<IPixelNode> getNodesInCirclarZone(int x0, int y0, int radius) {
		
		x0 *= sampling;
		y0 *= sampling;
		radius *= sampling;
		
		return sourceArea.getNodesInCirclarZone( x0,  y0, radius);
	}
	
	
	public Integer getWidthPx() {
		return widthPx;
	}
	
	public Integer getHeightPx() {
		return heightPx;
	}


	public IArea getSourceArea() {
		return sourceArea;
	}

	public void setSourceArea(AreaSquare sourceArea) {
		this.sourceArea = sourceArea;
	}
	
	public int getX(Node node) {
		return nodeIdToNodeXY(node.getNodeId())[0];
	}
	
	public int getY(Node node) {
		return nodeIdToNodeXY(node.getNodeId())[1];
	}
	
	public int[] nodeIdToNodeXY(int id) {

		int x;
		int y;
		
		Double val = new Double(id / widthPx);
		y = val.intValue();
		x = id - y * widthPx;
		
		return new int[] { x, y };

	}
	


	
}
package RN;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

import RN.dataset.InputData;
import RN.dataset.InputDataList;

/**
 * @author Eric Marchand
 * 
 */
public class DataSeries {

	private static DataSeries instance = null;
	
	private List<List> INPUTS = new ArrayList<List>();
	private List<List> INPUTTESTS = new ArrayList<List>();
	private List<List> IDEALS = new ArrayList<List>();
	
	private List<InputData> inputDataSet = new InputDataList<InputData>(INPUTS, IDEALS);
	private List<InputData> inputTestDataSet = new InputDataList<InputData>(INPUTTESTS, null);
	
	public List<InputData> getInputTestDataSet() {
		return inputTestDataSet;
	}


	public static DataSeries getInstance(){
		if(instance == null){
			instance = new DataSeries();
		}
		
		return instance;
	}
	

	public List<InputData> getInputDataSet() {
		return inputDataSet;
	}

	public List<List> getINPUTTESTS() {
		return INPUTTESTS;
	}


	public void setINPUTTESTS(List<List> iNPUTTESTS) {
		INPUTTESTS = iNPUTTESTS;
	}	
	

	public void clearTests() {
		INPUTTESTS.clear();
	}


	public boolean testsAreEmpty() {
		return INPUTTESTS.isEmpty();
	}


	public List<List> getINPUTS() {
		return INPUTS;
	}

	public void setINPUTS(List<List> iNPUTS) {
		INPUTS = iNPUTS;
	}

	public List<List> getIDEALS() {
		return IDEALS;
	}

	public void setIDEALS(List<List> iDEALS) {
		IDEALS = iDEALS;
	}
	

	
	public void addINPUTS(List<Double> inputs) {
		getINPUTS().add(inputs);
	}

	public void addIDEALS(List<Double> ideals) {
		getIDEALS().add(ideals);
	}
	
	public boolean addTests(List<Double> arg0) {
		return getINPUTTESTS().add(arg0);
	}
	

	public void clearSeries() {
		getINPUTS().clear();
		getIDEALS().clear();
		getINPUTTESTS().clear();
		inputDataSet.clear();
	}
	
	public void addINPUT(Double... inputs) {
		getINPUTS().add(Arrays.asList(inputs));
	}

	public void addIDEAL(Double... ideals) {
		getIDEALS().add(Arrays.asList(ideals));
	}


	public String getString() {
		String result = "";
		result = "INPUTS:" + INPUTS.size()  + " IDEALS:" + IDEALS.size() + "\r\n";
		int idxV = 1;
		for(List lineInput : INPUTS){
			Iterator itr = lineInput.iterator();
			result += idxV++ ;
			while(itr.hasNext()){
				Double value = (Double) itr.next();
				result += " V:" + value + " ";
			}
			result += "\r\n";
			result += lineInput.size() + " inputs \r\n";
			result += "\r\n";
		}
		int idxI = 1;
		for(List lineInput : IDEALS){
			Iterator itr = lineInput.iterator();
			result += idxI++ ;
			while(itr.hasNext()){
				Double value = (Double) itr.next();
				result += "I:" + value + " ";
			}
			result += "\r\n";
			result += lineInput.size() + " ideals \r\n";
			result += "\r\n";
		}
		return result;
	}
	


	
}
package RN.dataset;

import java.io.Serializable;

/**
 * @author Eric Marchand
 *
 */
public class Coordinate implements Serializable {
	
	// x the abscissa coordinate with origin 0 of the image
	private Double x = null;
	
	// y the ordinate coordinate with origin 0 of the image
	private Double y = null;
	
	// cartesian center x
	private Double x0 = null;
	
	// cartesian center y
	private Double y0 = null;
	
	// angle in polar system
	private Double theta = null;
	
	// eccentricity, distance from the center image in polar system
	private Double r = null;
	
	// eccentricity, distance from the center image in log-polar system
	private Double p = null;
	
	// base for the log-polar system
	private Double base = null;
	
	
	public Coordinate() {
	}
	
	public Coordinate(double x, double y) {
		this.x = x;
		this.y = y;
	}
	
	public Coordinate(ECoordinateSystem system, double a, double b) {
		
		if(system == ECoordinateSystem.LINEAR){
			this.x = a;
			this.y = b;
		}
		
		if(system == ECoordinateSystem.POLAR){
			this.r = a;
			this.theta = b;
		}
		
		if(system == ECoordinateSystem.LOG_POLAR){
			this.p = a;
			this.theta = b;
		}
	}
	
	
	
	public void linearToPolarSystem(){
		
		double x1 = this.x - x0;
		double y1 = this.y - y0;
		
		this.r = Math.sqrt(x1*x1 + y1*y1);
		
		
		double theta1 = Math.atan2(y1, x1);
		
		while(theta1 < 0D){
			theta1 += Math.PI * 2D;
		}
		
		this.theta = theta1;
	}
	
	public void linearToLogPolarSystem(){
		
		linearToPolarSystem();
		
		if(this.base == null){
			this.p = Math.log10(this.r);
		}else{
			this.p = Math.log10(this.r) / Math.log10(this.base);
		}
		
	}
	
	public void polarToLinearSystem(){
		
		this.x = this.r * Math.cos(this.theta) + this.x0;
		this.y = this.r * Math.sin(this.theta) + this.y0;
		
	}
	
	public void logPolarToLinearSystem(){
		
		this.x = Math.pow(this.base, this.p) * Math.cos(this.theta) + this.x0;
		this.y = Math.pow(this.base, this.p) * Math.sin(this.theta) + this.y0;
		
	}
	
	public void rotateSystem(double angle){
		
		this.x = (int) Math.round((x-x0) * Math.cos(angle) - (y-y0) * Math.sin(angle)) + x0 ;
		this.y = (int) Math.round((x-x0) * Math.sin(angle) + (y-y0) * Math.cos(angle)) + y0 ;
		
		if(this.theta != null){
			linearToPolarSystem();
		}
	}
	
	private int log2(int value){
		return (int) (Math.log(value) / Math.log(2) + 1e-10);
	}

	public Double getX() {
		return x;
	}

	public void setX(Double x) {
		this.x = x;
	}

	public Double getY() {
		return y;
	}

	public void setY(Double y) {
		this.y = y;
	}

	public Double getTheta() {
		return theta;
	}

	public void setTheta(Double theta) {
		this.theta = theta;
	}

	public Double getR() {
		return r;
	}

	public void setR(Double r) {
		this.r = r;
	}

	public Double getP() {
		return p;
	}

	public void setP(Double p) {
		this.p = p;
	}

	public Double getBase() {
		return base;
	}

	public void setBase(Double base) {
		this.base = base;
	}

	public Double getX0() {
		return x0;
	}

	public void setX0(Double x0) {
		this.x0 = x0;
	}

	public Double getY0() {
		return y0;
	}

	public void setY0(Double y0) {
		this.y0 = y0;
	}
	
	

}
package RN.dataset;

/**
 * @author Eric Marchand
 *
 */
public class DataEntry {

}
package RN.dataset;

import java.util.Deque;

/**
 * @author Eric Marchand
 *
 */
public class DataUtils {

	private static Integer latestPeriodsCount = 26;
	private static DataUtils instance = null;

	
	public static DataUtils getInstance(){
		
		if(instance == null){
			instance = new DataUtils();
		}
		return instance;
	}

	public double getExponentialMean(Deque<Double> latestInputValues, int N) {
		
		
		double alpha = 2.0d / (N + 1.0d);
		double result = 0.0d;
		double n = 1.0d;

		for (double value : latestInputValues) {
			result += Math.pow(1.0d - alpha, n) * value;
			n++;
		}

		result *= alpha;

//		System.out.println("Si x(t) varie en moins de " + (-(2.0d * Math.PI) / Math.log(1d - alpha))
//				+ " échantillons, la fluctuation se retrouve dans la moyenne exp. mais est d'autant plus affaiblie qu'elle est rapide.");

		return result;

	}



	public double MACD(double lastMACD, double MACD, double lastSignal, double signal, double lastHistogram, double histogram, double stockPrice) {

		return histogram;
		
		// the MACD line crosses the signal line
//		if (histogram == 0)
//			return 1.0D;
//		 if(lastHistogram <= 0 && histogram > 0)
//			 return 1.0D;
//		 if(lastHistogram > 0 && histogram <= 0)
//			 return 1.0D;
//
//		// the MACD line crosses zero
//		 if(lastMACD <= 0 && MACD > 0)
//			 return 1.0D;
//		 if(lastMACD > 0 && MACD <= 0)
//			 return 1.0D;
//		 if(MACD == 0)
//			 return 1.0D;
//		 
//		 return 0.0D;
			 
		// there is a divergence between the MACD line and the price of the
		// stock or between the histogram and the price of the stock
		// higher highs (lower lows) on the price graph but not on the blue line, or higher highs (lower lows) on the price graph but not on the bar graph
		// Sign (relative price extremumfinal – relative price extremuminitial) ≠ Sign (relative MACD extremumfinal – MACD extremuminitial)
		 // TODO
	}
	
	public double RSI(double stockPrice) {


//		Float lastestValueSeries1 = latestSeries1.peekFirst();
//		Float lastestValueSeries2 = latestSeries1.peekFirst();
//		Float lastestValueSeries3 = latestSeries1.peekFirst();
//		
//		double closeNow = stockPrice;
//		double closePrevious = latestSeries1.peekFirst();
//		double U = closeNow - closePrevious;
//		
//		
//		double lastMACD = getExponentialMean(latestSeries1, null, 12) - getExponentialMean(latestSeries2, null, 26);
//		double lastSignal = getExponentialMean(latestSeries3, null, 9);
//		double lastHistogram = lastMACD - lastSignal;
//		
//		double MACD = getExponentialMean(latestSeries1, stockPrice, 12) - getExponentialMean(latestSeries2, stockPrice, 26);
//		double signal = getExponentialMean(latestSeries3, MACD, 9);
//		double histogram = MACD - signal;
//
//		// the MACD line crosses the signal line
//		if (histogram == 0)
//			return 1.0D;
//		 if(lastHistogram <= 0 && histogram > 0)
//			 return 1.0D;
//		 if(lastHistogram > 0 && histogram <= 0)
//			 return 1.0D;
//
//		// the MACD line crosses zero
//		 if(lastMACD <= 0 && MACD > 0)
//			 return 1.0D;
//		 if(lastMACD > 0 && MACD <= 0)
//			 return 1.0D;
//		 if(MACD == 0)
//			 return 1.0D;
		 
		 return 0.0D;
			 
		// there is a divergence between the MACD line and the price of the
		// stock or between the histogram and the price of the stock
		// higher highs (lower lows) on the price graph but not on the blue line, or higher highs (lower lows) on the price graph but not on the bar graph
		// Sign (relative price extremumfinal – relative price extremuminitial) ≠ Sign (relative MACD extremumfinal – MACD extremuminitial)
		 // TODO
	}

}
package RN.dataset;

/**
 * @author Eric Marchand
 *
 */
public enum ECoordinateSystem {
	
	LINEAR, POLAR, LOG_POLAR;

}
package RN.dataset;

import java.util.Arrays;
import java.util.List;

/**
 * @author Eric Marchand
 *
 */
public class InputData {

	public List<Double> input;
	public List<Double> ideal;
	
	public InputData(Double[] input, Double[] ideal){
		
		if(input != null)
			this.input = Arrays.asList(input);
		
		if(ideal != null)
			this.ideal = Arrays.asList(ideal);
		
	}
	
	

	public InputData(List<Double> input, List<Double> ideal){
		this.input = input;
		this.ideal = ideal;
	}
	
	public Double getInput(int ind) {
		return input.get(ind);
	}



	public List<Double> getInput() {
		return input;
	}



	public void setInput(List<Double> input) {
		this.input = input;
	}



	public List<Double> getIdeal() {
		return ideal;
	}

	public Double getIdeal(int ind) {
		return ideal.get(ind);
	}

	public void setIdeal(List<Double> ideal) {
		this.ideal = ideal;
	}

	public float[] getInputArray() {
		
		float[] res = new float[input.size()];
		int idx = 0;
		for(Double in : input){
			res[idx++] = in.floatValue();
		}
		
		
		return res;
	}


	public float[] getIdealArray() {
		float[] res = new float[ideal.size()];
		int idx = 0;
		for(Double in : ideal){
			res[idx++] = in.floatValue();
		}
		
		return res;
	}

	

	
	
	
}
package RN.dataset;

import java.util.AbstractList;
import java.util.Arrays;
import java.util.List;
import java.util.RandomAccess;

/**
 * @author Eric Marchand
 *
 */
public class InputDataArray<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable{
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -2086895423766641269L;
	
	
	List<Double[]> inputs; 
	List<Double[]> ideals;
	
	
	public InputDataArray(Double[][] inputs, Double[][] ideals){
		this.inputs = Arrays.asList(inputs);
		this.ideals = Arrays.asList(ideals);
		
	}

	public List<Double[]> getInputs() {
		return inputs;
	}

	public void setInputs(List<Double[]> inputs) {
		this.inputs = inputs;
	}

	public List<Double[]> getIdeals() {
		return ideals;
	}

	public void setIdeals(List<Double[]> ideals) {
		this.ideals = ideals;
	}

	@Override
	public E get(int index) {
		return (E) new InputData(inputs.get(index), ideals.get(index));
	}

	@Override
	public int size() {
		return inputs.size();
	}

	

}
package RN.dataset;

import java.util.AbstractList;
import java.util.List;
import java.util.RandomAccess;

/**
 * @author Eric Marchand
 *
 */
public class InputDataList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable{
	
	/**
	 * 
	 */
	private static final long serialVersionUID = -2086895423766641269L;
	
	
	private List<List> inputs; 
	private List<List> ideals;
	
	
	public InputDataList(List<List> inputs, List<List> ideals){
		this.inputs = inputs;
		this.ideals = ideals;
		
	}



	@Override
	public E get(int index) {
		
		return (E) new InputData(inputs.get(index), ideals == null ? null : ideals.get(index));
	}

	@Override
	public int size() {
		return inputs.size();
	}



	public List<List> getInputs() {
		return inputs;
	}



	public void setInputs(List<List> inputs) {
		this.inputs = inputs;
	}



	public List<List> getIdeals() {
		return ideals;
	}



	public void setIdeals(List<List> ideals) {
		this.ideals = ideals;
	}



	public void clear() {
		inputs.clear();
		ideals.clear();
	}

	

}
package RN.dataset.inputsamples;

/**
 * @author Eric Marchand
 *
 */
public enum ESamples {
	ADD, SUBSTRACT,
	SINUS, COSINUS,
	// Champs recepteurs vision, gaussienne, gaussienne De Marr (principe d'Heisenberg), dérivée première, dérivée seconde (filtre LOG) ...
	GAUSSIAN, GAUSSIAN_DE_MARR, Gx_DE_MARR, Gy_DE_MARR, 
	G_D1xy_DE_MARR, G_Dxy_DE_MARR, G_Dx_DE_MARR, G_Dy_DE_MARR, 
	G_D2xy_DE_MARR, G_D2xyTheta_DE_MARR, G_Dxx_DE_MARR, G_Dyy_DE_MARR,  
	G_D3xy_DE_MARR, G_Dxxx_DE_MARR, G_Dxxy_DE_MARR, G_Dxyy_DE_MARR, G_Dyyy_DE_MARR,
	G_COURBURE_DE_MARR,
	COMPLEX, 
	CHAOS, 
	MEANEXP1, MEANEXP2, MEANEXP3, 
	IDENTITY, 
	FILE, MACD, TIMESERIE, RAND, NONE, SAMPLING, MULTIPLY,
	LOG_GABOR;
	
}
package RN.dataset.inputsamples;

import java.io.FileInputStream;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Date;
import java.util.Deque;
import java.util.Iterator;
import java.util.List;

import org.apache.poi.hssf.usermodel.HSSFCell;
import org.apache.poi.hssf.usermodel.HSSFRow;
import org.apache.poi.hssf.usermodel.HSSFSheet;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;

import RN.DataSeries;
import RN.EBoolean;
import RN.ITester;
import RN.NetworkElement;
import RN.ViewerFX;
import RN.dataset.Coordinate;
import RN.dataset.DataUtils;
import RN.utils.StreamUtils;
import javafx.scene.image.Image;
import javafx.scene.image.PixelReader;
import javafx.scene.paint.Color;

/**
 * 
 * @author Eric Marchand
 * 
 */
public class InputSample extends NetworkElement{

	private static InputSample instance = null;

	private String name;
	private ESamples sample;
	private int fileSheetIdx;
	public static double[] Ikeda;
	private static SimpleDateFormat f = new SimpleDateFormat("dd-MM-yyyy");


	public InputSample() {
		// this.name = name;
		// this.sample = sample;
		initIkeda();
	}

	public InputSample(String name, ESamples sample) {
		this.name = name;
		this.sample = sample;
		initIkeda();
		getInstance();
	}

	public InputSample(String name, ESamples sample, int idx) {
		this.name = name;
		this.sample = sample;
		this.fileSheetIdx = idx;
		initIkeda();
		getInstance();
	}

	public static InputSample getInstance() {
		if (instance == null) {
			instance = new InputSample();
		}
		return instance;
	}

	@Override
	public String toString() {
		return this.name;
	}

	private Deque<Double> latestSeries1;
	private Deque<Double> latestSeries2;
	private Deque<Double> latestSeries3;
	

	public Double compute(ESamples function, Double... paramDouble) {
		double d1 = 0;

		if (function == null)
			return paramDouble[0];
		
		
		if (function == ESamples.LOG_GABOR) {

			if (paramDouble.length != 9)
				throw new RuntimeException("Missing Gabor parameter's");

			double n = paramDouble[0];
			
			double x = paramDouble[1];
			double y = paramDouble[2];
			
			double x0 = paramDouble[3];
			double y0 = paramDouble[4];
			
			//Number of scales of the multiresolution scheme
			double n_s = paramDouble[5];
			double s = paramDouble[6];
			
			//Number of orientations (between 3 to 20) 8 is a typical value
			double t = paramDouble[7];
			double n_t = paramDouble[8];

			// (p,theta) are the log-polar coordinate (in log2 scale)
			Coordinate coord = new Coordinate(x,y);
			coord.setX0(x0);
			coord.setY0(y0);
			coord.setBase(2D);
			coord.linearToLogPolarSystem();
			
			double p = coord.getP();
			double theta = coord.getTheta();

			// centre du filtre
			double r_s = Math.log10(n) / Math.log10(2) - s;
			double theta_st = s % 2D == 0D ? (Math.PI / n_t) * (t + 0.5D) : (Math.PI / n_t) * t;

			// variance selon r et theta
			double sigma_theta = 0.996D * ( Math.PI / (n_t * Math.sqrt(2D)));
			double sigma_r = 0.996D * Math.sqrt(2D / 3D);
			
			d1 = Math.exp(- Math.pow(p - r_s, 2D) / (2D * sigma_r * sigma_r));
			
			d1 *=  Math.exp(- Math.pow(theta - theta_st, 2D) / (2D * sigma_theta * sigma_theta));
			
		}else if (function == ESamples.SAMPLING) {

			if (paramDouble.length == 1)
				throw new RuntimeException("Missing sampling parameter's");

			double x = paramDouble[0];
			double y = paramDouble[1];
			double sampling = paramDouble[2];

			d1 = (x % sampling == 0  ? 1D : 0D);
			d1 *= (y % sampling == 0  ? 1D : 0D);
			
		}else if (function == ESamples.GAUSSIAN) {

			if (paramDouble.length == 1)
				throw new RuntimeException("Missing gaussian parameter's");

			double widthPx = paramDouble[0];
			double heightPx = paramDouble[1];
			double x = paramDouble[2];
			double y = paramDouble[3];

			// centre
			double x1 = paramDouble[4];
			double y1 = paramDouble[5];

			// ecartement selon x et y
			double ox = paramDouble[6];
			double oy = paramDouble[7];
			
			d1 = Gxy( x,  x1,  ox,  y,  y1,  oy);
		
			
		}else if (function == ESamples.GAUSSIAN_DE_MARR) {

			if (paramDouble.length == 1)
				throw new RuntimeException("Missing gaussian parameter's");

			double widthPx = paramDouble[0];
			double heightPx = paramDouble[1];
			double x = paramDouble[2];
			double y = paramDouble[3];

			// centre
			double x1 = paramDouble[4];
			double y1 = paramDouble[5];

			// ecartement selon x et y
			double ox = paramDouble[6];
			double oy = paramDouble[7];
			
			double k = (paramDouble.length == 9 && paramDouble[8] != null ? paramDouble[8] : 1);
			
			if(k != 1){
				d1 =  ( 1D / (2D * Math.PI * k * Math.pow(ox,2D)) ) * Math.exp( -(Math.pow(x - x1, 2D) + Math.pow(y - y1, 2D))  /   (2D * k * ox * oy)  );
			}else{
				d1 =  Gxy_DE_MARR(x, x1, ox, y, y1, oy);
			}
			
		}else if (function == ESamples.G_Dx_DE_MARR) {

			if (paramDouble.length == 1)
				throw new RuntimeException("Missing gaussian parameter's");

			double widthPx = paramDouble[0];
			double heightPx = paramDouble[1];
			double x = paramDouble[2];
			double y = paramDouble[3];

			// centre
			double x1 = paramDouble[4];
			double y1 = paramDouble[5];

			// ecartement selon x et y
			double ox = paramDouble[6];
			double oy = paramDouble[7];
			
			d1 = G_Dx_DE_MARR(x, x1, ox, y, y1, oy);
		
			
		}else if (function == ESamples.G_Dy_DE_MARR) {

			if (paramDouble.length == 1)
				throw new RuntimeException("Missing gaussian parameter's");

			double widthPx = paramDouble[0];
			double heightPx = paramDouble[1];
			double x = paramDouble[2];
			double y = paramDouble[3];

			// centre
			double x1 = paramDouble[4];
			double y1 = paramDouble[5];

			// ecartement selon x et y
			double ox = paramDouble[6];
			double oy = paramDouble[7];
			
			d1 = G_Dy_DE_MARR(x, x1, ox, y, y1, oy);
		
			
		}else if (function == ESamples.G_Dxy_DE_MARR) {

			if (paramDouble.length == 1)
				throw new RuntimeException("Missing gaussian parameter's");

			double widthPx = paramDouble[0];
			double heightPx = paramDouble[1];
			double x = paramDouble[2];
			double y = paramDouble[3];

			// centre
			double x1 = paramDouble[4];
			double y1 = paramDouble[5];

			// ecartement selon x et y
			double ox = paramDouble[6];
			double oy = paramDouble[7];
			
			Double k = paramDouble.length == 9 ? paramDouble[8] : null;
			
			if(k != null)
				d1 = G_Dxy_DE_MARR(x, x1, ox, y, y1, oy, k);
			else
				d1 = G_Dxy_DE_MARR(x, x1, ox, y, y1, oy);
			
		}else if (function == ESamples.G_Dxx_DE_MARR) {

			if (paramDouble.length == 1)
				throw new RuntimeException("Missing gaussian parameter's");

			double widthPx = paramDouble[0];
			double heightPx = paramDouble[1];
			double x = paramDouble[2];
			double y = paramDouble[3];

			// centre
			double x1 = paramDouble[4];
			double y1 = paramDouble[5];

			// ecartement selon x et y
			double ox = paramDouble[6];
			double oy = paramDouble[7];
			
			Double k = paramDouble.length == 9 ? paramDouble[8] : null;
			
			if(k != null)
				d1 = G_Dxx_DE_MARR(x, x1, ox, y, y1, oy, k);
			else
				d1 = G_Dxx_DE_MARR(x, x1, ox, y, y1, oy);
			
		}else  if (function == ESamples.G_Dyy_DE_MARR) {

			if (paramDouble.length == 1)
				throw new RuntimeException("Missing gaussian parameter's");

			double widthPx = paramDouble[0];
			double heightPx = paramDouble[1];
			double x = paramDouble[2];
			double y = paramDouble[3];

			// centre
			double x1 = paramDouble[4];
			double y1 = paramDouble[5];

			// ecartement selon x et y
			double ox = paramDouble[6];
			double oy = paramDouble[7];
			
			Double k = paramDouble.length == 9 ? paramDouble[8] : null;
			
			if(k != null)
				d1 = G_Dyy_DE_MARR(x, x1, ox, y, y1, oy, k);
			else
				d1 = G_Dyy_DE_MARR(x, x1, ox, y, y1, oy);
			
		}else if (function == ESamples.G_D2xy_DE_MARR) {

			if (paramDouble.length == 1)
				throw new RuntimeException("Missing gaussian parameter's");

			double widthPx = paramDouble[0];
			double heightPx = paramDouble[1];
			double x = paramDouble[2];
			double y = paramDouble[3];


			// centre
			double x1 = paramDouble[4];
			double y1 = paramDouble[5];

			// ecartement selon x et y
			double ox = paramDouble[6];
			double oy = paramDouble[7];

			d1 = G_D2xy_DE_MARR(x, x1, ox, y, y1, oy);
			
		}else if (function == ESamples.G_D2xyTheta_DE_MARR) {

			if (paramDouble.length == 1)
				throw new RuntimeException("Missing gaussian parameter's");

			double widthPx = paramDouble[0];
			double heightPx = paramDouble[1];
			double x = paramDouble[2];
			double y = paramDouble[3];


			// centre
			double x1 = paramDouble[4];
			double y1 = paramDouble[5];

			// ecartement selon x et y
			double ox = paramDouble[6];
			double oy = paramDouble[7];
			
			double theta = paramDouble[8];
			
			Double k = paramDouble.length == 10 ? paramDouble[9] : null;
			
			if(k != null)
				d1 = G_D2xyTheta_DE_MARR(x, x1, ox, y, y1, oy, theta, k);
			else
				d1 = G_D2xyTheta_DE_MARR(x, x1, ox, y, y1, oy, theta);

			
		}else if (function == ESamples.G_D3xy_DE_MARR) {

			if (paramDouble.length == 1)
				throw new RuntimeException("Missing gaussian parameter's");

			double widthPx = paramDouble[0];
			double heightPx = paramDouble[1];
			double x = paramDouble[2];
			double y = paramDouble[3];


			// centre
			double x1 = paramDouble[4];
			double y1 = paramDouble[5];

			// ecartement selon x et y
			double ox = paramDouble[6];
			double oy = paramDouble[7];

			d1 = G_Dxxx_DE_MARR(x, x1, ox, y, y1, oy) + G_Dyyy_DE_MARR(x, x1, ox, y, y1, oy);
			
		}else if (function == ESamples.G_Dxxy_DE_MARR) {
			
//			Le traitement repose sur cinq paramètres :
//				N représente la taille du masque (matrice carrée) implantant le filtre LOG. N est impair.
//				σ permet d'ajuster la taille du chapeau mexicain.
//				∆x et ∆y sont les pas d'échantillonnage utilisés pour discrétiser h''(x,y). Généralement ∆x = ∆ y
//				S est le seuil qui permet de sélectionner les contours les plus marqués.
//				Il est à noter que le choix des paramètres N, σ et ∆x ne doit pas se faire de façon indépendante. En effet, le masque, même de taille réduite, doit ressembler à un chapeau mexicain. Le problème ici est le même que celui que l'on rencontre lors de l'échantillonnage d'une fonction gaussienne. Le nombre de points N à considérer doit être tel que l'étendue occupe l'intervalle [-3σ , 3σ].
//				En fonction du pas d'échantillonnage, l'étendue spatiale vaut : (N-1) ∆x  .
//				Cette étendue peut aussi s'écrire en fonction de σ : (N-1) ∆x = kσ  avec k entier.
//				En prenant par exemple  ∆x = 1 , il s'agit de choisir N et σ de sorte que l'étendue du chapeau mexicain soit pertinente. Pour le chapeau mexicain, la valeur de k doit être au moins de 4.

			if (paramDouble.length == 1)
				throw new RuntimeException("Missing gaussian parameter's");

			double widthPx = paramDouble[0];
			double heightPx = paramDouble[1];
			double x = paramDouble[2];
			double y = paramDouble[3];


			// centre
			double x1 = paramDouble[4];
			double y1 = paramDouble[5];

			// ecartement selon x et y
			double ox = paramDouble[6];
			double oy = paramDouble[7];

			d1 = G_Dxxy_DE_MARR(x, x1, ox, y, y1, oy);
			
		} else if (function == ESamples.G_Dxyy_DE_MARR) {
			

			if (paramDouble.length == 1)
				throw new RuntimeException("Missing gaussian parameter's");

			double widthPx = paramDouble[0];
			double heightPx = paramDouble[1];
			double x = paramDouble[2];
			double y = paramDouble[3];


			// centre
			double x1 = paramDouble[4];
			double y1 = paramDouble[5];

			// ecartement selon x et y
			double ox = paramDouble[6];
			double oy = paramDouble[7];

			
			d1 = G_Dxyy_DE_MARR(x, x1, ox, y, y1, oy);
			
		} else if (function == ESamples.G_Dyyy_DE_MARR) {
			

			if (paramDouble.length == 1)
				throw new RuntimeException("Missing gaussian parameter's");

			double widthPx = paramDouble[0];
			double heightPx = paramDouble[1];
			double x = paramDouble[2];
			double y = paramDouble[3];


			// centre
			double x1 = paramDouble[4];
			double y1 = paramDouble[5];

			// ecartement selon x et y
			double ox = paramDouble[6];
			double oy = paramDouble[7];

			d1 = G_Dyyy_DE_MARR( x, x1, ox, y, y1, oy);
			
		} else if (function == ESamples.G_Dxxx_DE_MARR) {
			

			if (paramDouble.length == 1)
				throw new RuntimeException("Missing gaussian parameter's");

			double widthPx = paramDouble[0];
			double heightPx = paramDouble[1];
			double x = paramDouble[2];
			double y = paramDouble[3];


			// centre
			double x1 = paramDouble[4];
			double y1 = paramDouble[5];

			// ecartement selon x et y
			double ox = paramDouble[6];
			double oy = paramDouble[7];

			d1 = G_Dxxx_DE_MARR(x, x1, ox, y, y1, oy);
			
			
			
		} else if (function == ESamples.G_COURBURE_DE_MARR) {
			

			if (paramDouble.length == 1)
				throw new RuntimeException("Missing gaussian parameter's");

			double widthPx = paramDouble[0];
			double heightPx = paramDouble[1];
			double x = paramDouble[2];
			double y = paramDouble[3];


			// centre
			double x1 = paramDouble[4];
			double y1 = paramDouble[5];

			// ecartement selon x et y
			double ox = paramDouble[6];
			double oy = paramDouble[7];

			d1 =  Math.abs(G_Dxx_DE_MARR(x, x1, ox, y, y1, oy) * G_Dyy_DE_MARR(x, x1, ox, y, y1, oy) - Math.pow(G_Dxy_DE_MARR(x, x1, ox, y, y1, oy), 2D));
			
			
		} else if (function == ESamples.COSINUS) {
			paramDouble[0] *= 16.0D;
			d1 = 0.5D + Math.cos(paramDouble[0] * 3.141592653589793D) / 2.0D;
			
		}else if(function == ESamples.SINUS){
			paramDouble[0] *= 4.0D;
			d1 = 0.5D + Math.sin(paramDouble[0] * 4.0D * 3.141592653589793D) / 2.0D;
			
		}else if(function == ESamples.COMPLEX){ 
			d1 = 0.5D + (Math.sin(paramDouble[0] * 3.0D * 3.141592653589793D) + Math.sin(paramDouble[0] * 7.0D * 3.141592653589793D)
					+ Math.sin(paramDouble[0] * 8.0D * 3.141592653589793D) + Math.sin(paramDouble[0] * 11.0D * 3.141592653589793D)) / 8.0D;
			
		}else if(function == ESamples.CHAOS){
			if (paramDouble[0] >= 2.0D) {
				d1 = Ikeda[201];
			} else {
				int i = (int) (paramDouble[0] * 100.0D);
				double d2 = 100.0D * paramDouble[0] - i;
				d1 = Ikeda[i] * (1.0D - d2) + Ikeda[(i + 1)] * d2;
			}
			
		}else if(function == ESamples.MEANEXP1){ 
			latestSeries1 = manageLatestSeries(latestSeries1, paramDouble[0], 5);
			d1 = DataUtils.getInstance().getExponentialMean(latestSeries1, 5);
			
		}else if(function == ESamples.MEANEXP2){ 
			latestSeries2 = manageLatestSeries(latestSeries2, paramDouble[0], 10);
			d1 = DataUtils.getInstance().getExponentialMean(latestSeries2, 10);
			
		}else if(function == ESamples.MEANEXP3){ 
			latestSeries3 = manageLatestSeries(latestSeries3, paramDouble[0], 15);
			d1 = DataUtils.getInstance().getExponentialMean(latestSeries3, 15);
			
		}else if(function == ESamples.MACD){ 
			latestSeries1 = manageLatestSeries(latestSeries1, null, 12);
			latestSeries2 = manageLatestSeries(latestSeries2, null, 26);
			latestSeries3 = manageLatestSeries(latestSeries3, null, 9);
			double lastMACD = DataUtils.getInstance().getExponentialMean(latestSeries1, 12) - DataUtils.getInstance().getExponentialMean(latestSeries2, 26);
			double lastSignal = DataUtils.getInstance().getExponentialMean(latestSeries3, 9);
			double lastHistogram = lastMACD - lastSignal;

			latestSeries1 = manageLatestSeries(latestSeries1, paramDouble[0], 12);
			latestSeries2 = manageLatestSeries(latestSeries2, paramDouble[0], 26);
			double MACD = DataUtils.getInstance().getExponentialMean(latestSeries1, 12) - DataUtils.getInstance().getExponentialMean(latestSeries2, 26);
			latestSeries3 = manageLatestSeries(latestSeries3, MACD, 9);
			double signal = DataUtils.getInstance().getExponentialMean(latestSeries3, 9);
			double histogram = MACD - signal;
			d1 = DataUtils.getInstance().MACD(lastMACD, MACD, lastSignal, signal, lastHistogram, histogram, paramDouble[0]);
			
		}else if(function == ESamples.RAND){
			d1 = Math.random();

		}else if(function == ESamples.TIMESERIE){ 
			// centrer reduit ?
		}else{ //IDENTITY
			d1 = paramDouble[0];
		}

		return d1;
	}
	
	
	private double Gxy(double x, double x1, double ox, double y, double y1, double oy) {
		
		return Math.exp((- Math.pow(x - x1, 2D) - Math.pow(y - y1, 2D))  /  (2D * ox * oy));
	}
	
	private double Gxy(double x, double x1, double ox, double y, double y1, double oy, double k) {
		
		return Math.exp((- Math.pow(x - x1, 2D) - Math.pow(y - y1, 2D))  /  (2D * k * ox * oy));
	}
	
	private double Gx(double x, double x1, double ox) {
		
		double result;
		double term1 = Math.pow(x - x1, 2D)  /   (2D * Math.pow( ox, 2D));
		
		result = Math.exp(-term1);
		
		return result;
	}
	
	private double Gy(double y, double y1, double oy) {
		
		double result;
		double term2 = Math.pow(y - y1, 2D)  /  (2D * Math.pow( oy, 2D));
		
		result = Math.exp(-term2);
		
		return result;
	}
	
	private double Gx_DE_MARR(double x, double x1, double ox) {
		
		double result;
		double term1 = ( 1D / (2D * Math.PI * Math.pow(ox,2D)) );
		
		result = term1 * Gx(x, x1, ox);
		
		return result;
	}
	
	
	private double Gy_DE_MARR(double y, double y1, double oy) {
		
		double result;
		double term1 = ( 1D / (2D * Math.PI * Math.pow(oy,2D))) ;
		
		result = term1 * Gy(y, y1, oy);
		
		return result;
	}
	
	private double Gxy_DE_MARR(double x, double x1, double ox, double y, double y1, double oy) {
		
		double result;
		double term1 = ( 1D / (2D * Math.PI * Math.pow(ox,2D)) );
		
		result = term1 * Gx(x, x1, ox) * Gy(y, y1, oy);
		
		return result;
	}
	
	private double G_Dx(double x, double x1, double ox) {
		
		double result;
		double term1 =  -(x - x1)  /  Math.pow( ox, 2);
		
		result = term1 * Gx_DE_MARR(x, x1, ox);
		
		return result;
	}
	
	private double G_Dy(double y, double y1, double oy) {
		
		double result;
		double term1 =  -(y - y1)  /  Math.pow( oy, 2);
		
		result = term1 * Gy_DE_MARR(y, y1, oy);
		
		return result;
	}
	
	private double G_Dxx(double x, double x1, double ox, double y, double y1, double oy) {
		
		double term1 =  (Math.pow(x - x1, 2D) - Math.pow( ox, 2D))  /  (2D * Math.PI * Math.pow( ox, 6D));
		
		return term1 * Gxy(x, x1, ox, y, y1, oy);
	}
	
	private double G_Dxx(double x, double x1, double ox, double y, double y1, double oy, double k) {
		
		double term1 =  (Math.pow(x - x1, 2D) - k * Math.pow( ox, 2D))  /  (2D * Math.PI * k * Math.pow( ox, 6D));
		
		return term1 * Gxy(x, x1, ox, y, y1, oy, k);
	}
	
	/**
	 * Dérivée Seconde partielle en x puis en y
	 * @param x
	 * @param x1
	 * @param ox
	 * @param y
	 * @param y1
	 * @param oy
	 * @return
	 */
	private double G_Dxy(double x, double x1, double ox, double y, double y1, double oy) {
		
		double result;
		
		result =  ((x-x1)*(y-y1)) / (2D * Math.PI * Math.pow(ox, 3D) * Math.pow(oy, 3D) ) * Gxy(x, x1, ox, y, y1, oy);
		
		return result;
	}
	
	private double G_Dxy(double x, double x1, double ox, double y, double y1, double oy, double k) {
		
		double result;
		
		result =  ((x-x1)*(y-y1)) / (2D * Math.PI * k * Math.pow(ox, 3D) * Math.pow(oy, 3D) ) * Gxy(x, x1, ox, y, y1, oy, k);
		
		return result;
	}
	
	/**
	 * Dérivée Seconde de la gaussienne de marr en 2D
	 * @param x
	 * @param x1
	 * @param ox
	 * @param y
	 * @param y1
	 * @param oy
	 * @return
	 */
	private double G_D2xy_DE_MARR(double x, double x1, double ox, double y, double y1, double oy) {
		
		double result;
		
		//result =  G_Dxx(x, x1, ox) * G_Dyy(y, y1, oy);
		
		double term1 =  (-1D / (Math.PI * Math.pow(ox, 4D))) * (1D - ( Math.pow(x-x1, 2D) + Math.pow(y-y1, 2D)) / (2D * Math.pow(ox, 2D)))  ;
		
		result = term1 * Gxy(x, x1, ox, y, y1, oy);
		
		return result;
	}
	
//	private double G_D2xx_DE_MARR(double x, double x1, double ox) {
//		
//		double result;
//		
//		double term1 =  (Math.pow(x-x1, 2D) - Math.pow(ox, 2D)) / (  Math.PI * Math.pow(ox, 6D));
//		result = term1 * Gx(x, x1, ox);
//		
//		return result;
//	}
	
//	private double G_D2yy_DE_MARR( double y, double y1, double oy) {
//		
//		double result;
//		
//		double term1 =  (Math.pow(y-y1, 2D) - Math.pow(oy, 2D)) / (  Math.PI * Math.pow(oy, 6D));
//		result = term1 * Gy(y, y1, oy);		
//		
//		return result;
//	}
	
	private double G_D2xyTheta_DE_MARR(double x, double x1, double ox, double y, double y1, double oy, double theta) {
		
		double result;
		
		//theta = Math.atan2( G_Dy(y, y1, oy),  G_Dx(x, x1, ox));
		
		theta = theta * (Math.PI / 180D);
		
		result =  (Math.pow(Math.cos(theta), 2D) * G_Dxx(x, x1, ox, y, y1, oy)) + (2D * Math.cos(theta) * Math.sin(theta) * G_Dxy(x, x1, ox, y, y1, oy)) + (Math.pow(Math.sin(theta), 2D) * G_Dyy(x, x1, ox, y, y1, oy));
		
		
		return result;
	}
	
	private double G_D2xyTheta_DE_MARR(double x, double x1, double ox, double y, double y1, double oy, double theta, double k) {
		
		double result;
		
		theta = theta * (Math.PI / 180D);
		
		result =  (Math.pow(Math.cos(theta), 2D) * G_Dxx(x, x1, ox, y, y1, oy, k)) + (2D * Math.cos(theta) * Math.sin(theta) * G_Dxy(x, x1, ox, y, y1, oy, k)) + (Math.pow(Math.sin(theta), 2D) * G_Dyy(x, x1, ox, y, y1, oy, k));
		
		
		return result;
	}
	
	private double G_Dx_DE_MARR(double x, double x1, double ox, double y, double y1, double oy) {
		
		double result;
		
		
		result = ( -(x - x1) / (2D * Math.PI * Math.pow(ox, 4D) )) * Gxy(x, x1, ox, y, y1, oy);
		
		return result;
	}
	
	private double G_Dy_DE_MARR(double x, double x1, double ox, double y, double y1, double oy) {
		
		double result;
		
		
		result = ( -(y - y1) / (2D * Math.PI * Math.pow(oy, 4D) )) * Gxy(x, x1, ox, y, y1, oy);
		
		return result;
	}
	
	private double G_Dxy_DE_MARR(double x, double x1, double ox, double y, double y1, double oy, double k) {
		
		double result;
		
		
		result = ( ((x - x1) * (y - y1)) / (2D * Math.PI * k * Math.pow(ox, 4D) * Math.pow(oy, 2D))) * Gxy(x, x1, ox, y, y1, oy, k);
		
		return result;
	}
	
	private double G_Dxy_DE_MARR(double x, double x1, double ox, double y, double y1, double oy) {
		
		double result;
		
		
		result = ( ((x - x1) * (y - y1)) / (2D * Math.PI  * Math.pow(ox, 4D) * Math.pow(oy, 2D))) * Gxy(x, x1, ox, y, y1, oy);
		
		return result;
	}
	
	private double G_Dxx_DE_MARR(double x, double x1, double ox, double y, double y1, double oy) {
		
		return ( (Math.pow(x - x1, 2D) - Math.pow(ox, 2D)) / (2D * Math.PI * Math.pow(ox, 6D) )) * Gxy(x, x1, ox, y, y1, oy);
		
	}
	
	private double G_Dxx_DE_MARR(double x, double x1, double ox, double y, double y1, double oy, double k) {
		
		return ( (Math.pow(x - x1, 2D) -  k * Math.pow(ox, 2D)) / (2D * Math.PI * k * Math.pow(ox, 6D) )) * Gxy(x, x1, ox, y, y1, oy, k);
		
	}
	
	private double G_Dyy_DE_MARR(double x, double x1, double ox, double y, double y1, double oy) {
		
		return ( (Math.pow(y - y1, 2D) - Math.pow(oy, 2D)) / (2D * Math.PI * Math.pow(oy, 6D) )) * Gxy(x, x1, ox, y, y1, oy);
	}
	
	private double G_Dyy_DE_MARR(double x, double x1, double ox, double y, double y1, double oy, double k) {
		
		return ( (Math.pow(y - y1, 2D) - k * Math.pow(oy, 2D)) / (2D * Math.PI * k * Math.pow(oy, 6D) )) * Gxy(x, x1, ox, y, y1, oy, k);
	}
	
	private double G_Dyyy_DE_MARR(double x, double x1, double ox, double y, double y1, double oy) {
		
		double result;
		
		
		result = ( ( -Math.pow(y - y1, 3D) + 3D * (y-y1) * Math.pow(oy, 2D) ) / (2D * Math.PI * Math.pow(oy, 8D) )) * Gxy(x, x1, ox, y, y1, oy);
		
		return result;
	}
	
	private double G_Dxxx_DE_MARR(double x, double x1, double ox, double y, double y1, double oy) {
		
		double result;
		
		
		result = ( ( -Math.pow(x - x1, 3D) + 3D * (x-x1) * Math.pow(ox, 2D) ) / (2D * Math.PI * Math.pow(ox, 8D) )) * Gxy(x, x1, ox, y, y1, oy);
		
		return result;
	}
	
	private double G_Dxxy_DE_MARR(double x, double x1, double ox, double y, double y1, double oy) {
		
		double result;
		
		
		result = ( ( (y-y1) * Math.pow(ox, 2D) - (y-y1) * Math.pow(x - x1, 2D)) / (2D * Math.PI * Math.pow(ox, 8D) )) * Gxy(x, x1, ox, y, y1, oy);
		
		return result;
	}
	
	private double G_Dxyy_DE_MARR(double x, double x1, double ox, double y, double y1, double oy) {
		
		double result;
		
		
		result = ( ( (x-x1) * Math.pow(ox, 2D) - (x-x1) * Math.pow(y - y1, 2D)) / (2D * Math.PI * Math.pow(oy, 8D) )) * Gxy(x, x1, ox, y, y1, oy);
		
		return result;
	}
	
//	private double G_D3xy_DE_MARR(double x, double x1, double ox, double y, double y1, double oy) {
//		
//		double result;
//		
//		result = ((-Math.pow(x-x1, 3D) -Math.pow(y-y1, 3D) + ( ox * oy * (x-x1 + y-y1))) / (2D * Math.PI * Math.pow(ox, 8D))) * Gxy(x, x1, ox, y, y1, oy);
//		
//		return result;
//	}
	
	private double G_Dyy(double x, double x1, double ox, double y, double y1, double oy) {
		
		double result;
		double term1 =  (Math.pow(y-y1, 2D) - Math.pow( oy, 2D))  /  (2D * Math.PI * Math.pow( oy, 6D));
		
		result = term1 * Gxy(x, x1, ox, y, y1, oy);
		
		return result;
	}
	
	private double G_Dyy(double x, double x1, double ox, double y, double y1, double oy, double k) {
		
		double result;
		double term1 =  (Math.pow(y-y1, 2D) - k * Math.pow( oy, 2D))  /  (2D * Math.PI * k * Math.pow( oy, 6D));
		
		result = term1 * Gxy(x, x1, ox, y, y1, oy, k);
		
		return result;
	}
	
	private double G_Dxxx(double x, double x1, double ox, double y, double y1, double oy) {
		
		double result;
		double term1 =  ( 3D * (x-x1) * Math.pow( ox, 2D) - Math.pow(x-x1, 3D) )  /  (2D * Math.PI * Math.pow( ox, 8D));
		
		result = term1 * Gxy(x, x1, ox, y, y1, oy);
		
		return result;
	}
	
	
	
	
	private double DerivatedGaussian(int n, double x, double x1, double sigmax){
		
		return Hnsigma(n, sigmax, x) * Gx(x, x1, sigmax);
	}
	
	private double Hnsigma(int n, double sigmax, double x){
		return (Math.pow(-1D, n) / (sigmax * Math.sqrt(2D)) * PolynomeHermite(n, x / (sigmax * Math.sqrt(2D))));
	}
	
	private Double PolynomeHermite(int n, double value){
		if(n==0){
			return 1D;
		}else if(n==1){
			return 2D * value;
		}else if(n==2){
			return 4D * Math.pow(value, 2D) - 2D;
		}else if(n==3){
			return 8D * Math.pow(value, 3D) - (12D * value);
		}else if(n==4){
			return 16D * Math.pow(value, 4D) - (48D * Math.pow(value, 2D) + 12D);
		}else if(n==5){
			return 32D * Math.pow(value, 5D) - (160D * Math.pow(value, 3D) + (120D * value));
		}else if(n==6){
			return 64D * Math.pow(value, 6D) - (480D * Math.pow(value, 4D) + (720D * Math.pow(value, 2D)) - 120D );
		}
		return null;
	}
	
	  

	private Deque<Double> manageLatestSeries(Deque<Double> latestInputValues, Double inputValue, int i) {

		int latestPeriodsCount = 26;
		if (latestInputValues == null)
			latestInputValues = new ArrayDeque<Double>(i);

		if (i > latestPeriodsCount)
			throw new RuntimeException("depassement de longueur, rallonger les historiques de donnees");

		if (inputValue == null)
			return latestInputValues;

		if (latestInputValues.isEmpty()) {
			for (int idx = 0; idx < latestPeriodsCount - 1; idx++)
				latestInputValues.addFirst(inputValue);
		}

		if (latestInputValues.size() > 0)
			latestInputValues.removeLast();

		latestInputValues.addFirst(inputValue);

		return latestInputValues;
	}

	public static void initIkeda() {
		double d1 = 0.0D;
		double d2 = 0.0D;
		Ikeda = new double[201];
		for (int i = 0; i <= 200; i++) {
			double d3 = 0.4D - 6.0D / (1.0D + d1 * d1 + d2 * d2);
			d1 = 1.0D + 0.7D * (d1 * Math.cos(d3) - d2 * Math.sin(d3));
			d2 = 0.7D * (d1 * Math.sin(d3) + d2 * Math.sin(d3));
			Ikeda[i] = (d1 - 0.2D);
		}
	}

	public static void setSamples(int inputCount, int outputCount, double delta, double delay) {

		DataSeries.getInstance().clearSeries();

		double d1 = (inputCount + outputCount - 2) * delta + delay;
		double d2;
		double d3;

		for (double j = 0; j < 500; j++) {
			List<Double> inputList = new ArrayList<Double>();
			List<Double> outputList = new ArrayList<Double>();
			d2 = j * (1.0D - d1) / 500.0D;

			for (int i = 0; i < inputCount; i++) {
				d3 = d2 + delta * i;
				inputList.add(InputSample.getInstance().compute(ViewerFX.getSelectedSample(), d3));
				// inputList.add((Math.sin(d3 * 3.0D * 3.141592653589793D) +
				// Math.sin(d3 * 7.0D * 3.141592653589793D) + Math.sin(d3 * 8.0D
				// * 3.141592653589793D)) / 8.0D + 0.5D);
			}
			for (int i = 0; i < outputCount; i++) {
				d3 = d2 + delay + delta * (i + inputCount - 1);
				outputList.add(InputSample.getInstance().compute(ViewerFX.getSelectedSample(), d3));
			}
			DataSeries.getInstance().addINPUTS(inputList);
			DataSeries.getInstance().addIDEALS(outputList);
		}
	}

	public static List<String> getSheetsName(String filePath) {
		List<String> sheetsName = new ArrayList<String>();
		FileInputStream fis = null;
		try {

			fis = new FileInputStream(filePath);
			HSSFWorkbook workbook = new HSSFWorkbook(fis);
			HSSFSheet sheet = null;
			for (int idx = 0; idx < workbook.getNumberOfSheets(); idx++) {
				sheet = workbook.getSheetAt(idx);
				sheetsName.add(sheet.getSheetName());
			}

		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			if (fis != null) {
				try {
					fis.close();
					fis = null;
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}

		return sheetsName;
	}

	public static void setFileSample(ITester tester, String filePath, Integer sheetIndex) throws Exception {

		DataSeries.getInstance().clearSeries();
		FileInputStream fis = null;

		try {
			
			initContext();

			fis = new FileInputStream(filePath);

			HSSFWorkbook workbook = new HSSFWorkbook(fis);
			workbook.setMissingCellPolicy(Row.CREATE_NULL_AS_BLANK);
			HSSFSheet sheet = workbook.getSheetAt(sheetIndex - 1);
			String lastContentType = null;
			Iterator rows = sheet.rowIterator();
			int rowIdx = 0;
			while (rows.hasNext()) {
				HSSFRow row = (HSSFRow) rows.next();

				Iterator cells = row.cellIterator();
				while (cells.hasNext()) {
					
					HSSFCell cell = (HSSFCell) cells.next();
					
					if(cell.getColumnIndex() > 0)
						continue;
					
					String contentType = cell.getStringCellValue().toUpperCase();
					int valuesSize = row.getLastCellNum() - 1;

					if (lastContentType != null && !lastContentType.contains("DATA") && contentType.contains("DATA")){
						createNetwork(tester, sheet, rowIdx);
					}

					if (contentType.equals("DATA")) {
						processData(row, valuesSize);
						lastContentType = contentType;
						break;
					} else if(contentType.equals("DATASIMPLEIMG")){
						processSimpleImage(row, valuesSize);
						lastContentType = contentType;
						break;
					} else if(contentType.equals("DATAIMG")){
						processImage(row, valuesSize);
						lastContentType = contentType;
						break;
					} else if(contentType.equals("DATAIMGTEST")){
						processImageTest(row, valuesSize);
						lastContentType = contentType;
						break;
					}else if (contentType.equals("TEST")){
						processTest(row, valuesSize);
						lastContentType = contentType;
						break;
					} else if (contentType.equals("NETWORKTYPE")) {
						processNetworkType(cells, valuesSize);
					} else if (contentType.equals("KIND")) {
						processKind(cells, valuesSize);
					} else if (contentType.equals("LAYER")) {
						processLayer(cells, valuesSize);
					} else if (contentType.equals("AREASCALE")) {
						processAreaScale(cells, valuesSize);
					} else if (contentType.equals("AREATYPE")) {
						processAreaType(cells, valuesSize);
					} else if (contentType.equals("AREAIMAGE")) {
						processAreaImage(cells, valuesSize);
					} else if (contentType.equals("AREA")) {
						processArea(cells, valuesSize);
					} else if (contentType.equals("NODECOUNT")) {
						processNodeCount(cells, valuesSize);
					} else if (contentType.equals("NODEBIASWEIGHT")) {
						processNodeBiasWeight(cells, valuesSize);
					} else if (contentType.equals("NODETYPE")) {
						processNodeType(cells, valuesSize);
					} else if (contentType.equals("NODEACTIVATION")) {
						processNodeActivation(cells, valuesSize);
					} else if (contentType.equals("NODERECURRENT")) {
						processNodeRecurrent(cells, valuesSize);
					} else if (contentType.equals("LINK")) {
						processLink(cells, valuesSize);
					} else if (contentType.equals("LINKAGE")) {
						processLinkage(cells, valuesSize);
					} else if (contentType.equals("LINKAGEBETWEENAREAS")) {
						processLinkageBetweenAreas(cells, valuesSize);
					} else if (contentType.equals("LINKAGETARGETEDAREA")) {
						processLinkageTargetedArea(cells, valuesSize);						
					} else if (contentType.equals("LINKAGEOPTPARAMS")) {
						processLinkageOptParams(cells, valuesSize);
					} else if (contentType.equals("LINKAGEWEIGHTMODIFIABLE")) {
						processLinkageWeightModifiable(cells, valuesSize);
					} else if (contentType.equals("FILTER")) {
						processFilter(cells, valuesSize);
					} else if (contentType.equals("LABEL")) {
						processLabel(cells, valuesSize);
					} else if (contentType.equals("AREASAMPLING")){
						processSampling(cells, valuesSize);
					}

					lastContentType = contentType;
				}

				rowIdx++;
				// sheetData.add(data);
			}
			
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			if (fis != null) {
				try {
					fis.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		}

	}

	private static void processSimpleImage(HSSFRow row, int valuesSize) {
		
		// Loading of image
		HSSFCell cellImgPath = (HSSFCell) row.getCell(1);
		Image image = new Image("file:" + cellImgPath.getRichStringCellValue().getString());
		
		PixelReader pixelReader = image.getPixelReader();
		List<Double> dataInput = null;
		List<Double> dataIdeal = null;        
        // Determine the color of each pixel in the image
        for (int readY = 0; readY < image.getHeight(); readY = readY + 4) {
            for (int readX = 0; readX < image.getWidth(); readX = readX + 4) {
                Color color = pixelReader.getColor(readX, readY);
		
				dataInput = new ArrayList<Double>(getContext().getNodeSumByLayerAndKind(0, "INPUT"));
				dataIdeal = new ArrayList<Double>(getContext().getNodeSumByKind("OUTPUT"));
				// while(cells.hasNext()){
				for (int indCol = 1; indCol <= valuesSize; indCol++) {
					HSSFCell cell = (HSSFCell) row.getCell(indCol);
					if (cell.getCellType() == HSSFCell.CELL_TYPE_NUMERIC || cell.getCellType() == HSSFCell.CELL_TYPE_BLANK 
							|| cell.getCellType() == HSSFCell.CELL_TYPE_FORMULA || cell.getCellType() == HSSFCell.CELL_TYPE_STRING) {
						
						
						if (getContext().getKind(cell.getColumnIndex() - 1).indexOf("INPUT") != -1) {
							if(getContext().getLabel(cell.getColumnIndex() - 1).equalsIgnoreCase("X"))
								dataInput.add(getInstance().compute(getContext().getFilter(cell.getColumnIndex() - 1), (double) readX / 100));
							else if(getContext().getLabel(cell.getColumnIndex() - 1).equalsIgnoreCase("Y"))
								dataInput.add(getInstance().compute(getContext().getFilter(cell.getColumnIndex() - 1), (double) readY / 100));
							else if(getContext().getLabel(cell.getColumnIndex() - 1).equalsIgnoreCase("OPACITY"))
								dataInput.add(getInstance().compute(getContext().getFilter(cell.getColumnIndex() - 1), color.getOpacity()));
								
						} 
						else if (getContext().getKind(cell.getColumnIndex() - 1).indexOf("OUTPUT") != -1) {
							if(getContext().getLabel(cell.getColumnIndex() - 1).equalsIgnoreCase("RED"))
								dataIdeal.add(color.getRed());
							else if(getContext().getLabel(cell.getColumnIndex() - 1).equalsIgnoreCase("GREEN"))
								dataIdeal.add(color.getGreen());
							else if(getContext().getLabel(cell.getColumnIndex() - 1).equalsIgnoreCase("BLUE"))
								dataIdeal.add(color.getBlue());
							else if(getContext().getLabel(cell.getColumnIndex() - 1).equalsIgnoreCase("OPACITY"))
								dataIdeal.add(color.getOpacity());
							else{
								double value = cell.getNumericCellValue();
								dataIdeal.add(getInstance().compute(getContext().getFilter(cell.getColumnIndex() - 1), value));
							}
						}
					}
				}
		
				DataSeries.getInstance().addINPUTS(dataInput);
				DataSeries.getInstance().addIDEALS(dataIdeal);
		
            }
        }
		
	}
	
	private static String getPath(String imgPath) {
		
		// Détection du système d'exploitation
		String osName = System.getProperty("os.name").toLowerCase();
		String formattedPath;

		if (osName.contains("win")) {
		    // Sur Windows, les chemins peuvent commencer par un lecteur, donc on les laisse tels quels
		    formattedPath = "file:./" + imgPath.replace("\\", "/");
		} else {
		    // Sur macOS et Linux, on s'assure simplement que le chemin commence par "file:"
		    formattedPath = "file:./" + imgPath.replace("\\", "/");
		}
		
		return formattedPath;
	}
	
	private static void processImage(HSSFRow row, int valuesSize) throws Exception {
		
		// Loading of image
		HSSFCell cellImgPath = (HSSFCell) row.getCell(1);
		
		String imgPath = cellImgPath.getRichStringCellValue().getString();

		// Création de l'objet Image avec le chemin formaté
		Image image = new Image(getPath(imgPath));		
		
		if(image.getException() != null)
			throw image.getException();
		
		PixelReader pixelReader = image.getPixelReader();
		List<Double> dataInput = new ArrayList<Double>(getContext().getNodeSumByLayerAndKind(0, "INPUT"));
		List<Double> dataIdeal = new ArrayList<Double>(getContext().getNodeSumByKind("OUTPUT"));
		
		for (int indCol = 1; indCol <= valuesSize; indCol++) {
			
			HSSFCell cell = (HSSFCell) row.getCell(indCol);
			
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			
			if (cell.getCellType() == HSSFCell.CELL_TYPE_NUMERIC
					|| cell.getCellType() == HSSFCell.CELL_TYPE_FORMULA || cell.getCellType() == HSSFCell.CELL_TYPE_STRING) {

				if (getContext().getKind(cell.getColumnIndex() - 1).indexOf("INPUT") != -1) {
						
						// Determine the color of each pixel in the image
						Color color = null;
						for (int readY = 0; readY < image.getHeight(); readY = readY + getContext().getSamplings(0)) {
							for (int readX = 0; readX < image.getWidth(); readX = readX + getContext().getSamplings(0)) {
								color = pixelReader.getColor(readX, readY);
								dataInput.add(getInstance().compute(
										getContext().getFilter(cell.getColumnIndex() - 1), 
										color.getOpacity(), 
										image.getWidth(),
										image.getHeight(),
										Double.valueOf(readX),
										Double.valueOf(readY)));
							}
						}
						

				} else if (getContext().getKind(cell.getColumnIndex() - 1).indexOf("OUTPUT") != -1) {
					
					if(cell.getCellType() == HSSFCell.CELL_TYPE_STRING){

						// Création de l'objet Image avec le chemin formaté
						image = new Image(getPath(cell.getRichStringCellValue().getString()));	
						if(image.getException() != null)
							throw image.getException();

						pixelReader = image.getPixelReader();
						
					}
					
					
					if (getContext().getLabel(cell.getColumnIndex() - 1).equalsIgnoreCase("RED")) {
						// Determine the color of each pixel in the image
						Color color = null;
						for (int readY = 0; readY < image.getHeight(); readY = readY + getContext().getSamplings(0)) {
							for (int readX = 0; readX < image.getWidth(); readX = readX + getContext().getSamplings(0)) {
								color = pixelReader.getColor(readX, readY);
								dataIdeal.add(color.getRed());
							}
						}
					} else if (getContext().getLabel(cell.getColumnIndex() - 1).equalsIgnoreCase("GREEN")) {
						// Determine the color of each pixel in the image
						Color color =  null;
						for (int readY = 0; readY < image.getHeight(); readY = readY + getContext().getSamplings(0)) {
							for (int readX = 0; readX < image.getWidth(); readX = readX + getContext().getSamplings(0)) {
								color = pixelReader.getColor(readX, readY);
								dataIdeal.add(color.getGreen());
							}
						}
					} else if (getContext().getLabel(cell.getColumnIndex() - 1).equalsIgnoreCase("BLUE")) {
						// Determine the color of each pixel in the image
						Color color =  null;
						for (int readY = 0; readY < image.getHeight(); readY = readY + getContext().getSamplings(0)) {
							for (int readX = 0; readX < image.getWidth(); readX = readX + getContext().getSamplings(0)) {
								color = pixelReader.getColor(readX, readY);
								dataIdeal.add(color.getBlue());
							}
						}
					} else if (getContext().getLabel(cell.getColumnIndex() - 1).equalsIgnoreCase("SATURATION")) {
						// Determine the color of each pixel in the image
						Color color =  null;
						for (int readY = 0; readY < image.getHeight(); readY = readY + getContext().getSamplings(0)) {
							for (int readX = 0; readX < image.getWidth(); readX = readX + getContext().getSamplings(0)) {
								color = pixelReader.getColor(readX, readY);
								dataIdeal.add(color.getSaturation());
							}
						}
					} else if (getContext().getLabel(cell.getColumnIndex() - 1).equalsIgnoreCase("OPACITY")) {
						// Determine the color of each pixel in the image
						Color color =  null;
						for (int readY = 0; readY < image.getHeight(); readY = readY + getContext().getSamplings(0)) {
							for (int readX = 0; readX < image.getWidth(); readX = readX + getContext().getSamplings(0)) {
								color = pixelReader.getColor(readX, readY);
								dataIdeal.add(color.getOpacity());
							}
						}
					} else if (getContext().getLabel(cell.getColumnIndex() - 1).equalsIgnoreCase("BRIGHTNESS")) {
						// Determine the color of each pixel in the image
						Color color =  null;
						for (int readY = 0; readY < image.getHeight(); readY = readY + getContext().getSamplings(0)) {
							for (int readX = 0; readX < image.getWidth(); readX = readX + getContext().getSamplings(0)) {
								color = pixelReader.getColor(readX, readY);
								dataIdeal.add(color.getBrightness());
							}
						}
					}  else {
						double valueNumeric = cell.getNumericCellValue();
						dataIdeal.add(getInstance().compute(getContext().getFilter(cell.getColumnIndex() - 1), valueNumeric));
					}
					
				}
			}
		}
		
		DataSeries.getInstance().addINPUTS(dataInput);
		DataSeries.getInstance().addIDEALS(dataIdeal);
		
				
	}
	
	private static void processImageTest(HSSFRow row, int valuesSize) {
		
		// Loading of image
		HSSFCell cellImgPath = (HSSFCell) row.getCell(1);
		Image image = new Image(getPath(cellImgPath.getRichStringCellValue().getString()));	
		
		PixelReader pixelReader = image.getPixelReader();
		List<Double> dataInput = new ArrayList<Double>(getContext().getNodeSumByLayerAndKind(0, "INPUT"));
		
		for (int indCol = 1; indCol <= valuesSize; indCol++) {
			HSSFCell cell = (HSSFCell) row.getCell(indCol);
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			
			if (cell.getCellType() == HSSFCell.CELL_TYPE_NUMERIC 
					|| cell.getCellType() == HSSFCell.CELL_TYPE_FORMULA || cell.getCellType() == HSSFCell.CELL_TYPE_STRING) {


				if (getContext().getKind(cell.getColumnIndex() - 1).indexOf("INPUT") != -1) {
					
						// Determine the color of each pixel in the image
						Color color = null;
						for (int readY = 0; readY < image.getHeight(); readY = readY + getContext().getSamplings(0)) {
							for (int readX = 0; readX < image.getWidth(); readX = readX + getContext().getSamplings(0)) {
								color = pixelReader.getColor(readX, readY);
								dataInput.add(getInstance().compute(null, color.getOpacity()));
							}
						}
						

				}
			}
		}
		
		DataSeries.getInstance().addTests(dataInput);
		
				
	}
	
	private static void processTest(HSSFRow row, int valuesSize) {
		
		List<Double> dataInput = new ArrayList<Double>(getContext().getNodeSumByLayerAndKind(0, "INPUT"));
		for (int indCol = 1; indCol <= valuesSize; indCol++) {
			HSSFCell cell = (HSSFCell) row.getCell(indCol);
			if (cell.getCellType() == HSSFCell.CELL_TYPE_NUMERIC || cell.getCellType() == HSSFCell.CELL_TYPE_BLANK || cell.getCellType() == HSSFCell.CELL_TYPE_FORMULA) {
				double value = cell.getNumericCellValue();
				if (getContext().getKind(cell.getColumnIndex() - 1).indexOf("INPUT") != -1) {
					dataInput.add(getInstance().compute(getContext().getFilter(cell.getColumnIndex() - 1), value));
				} 
			}
		}

		DataSeries.getInstance().addTests(dataInput);
		
	}

	private static void processLabel(Iterator cells, int size) {
		
		getContext().initLabels(size);
		
		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;

			getContext().addLabel(cell.getStringCellValue().toUpperCase(), cell.getColumnIndex() - 1);
		}
	}
	
	private static void processSampling(Iterator cells, int valuesSize) {
		
		getContext().initSampling(valuesSize);
		
		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;

			getContext().addSample((int) cell.getNumericCellValue(), cell.getColumnIndex() - 1);
		}
	}
	
	private static void processAreaScale(Iterator cells, int valuesSize) {
		
		getContext().initScale(valuesSize);
		
		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;

			getContext().addScale((int) cell.getNumericCellValue(), cell.getColumnIndex() - 1);
		}
	}
	

	private static void createNetwork(ITester tester, Sheet sheet, int rowDataIdx) {

		tester.setTrainingVectorNumber(sheet.getLastRowNum() - rowDataIdx + 1);

		// tester.createNetwork("NN-" + sheetName + "-" + f.format(new Date()));
		tester.createXLSNetwork(f.format(new Date()) + " " + sheet.getSheetName(), getContext());
		tester.getNetwork().finalizeConnections();

	}

	private static void processLink(Iterator cells, int size) {
		Integer idxSource = null;
		Integer idxTarget = null;
		
		getContext().initLinks(size);
		
		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			
			if (cell.getStringCellValue().toUpperCase().equals("SOURCE")) {
				idxSource = cell.getColumnIndex();
			} else if (cell.getStringCellValue().toUpperCase().equals("TARGET")) {
				idxTarget = cell.getColumnIndex();
			} else if (cell.getStringCellValue().toUpperCase().equals("SELF")) {
				idxSource = cell.getColumnIndex();
				idxTarget = idxSource;
			}
		}
		if (idxSource != null && idxTarget != null)
			getContext().addLink(idxSource, idxTarget);

	}
	
	private static void processLinkage(Iterator cells, int size) {
		
		getContext().initLinkages(size);
		
		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			getContext().addLinkage(cell.getStringCellValue().toUpperCase(), cell.getColumnIndex() - 1);
		}

	}
	
	private static void processLinkageBetweenAreas(Iterator cells, int size) {
		
		getContext().initLinkageBetweenAreas(size);
		
		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			getContext().addLinkageBetweenAreas(cell.getStringCellValue().toUpperCase(), cell.getColumnIndex() - 1);
		}

	}
	
	private static void processLinkageTargetedArea(Iterator cells, int size) {
		
		getContext().initLinkageTargetedArea(size);
		
		String[] areaIds = null;
		Integer[] areaIdsInteger = null;
		
		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			
			areaIds = cell.getStringCellValue().split(";");
			
			areaIdsInteger = StreamUtils.convertArray(areaIds, Integer::parseInt, Integer[]::new);
			
			getContext().addLinkageTargetedArea(areaIdsInteger, cell.getColumnIndex() - 1);
		}

	}
	
	
	private static void processLinkageOptParams(Iterator cells, int size) {
		
		getContext().initLinkageOptParams(size);
		
		String[] params = null;
		Double[] paramsDouble = null;
		
		while (cells.hasNext()) {
			
			HSSFCell cell = (HSSFCell) cells.next();
			
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			
			params = cell.getStringCellValue().split(";");
			
			paramsDouble = StreamUtils.convertArray(params, Double::parseDouble, Double[]::new);
			getContext().addLinkageOptParams(paramsDouble, cell.getColumnIndex() - 1);
		}

	}
	
	
	private static void processLinkageWeightModifiable(Iterator cells, int size) {
		
		getContext().initLinkageWeightModifiables(size);
		
		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			getContext().addLinkageWeightModifiable(EBoolean.valueOf(cell.getStringCellValue().toUpperCase()), cell.getColumnIndex() - 1);
		}

	}

	private static void processNodeRecurrent(Iterator cells, int size) {
		
		
		getContext().initNodeRecurrents(size);


		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
				
			getContext().addNodeRecurrent("RECURRENT".equalsIgnoreCase(cell.getStringCellValue().toUpperCase()), cell.getColumnIndex() - 1);
		}

	}

	private static void processNodeActivation(Iterator cells, int size) {
		
		getContext().initNodeActivations(size);
		

		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			getContext().addNodeActivation(cell.getStringCellValue().toUpperCase(), cell.getColumnIndex() - 1);
		}

	}

	private static void processNodeType(Iterator cells, int size) {
		
		getContext().initNodeTypes(size);


		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			getContext().addNodeType(cell.getStringCellValue().toUpperCase(), cell.getColumnIndex() - 1);
		}

	}

	private static void processNodeCount(Iterator cells, int size) {
		
		getContext().initNodes(size);


		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			getContext().addNode((int) cell.getNumericCellValue(), cell.getColumnIndex() - 1);
		}

	}

	private static void processNodeBiasWeight(Iterator cells, int size){
		
		getContext().initNodeBiasWeight(size);
		
		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			getContext().addNodeBiasWeight((double) cell.getNumericCellValue(), cell.getColumnIndex() - 1);
		}
	}
	
	private static void processAreaImage(Iterator cells, int size) {

		getContext().initAreasImage(size);

		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			getContext().addAreaImage(EBoolean.valueOf(cell.getStringCellValue().toUpperCase()), cell.getColumnIndex() - 1);
		}

	}
	
	private static void processAreaType(Iterator cells, int size) {

		getContext().initAreasType(size);

		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			getContext().addAreaType(cell.getStringCellValue().toUpperCase(), cell.getColumnIndex() - 1);
		}

	}
	
	private static void processArea(Iterator cells, int size) {

		getContext().initAreas(size);

		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			getContext().addArea((int) cell.getNumericCellValue(), cell.getColumnIndex() - 1);
		}

	}

	private static void processLayer(Iterator cells, int size) {

		getContext().initLayers(size);

		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			getContext().addLayer((int) cell.getNumericCellValue(), cell.getColumnIndex() - 1);
		}

	}
	
	
	private static void processNetworkType(Iterator cells, int size) {

		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			getContext().addNetworkType(cell.getStringCellValue().toUpperCase());
		}
	}

	private static void processKind(Iterator cells, int size) {

		getContext().initKinds(size);

		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			getContext().addKind(cell.getStringCellValue().toUpperCase(), cell.getColumnIndex() - 1);
		}
	}

	private static void processFilter(Iterator cells, int size) {
		
		getContext().initFilters(size);

		while (cells.hasNext()) {
			HSSFCell cell = (HSSFCell) cells.next();
			if(HSSFCell.CELL_TYPE_BLANK == cell.getCellType())
				continue;
			if(!"".equals(cell.getStringCellValue().trim()))
				getContext().addFilter(cell.getStringCellValue().toUpperCase(), cell.getColumnIndex() - 1);
		}
	}

	private static void processData(HSSFRow row, int size) {

		List<Double> dataInput = new ArrayList<Double>(getContext().getNodeSumByLayerAndKind(0, "INPUT"));
		List<Double> dataIdeal = new ArrayList<Double>(getContext().getNodeSumByKind("OUTPUT"));
		// while(cells.hasNext()){
		for (int indCol = 1; indCol <= size; indCol++) {
			
			HSSFCell cell = (HSSFCell) row.getCell(indCol);
			if (cell.getCellType() == HSSFCell.CELL_TYPE_NUMERIC  || cell.getCellType() == HSSFCell.CELL_TYPE_FORMULA) {
				
				double value = cell.getNumericCellValue();
				
				if (getContext().getKind(cell.getColumnIndex() - 1).indexOf("INPUT") != -1) {
					dataInput.add(getInstance().compute(getContext().getFilter(cell.getColumnIndex() - 1), value));
				} else if (getContext().getKind(cell.getColumnIndex() - 1).indexOf("OUTPUT") != -1) {
					dataIdeal.add(getInstance().compute(getContext().getFilter(cell.getColumnIndex() - 1), value));
				}
			}
		}

		DataSeries.getInstance().addINPUTS(dataInput);
		DataSeries.getInstance().addIDEALS(dataIdeal);
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public ESamples getSample() {
		return sample;
	}

	public void setSample(ESamples sample) {
		this.sample = sample;
	}

	public int getFileSheetIdx() {
		return fileSheetIdx;
	}

	public void setFileSheetIdx(int fileSheetIdx) {
		this.fileSheetIdx = fileSheetIdx;
	}

}
package RN.dataset;

/**
 * @author Eric Marchand
 *
 */
public class OutputData {

	public Double[] output;
	
	public OutputData(Double[] output){
		this.output = output;
	}

	public Double[] getOutput() {
		return output;
	}
	
	public Double getOutput(int ind) {
		return Double.valueOf(output[ind]);
	}
	
	public void setOutput(Double[] output) {
		this.output = output;
	}
	
	public String toString(){
		String result = "";
		int idx = 0;
		for(Double val : output){
			result += "[" + idx++ + "] " + val + "    ";
		}
		return result;
	}

	
	
}
package RN.dataset;

import java.util.AbstractList;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.RandomAccess;

/**
 * @author Eric Marchand
 *
 */
public class OutputDataList <E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable{

	private List<Double[]> outputs; 
	
	public OutputDataList(Double[][] outputs){
		this.outputs = Arrays.asList(outputs);
	}
	
	public OutputDataList(){
		this.outputs = new ArrayList<Double[]>();
	}

	public void addData(Double[] value){
		outputs.add(value);
	}


	public E get(int index){
		return (E) new OutputData(outputs.get(index));
	}

	@Override
	public int size() {
		return outputs.size();
	}

	public void clear() {
		outputs.clear();
	}
	
}
package RN;

/**
 * @author Eric Marchand
 * 
 */
public enum EAreaType {
	
	INLINE("RN.Area"), SQUARE("RN.AreaSquare");
	
	String classPath = null;
	
	EAreaType(String classPath){
		this.classPath = classPath;
	}

	public String getClassPath() {
		return classPath;
	}

	public void setClassPath(String classPath) {
		this.classPath = classPath;
	}

}
package RN;

/**
 * @author Eric Marchand
 * 
 */
public enum EBoolean {
	
	YES(Boolean.TRUE),
	NO(Boolean.FALSE);
	
	private Boolean value = null;
	
	EBoolean(boolean value){
		this.value = value;
	}

	public Boolean getValue() {
		return value;
	}

	public void setValue(Boolean value) {
		this.value = value;
	}
	
	

}
package RN;

/**
 * @author Eric Marchand
 * 
 */
public enum ENetworkImplementation {
	
	LINKED("Link objects' are shared between nodes."), UNLINKED("Computational is done without link object.");
	
	String comment = null;
	ENetworkImplementation(String comment){
		this.comment = comment;
	}

}
package RN.fxml.controllers;

import java.io.IOException;
import java.net.URL;
import java.util.ResourceBundle;

import javafx.fxml.FXML;
import javafx.fxml.Initializable;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import RN.TestNetwork;
import RN.algotrainings.LSTMTrainer;

public class NN implements Initializable {

	@FXML
	public static TextField valinp0;
	public static TextField valinp1;
	public static TextField valinp0out;
	public static TextField valinp1out;
	public static TextField valhid0inp;
	public static TextField valhid1inp;
	public static TextField valhid2inp;
	public static TextField valhid0out;
	public static TextField valhid1out;
	public static TextField valhid2out;
	public static TextField valout0inp;
	public static TextField valout0out;
	public static TextField errhid0;
	public static TextField errhid1;
	public static TextField errhid2;
	public static TextField errout0;
	public static TextField validealout0;
	public static TextField valaggout0;
	public static TextField valagghid0;
	public static TextField valagghid1;
	public static TextField valagghid2;
	public static Label whid0inp0;
	public static Label whid0inp1;
	public static Label whid1inp0;
	public static Label whid1inp1;
	public static Label whid2inp0;
	public static Label whid2inp1;	
	public static Label wbiashid0;	
	public static Label wbiashid1;	
	public static Label wbiashid2;	
	public static Label wbiasout0;	
	public static Label wout0hid0;	
	public static Label wout0hid1;	
	public static Label wout0hid2;	
	
	
	
	@FXML
	@Override
	public void initialize(URL arg0, ResourceBundle arg1) {
		
	}
	
	@FXML
	public static void show(){
		System.out.println("clicked");
		TestNetwork.getInstance().getNetwork().show();

	}
	
	public static void selectTrainingSet(){
		System.out.println("selectTrainingSet clicked");
	}
	
	public static void nextTrainInputValues(){
		
		LSTMTrainer.getInstance().nextTrainInputValues();

		System.out.println("nextTrainInputValues clicked");
		TestNetwork.getInstance().getNetwork().show();
	}
	
	
	public void feedForward() throws Exception{
		
		LSTMTrainer.getInstance().feedForward();
		System.out.println("feedForward clicked");
		TestNetwork.getInstance().getNetwork().show();
	}
	
	public void computeDeltaWeights() throws Exception{
		
		LSTMTrainer.getInstance().computeDeltaWeights();
		System.out.println("computeDeltaWeights clicked");
		TestNetwork.getInstance().getNetwork().show();
	}
	
	public void updateAllWeights() throws Exception {
		
		LSTMTrainer.getInstance().updateAllWeights();
		System.out.println("updateAllWeights clicked");
		TestNetwork.getInstance().getNetwork().show();
	}
	
	
	public void doBatch() throws Exception{
//		selectTrainingSet();
//		for(int ind=1; ind <= SimpleTraining.getInstance().getInputDataSet().size(); ind++){
			nextTrainInputValues();
			feedForward();
			computeDeltaWeights();
//		}
//		updateAllWeights();
	}
	
	public void doUpdateAfterEachTrainings() throws Exception{
//		selectTrainingSet();
//		for(int ind=1; ind <= SimpleTraining.getInstance().getInputDataSet().size(); ind++){
			nextTrainInputValues();
			feedForward();
			computeDeltaWeights();
			updateAllWeights();
//		}
		
	}
	
	public void initWeights(){
		TestNetwork.getInstance().initWeights(-1.0D, 1.0D);
		System.out.println("initWeights clicked");
		TestNetwork.getInstance().getNetwork().show();
	}
	
	
	


}
package RN.genetic.alteration;



/**
 * @author Eric Marchand
 *
 */
public abstract class AbstractAlterationDecorator extends Alteration implements IAlteration{



	protected Alteration decoratedAlteration = null;
	
	
	public abstract void beforeProcess();
	
	@Override
	public void apply(){
		
		beforeProcess();
		
		if(decoratedAlteration != null)
			decoratedAlteration.apply();
		
		process();
		
		afterProcess();
		
		geneticCodeAlteration();
		
	}
	
	public abstract void afterProcess();

	public abstract String geneticCodeAlteration();
	
}
package RN.genetic.alteration;

import RN.INetwork;
import RN.algotrainings.ITrainer;

/**
 * @author Eric Marchand
 *
 */
public class Alteration {

	protected static INetwork network = null;
	protected static ITrainer trainer = null;
	
	public Alteration(){
	}
	
	public Alteration(INetwork network, ITrainer trainer){
		Alteration.network = network;
		Alteration.trainer = trainer;
	}
	
	
	public void process(){
		System.out.println("Alteration process");
	}
	

	public void apply(){
		process();
	}
	
}
package RN.genetic.alteration;

import RN.INetwork;
import RN.Network;
import RN.algotrainings.BackPropagationTrainer;
import RN.algotrainings.ITrainer;

/**
 * @author Eric Marchand
 *
 */
public class AlterationFactory {

	public static Alteration create(INetwork network, ITrainer trainer, EAlteration eAlteration){
		
		Alteration alteration = new Alteration(network, trainer);
//		Strategy strategy = new WeightUpdateStrategy();
//		strategy = new TestStrategy(strategy);
		
		if(eAlteration == EAlteration.GROWING_HIDDENS){
			alteration = new GrowingHiddensAlteration();
		}else if(eAlteration == EAlteration.RAND_LEARNING_RATE){
			alteration = new LearningRateAlteration();
		}else if(eAlteration == EAlteration.RAND_MOMENTUM){
			alteration = new MomentumAlteration();
		}else if(eAlteration == EAlteration.RECURRENCY_ADDING){
			alteration = new RecurrentAlteration();
		}
		
		return alteration;
	}
	
	public static void main(String[] args){
		create(Network.getInstance(), new BackPropagationTrainer(), EAlteration.GROWING_HIDDENS).apply();
	}
	
}
package RN.genetic.alteration;

/**
 * @author Eric Marchand
 *
 */
public enum EAlteration {

	GROWING_HIDDENS, RAND_LEARNING_RATE, RAND_MOMENTUM, RECURRENCY_ADDING;
	
}
package RN.genetic.alteration;

import RN.ILayer;
import RN.TestNetwork;
import RN.links.Link;
import RN.nodes.INode;
import RN.nodes.Node;

/**
 * @author Eric Marchand
 *
 */
public class GrowingHiddensAlteration extends AbstractAlterationDecorator implements IAlteration{

	private String geneticCodeAlteration = "";
	
	public GrowingHiddensAlteration(Alteration alteration) {
		this.decoratedAlteration = alteration;
	}

	public GrowingHiddensAlteration() {
	}

	@Override
	public void beforeProcess() {
		
	}

	@Override
	public void process() {
		
		ILayer subLayer = network.getFirstLayer();
		ILayer growingLayer = network.getLayer(subLayer.getLayerId() + 1);
		ILayer nextLayer = network.getLayer(growingLayer.getLayerId() + 1);
		
		Node newNode = new Node();
		newNode.createBias();
		growingLayer.getArea(growingLayer.getAreaCount() - 1).addNode(newNode);
		
		if(network.getLayers().size() > 3){
			ILayer secondSubLayer = growingLayer;
			ILayer secondGrowingLayer = network.getLayer(secondSubLayer.getLayerId() + 2);
			ILayer secondNextLayer = network.getLayer(secondGrowingLayer.getLayerId() + 1);
			
			Node secondNewNode = new Node();
			secondNewNode.createBias();
			secondGrowingLayer.getArea(secondGrowingLayer.getAreaCount() - 1).addNode(secondNewNode);
			
			// we link after adding nodes
			crossLinkage(secondNewNode, secondSubLayer, secondGrowingLayer, secondNextLayer);
			
			System.out.println("Alteration for " + network + " : growing node layer num : " + secondGrowingLayer.getLayerId());
			geneticCodeAlteration += "+N(l" + secondGrowingLayer.getLayerId() + ").";
		}
		
		// we link after adding nodes
		crossLinkage(newNode, subLayer, growingLayer, nextLayer);
		
		System.out.println("growing node layer num : " + growingLayer.getLayerId());
		geneticCodeAlteration += "+N(l" + growingLayer.getLayerId() + ").";
		
	}

	private void crossLinkage(INode newNode, ILayer subLayer, ILayer growingLayer, ILayer nextLayer) {
		TestNetwork tester = TestNetwork.getInstance();
		
		newNode.getArea().getLinkage().sublayerFanOutLinkage(newNode, subLayer);
		
		newNode.getArea().getLinkage().nextLayerFanOutLinkage(newNode, nextLayer);
		
		for (Link link : newNode.getInputs())
			link.initWeight(tester.getInitWeightRange(0), tester.getInitWeightRange(1));
		
		if (growingLayer.isDropOutLayer()) {
			newNode.setDropOutActive(true);
		}
	}
	
	
	@Override
	public void afterProcess() {
		
	}
	
	@Override
	public String geneticCodeAlteration(){
		
		network.setName(network.getName() + geneticCodeAlteration);
		
		return geneticCodeAlteration;
		
	}

}
package RN.genetic.alteration;

/**
 * @author Eric Marchand
 *
 */
public interface IAlteration {

	void beforeProcess();

	void afterProcess();
	
	void apply();
	
}
package RN.genetic.alteration;

import RN.genetic.Genetic;
import RN.utils.StatUtils;

/**
 * @author Eric Marchand
 *
 */
public class LearningRateAlteration extends AbstractAlterationDecorator implements IAlteration{

	private String geneticCodeAlteration = "";
	
	public LearningRateAlteration(Alteration alteration) {
		this.decoratedAlteration = alteration;
	}

	public LearningRateAlteration() {
	}

	@Override
	public void beforeProcess() {
		
	}

	@Override
	public void process() {
		System.out.print("learning rate was : " + trainer.getLearningRate() );
		trainer.setLearningRate(Math.random());
		System.out.println(" set to  : " + trainer.getLearningRate());
		
		geneticCodeAlteration = "l%(" + StatUtils.format(trainer.getLearningRate(), "#.#") + ")" + Genetic.CODE_SEPARATOR;
		
	}

	
	
	@Override
	public void afterProcess() {
		
	}
	
	@Override
	public String geneticCodeAlteration(){
		
		network.setName(network.getName() + geneticCodeAlteration);
		
		return geneticCodeAlteration;
		
	}

}
package RN.genetic.alteration;

import RN.genetic.Genetic;
import RN.utils.StatUtils;

/**
 * @author Eric Marchand
 *
 */
public class MomentumAlteration extends AbstractAlterationDecorator implements IAlteration{

	private String geneticCodeAlteration = "";
	
	public MomentumAlteration(Alteration alteration) {
		this.decoratedAlteration = alteration;
	}

	public MomentumAlteration() {
	}

	@Override
	public void beforeProcess() {
		
	}

	@Override
	public void process() {
		System.out.print("momentum was : " +  trainer.getAlphaDeltaWeight());
		trainer.setAlphaDeltaWeight(Math.random());
		System.out.println(" set to  : " + trainer.getAlphaDeltaWeight());
		geneticCodeAlteration = "m%(" + StatUtils.format(trainer.getAlphaDeltaWeight(), "#.#") + ")" + Genetic.CODE_SEPARATOR;
	}

	@Override
	public void afterProcess() {
		
	}
	
	@Override
	public String geneticCodeAlteration(){
		
		network.setName(network.getName() + geneticCodeAlteration);
		
		return geneticCodeAlteration;
		
	}

}
package RN.genetic.alteration;

import RN.IArea;
import RN.ILayer;
import RN.genetic.Genetic;
import RN.links.ELinkType;
import RN.links.Link;
import RN.nodes.ENodeType;
import RN.nodes.INode;
import RN.nodes.Node;
import RN.nodes.RecurrentNode;
import RN.utils.StatUtils;

/**
 * @author Eric Marchand
 *
 */
public class RecurrentAlteration extends AbstractAlterationDecorator implements IAlteration {

	
	private String geneticCodeAlteration = "";
	
	public RecurrentAlteration(Alteration alteration) {
		this.decoratedAlteration = alteration;
	}

	public RecurrentAlteration() {
	}

	@Override
	public void beforeProcess() {
		int count = 0;
		ILayer firstLayer = network.getFirstLayer();
		for (ILayer layer : network.getLayers()) {
			if (layer != firstLayer) {
					Link link = null;
					for (INode sourceNode : layer.getLayerNodes()) {
						if (StatUtils.randomize(10) == 1) {
							Node recurrent = new RecurrentNode(sourceNode);
							firstLayer.getArea(0).addNode(recurrent);
							link = Link.getInstance(ELinkType.REGULAR, false);
							link.setSourceNode(sourceNode);
							link.setWeightModifiable(false);
							recurrent.addInput(link);
							count++;
							System.out.println("recurrent node added. ");
						}
					}
				}
			}
		if(count > 0)
			geneticCodeAlteration += "+RN(" + count + ")" + Genetic.CODE_SEPARATOR;
	}

	@Override
	public void process() {
		int count = 0;
		for (ILayer layer : network.getLayers()) {
			for (IArea area : layer.getAreas()) {
				if (StatUtils.randomize(5) == 1) {
					System.out.println("recurrent nodes (if exists) lateral-linked. ");
					INode lastRecurrent = null;
					for (INode node : area.getNodes()) {
						if (node.getNodeType() == ENodeType.RECURRENT) {
							if (lastRecurrent != null){
								lastRecurrent.doubleLink(node, ELinkType.RECURRENT_LATERAL_LINK);
								count++;
							}
						}
					}
				}
			}
		}
		
		if(count > 0)
			geneticCodeAlteration += "-R-(" + count + ")" + Genetic.CODE_SEPARATOR;
	}

	@Override
	public void afterProcess() {


	}
	
	@Override
	public String geneticCodeAlteration(){
		
		network.setName(network.getName() + geneticCodeAlteration);
		
		return geneticCodeAlteration;
		
	}

}
package RN.genetic;

import java.util.Arrays;
import java.util.Comparator;

import RN.INetwork;
import RN.ITester;
import RN.TestNetwork;
import RN.algotrainings.BackPropagationTrainer;
import RN.algotrainings.ITrainer;
import RN.dataset.inputsamples.InputSample;
import RN.genetic.alteration.AlterationFactory;
import RN.genetic.alteration.EAlteration;
import RN.utils.StatUtils;

/**
 * @author Eric Marchand
 *
 */
public class Generation {

	
	public static ITester tester = null;
	
	private INetwork[] generation;
	private ITrainer[] trainers;
	private static final int GENERATION_SIZE = 20;
	private static int generationCount = 0;
	
	private INetwork winner = null;
	

	public INetwork getWinner() {
		return winner;
	}


	public void setWinner(INetwork winner) {
		this.winner = winner;
	}


	public Generation(INetwork[] generation, ITrainer[] trainers) {
		this.generation = generation;
		this.trainers = trainers;
	}
	
	
	public void replace(INetwork[] futureGeneration){
		this.generation = futureGeneration;
	}
	
	/**
	 * At the beginning, God created the heaven and the earth...
	 */
	public static void createEnvironnement(){
		tester = TestNetwork.getInstance();
//		ViewerFX.setTrainer(trainer);
//		ViewerFX.setTester(tester);
//		ViewerFX.startViewerFX();
	}
	
	/**
	 * Adam and Eve, equals but sexually different...
	 * 
	 * @return
	 */
	public static Generation initialSeed(){
		
		try {
			InputSample.setFileSample(tester, tester.getFilePath(), 1);
		} catch (Exception e) {
			e.printStackTrace();
		}
		
		INetwork god = tester.getNetwork();
		
		Generation initialGeneration = new Generation(new INetwork[GENERATION_SIZE], new ITrainer[GENERATION_SIZE]);
		
		initialGeneration.generation[0] = god.deepCopy(generationCount);
		initialGeneration.trainers[0] = new BackPropagationTrainer();
		
		for(int idx=1; idx < GENERATION_SIZE; idx++){
			initialGeneration.trainers[idx] = new BackPropagationTrainer();
			initialGeneration.generation[idx] = codeAlteration(god.deepCopy(generationCount), initialGeneration.trainers[idx]);
		}
		
		generationCount++;
		
		return initialGeneration;
		
	}
	
	public void life() {
		
		int maxTrainingCycles = 100;
		
		for(int idx=0; idx < generation.length; idx++){
			
			tester.setNetwork(generation[idx]);
			trainers[idx].setMaxTrainingCycles(maxTrainingCycles);
			
			try {
				trainers[idx].launchTrain();
				System.out.println("life " + idx + " of " + generation.length + " complete.");
			} catch (Exception e) {
				// dead during training, god bless you !
				generation[idx] = null;
				trainers[idx] = null;
				System.out.println("dead during training, god bless you !");
			}
			
		}
		
	}
	
	public void naturalSelection(){
		
		Comparator<INetwork> sortByError = new SortByBackPropagationError();
		Arrays.sort(generation, sortByError);
		setWinner(generation[0]);
		
		int i = 1;
		for(INetwork net : generation){
			System.out.print("Results for natural selection  >>     "+ "   (error : " + StatUtils.format(net.getAbsoluteError(), "###.#####")+")         " + ( i == 0 ? "WINNER" : i) + " : " + net );
			System.out.println("       =  " + net.geneticCodec() );
			i++;
		}
		
		
	}
	
	public INetwork[] seed(){
		
		INetwork winner = getWinner();
		ITrainer trainer = null;
		System.out.println("START Replications of the winner. [x" + GENERATION_SIZE + "]");
		INetwork[] futureGeneration = new INetwork[GENERATION_SIZE];
		if(!winner.getName().endsWith(Genetic.GENE_SEPARATOR))
			winner.appendName(Genetic.GENE_SEPARATOR);
		futureGeneration[0] = winner.deepCopy(generationCount);
		trainers[0] = new BackPropagationTrainer();
		for(int idx=1; idx < GENERATION_SIZE; idx++){
			System.out.println("Replication with alteration of " + winner + "]");
			trainer = new BackPropagationTrainer();
			trainers[idx] = trainer;
			futureGeneration[idx] = codeAlteration(winner.deepCopy(generationCount), trainer);
			
		}
		generationCount++;
		
		System.out.println("END of Replications---------------- ");
		return futureGeneration;
		
	}
	
	public static INetwork codeAlteration(INetwork network, ITrainer trainer){
		// Math random EAlteration
		for(int nbAlt = 0; nbAlt < StatUtils.randomize(50); nbAlt++){
			System.out.println("Alteration for " + network + " :");
			int altKind = StatUtils.randomize(3);
			switch(altKind){
				case 0 : 
					System.out.println("growing hiddens alteration");
					AlterationFactory.create(network, trainer, EAlteration.GROWING_HIDDENS).apply();
					break;
				case 1 : 
					System.out.println("learning rate alteration");
					AlterationFactory.create(network, trainer, EAlteration.RAND_LEARNING_RATE).apply();
					break;
				case 2 : 
					System.out.println("momentum alteration");
					AlterationFactory.create(network, trainer, EAlteration.RAND_MOMENTUM).apply();
					break;
				case 3 : 
					System.out.println("recurrency alteration");
					AlterationFactory.create(network, trainer, EAlteration.RECURRENCY_ADDING).apply();
					break;					
				default :
					System.out.println("no alteration");
			}
		}
		
		return network;
	}
	
	
	
	public static void main(String[] args){
		for(int nbAlt = 0; nbAlt < StatUtils.randomize(100); nbAlt++){
			System.out.println("nbAlt =" + nbAlt);
			int altKind = StatUtils.randomize(1);
			System.out.println("kind : " + altKind);
			switch(altKind){
				case 0 : 
					System.out.println("growing hiddens alteration");
					break;
				default :
					System.out.println("no alteration");
			}
		}
	}
	
}
package RN.genetic;

import RN.INetwork;


/**
 * @author Eric Marchand
 *
 */
public class Genetic {

	// nb of generations
	private final static int MAX_LIFE_CYCLE = 4;
	
	public final static String CODE_SEPARATOR = ".";
	public final static String GENE_SEPARATOR = "||";
	
	
	public static INetwork process(){
		
		// At the beginning...
		Generation.createEnvironnement();
		
		// Adam and Eve...
		Generation generation = Generation.initialSeed();
		
		int lifeCycle = 0;
		
		do{
			// run network over samples
			generation.life();
			
			// choose the best network
			generation.naturalSelection();
			
			// generate networks with a new code alteration
			if(lifeCycle + 1 < MAX_LIFE_CYCLE)
				generation.replace(generation.seed());
		
		}while(++lifeCycle < MAX_LIFE_CYCLE);
		
		return generation.getWinner();
		
	}
	
	public static void main(String[] args){
		System.out.println(Genetic.process());
	}
	
	
}
package RN.genetic;

import java.util.Comparator;

import RN.INetwork;

/**
 * @author Eric Marchand
 *
 */
public class SortByBackPropagationError implements Comparator<INetwork> {

	@Override
	public int compare(INetwork o1, INetwork o2) {
		
		if(o1.getAbsoluteError() - o2.getAbsoluteError() > 0)
			return 1;
		else if( o1.getAbsoluteError() - o2.getAbsoluteError() == 0)
			return 0;
		else
			return -1;
	}

}
package RN;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;

import RN.dataset.InputData;
import RN.dataset.OutputData;
import RN.nodes.ENodeType;
import javafx.collections.FXCollections;
import javafx.scene.chart.LineChart;
import javafx.scene.chart.XYChart;

public class GlobalNetwork {
	
	private static GlobalNetwork instance = null;
	
	private static List<INetwork> networks = new ArrayList<INetwork>();

	public List<LineChart.Series<Number, Number>> seriesFirstNETInputs = new ArrayList<LineChart.Series<Number, Number>>();
	public List<LineChart.Series<Number, Number>> seriesFirstNETOutputs = new ArrayList<LineChart.Series<Number, Number>>();
	public List<LineChart.Series<Number, Number>> seriesLastNETInputs = new ArrayList<LineChart.Series<Number, Number>>();
	public List<LineChart.Series<Number, Number>> seriesLastNETOutputs = new ArrayList<LineChart.Series<Number, Number>>();
	public LineChart<Number, Number> sc = ViewerFX.lineChart;
	
	public static GlobalNetwork getInstance() {
		if (instance == null) {
			instance = new GlobalNetwork();
		}

		return instance;
	}
	

	public void launchRealCompute() throws Exception {

		
		DataSeries dataSeries = DataSeries.getInstance();
		int idxNetwork = 0;
		INetwork network = get(idxNetwork);

		if (network != null && !dataSeries.getInputDataSet().isEmpty()) {

			OutputData output = null;

			if (sc.getData() == null)
				sc.setData(FXCollections.<XYChart.Series<Number, Number>> observableArrayList());

			LineChart.Series<Number, Number> series = null;
			seriesFirstNETInputs = new ArrayList<LineChart.Series<Number, Number>>();
			seriesFirstNETOutputs = new ArrayList<LineChart.Series<Number, Number>>();
			seriesLastNETInputs = new ArrayList<LineChart.Series<Number, Number>>();
			seriesLastNETOutputs = new ArrayList<LineChart.Series<Number, Number>>();

			for (int idx = 0; idx < network.getFirstLayer().getLayerNodes(ENodeType.REGULAR).size(); idx++) {
				series = new LineChart.Series<Number, Number>();
				series.setName("Run in" + (sc.getData().size() + 1));
				seriesFirstNETInputs.add(series);
			}

			for (int idx = 0; idx < network.getLastLayer().getNodeCount(); idx++) {
				series = new LineChart.Series<Number, Number>();
				series.setName("Run out[" + idx + "]" + (sc.getData().size() + 1));
				seriesFirstNETOutputs.add(series);
			}
			


			int runCycle = 0;
			ListIterator computeItr = dataSeries.getInputDataSet().listIterator();
			for (InputData entry : dataSeries.getInputDataSet()) {
				int idx = 0;

				for (LineChart.Series<Number, Number> seriesIn : seriesFirstNETInputs) {
					seriesIn.getData().add(new LineChart.Data<Number, Number>(runCycle, entry.getInput(idx++)));
				}
				
				try {
					output = network.compute(computeItr);
				} catch (Exception e) {
					e.printStackTrace();
				}
				
				idx = 0;
				for (LineChart.Series<Number, Number> seriesOut : seriesFirstNETOutputs) {
					seriesOut.getData().add(new LineChart.Data<Number, Number>(runCycle, output.getOutput(idx++)));
				}
				
				while(++idxNetwork < size() - 1){
					network = get(idxNetwork);
					output = network.propagation(false);
				}
				
				if(seriesLastNETInputs.size() == 0)
					for (idx = 0; idx < network.getFirstLayer().getLayerNodes(ENodeType.REGULAR).size(); idx++) {
						series = new LineChart.Series<Number, Number>();
						series.setName("Run in" + (sc.getData().size() + 1));
						seriesLastNETInputs.add(series);
					}
				
				idx = 0;
				for (LineChart.Series<Number, Number> seriesIn : seriesLastNETInputs) {
					seriesIn.getData().add(new LineChart.Data<Number, Number>(runCycle, entry.getInput(idx++)));
				}

				if(seriesLastNETOutputs.size() == 0)
				for (idx = 0; idx < network.getLastLayer().getNodeCount(); idx++) {
					series = new LineChart.Series<Number, Number>();
					series.setName("Run out[" + idx + "]" + (sc.getData().size() + 1));
					seriesLastNETOutputs.add(series);
				}
				
				idx = 0;
				for (LineChart.Series<Number, Number> seriesOut : seriesLastNETOutputs) {
					seriesOut.getData().add(new LineChart.Data<Number, Number>(runCycle, output.getOutput(idx++)));
				}


				
				if (ViewerFX.showLogs.isSelected()) {
					System.out.print("[  ");
					for (double input : entry.getInput()) {
						System.out.print(input + "  ");
					}
					System.out.print("]");

					for (double out : output.getOutput()) {
						System.out.print(", [actual=" + out);
//						System.out.print(", ideal=" + entry.getIdeal(idx++) + "]");
					}
					System.out.println(" ");
				}

				runCycle++;
				
				
			}
		
		}
	}


	public int size() {
		return networks.size();
	}


	public boolean isEmpty() {
		return networks.isEmpty();
	}


	public boolean contains(Object o) {
		return networks.contains(o);
	}


	public Iterator<INetwork> iterator() {
		return networks.iterator();
	}


	public Object[] toArray() {
		return networks.toArray();
	}


	public <T> T[] toArray(T[] a) {
		return networks.toArray(a);
	}


	public boolean add(INetwork e) {
		return networks.add(e);
	}


	public boolean remove(Object o) {
		return networks.remove(o);
	}


	public boolean containsAll(Collection<?> c) {
		return networks.containsAll(c);
	}


	public boolean addAll(Collection<? extends INetwork> c) {
		return networks.addAll(c);
	}


	public boolean addAll(int index, Collection<? extends INetwork> c) {
		return networks.addAll(index, c);
	}


	public boolean removeAll(Collection<?> c) {
		return networks.removeAll(c);
	}


	public boolean retainAll(Collection<?> c) {
		return networks.retainAll(c);
	}


	public void clear() {
		networks.clear();
	}


	public boolean equals(Object o) {
		return networks.equals(o);
	}


	public int hashCode() {
		return networks.hashCode();
	}


	public INetwork get(int index) {
		return networks.get(index);
	}


	public INetwork set(int index, INetwork element) {
		return networks.set(index, element);
	}


	public void add(int index, INetwork element) {
		networks.add(index, element);
	}


	public INetwork remove(int index) {
		return networks.remove(index);
	}


	public int indexOf(Object o) {
		return networks.indexOf(o);
	}


	public int lastIndexOf(Object o) {
		return networks.lastIndexOf(o);
	}


	public ListIterator<INetwork> listIterator() {
		return networks.listIterator();
	}


	public ListIterator<INetwork> listIterator(int index) {
		return networks.listIterator(index);
	}


	public List<INetwork> subList(int fromIndex, int toIndex) {
		return networks.subList(fromIndex, toIndex);
	}
	
}
package RN;

import java.util.HashMap;
import java.util.Map;
import java.util.function.Predicate;

import RN.links.ELinkType;
import RN.links.Link;
import RN.nodes.INode;
import RN.nodes.Node;
import javafx.event.EventHandler;
import javafx.scene.AmbientLight;
import javafx.scene.PerspectiveCamera;
import javafx.scene.PointLight;
import javafx.scene.Scene;
import javafx.scene.image.Image;
import javafx.scene.input.KeyEvent;
import javafx.scene.input.MouseEvent;
import javafx.scene.paint.Color;
import javafx.scene.paint.PhongMaterial;
import javafx.scene.shape.Box;
import javafx.scene.shape.DrawMode;
import javafx.scene.shape.Line;
import javafx.scene.shape.Sphere;

/**
 * @author Eric Marchand
 * 
 */
public class Graphics3D {

	private static Map<Link, Line> shapeLinks = new HashMap<Link, Line>();
	private static Map<INode, Sphere> shapeNodes = new HashMap<INode, Sphere>();
	
	
	private static PointLight pointLight = new PointLight();
	private static AmbientLight ambient = new AmbientLight();
	private static PhongMaterial material = new PhongMaterial();


	final static Graphics3DXForm world = new Graphics3DXForm();
	final static PerspectiveCamera camera = new PerspectiveCamera(true);
	final static Graphics3DXForm cameraXform = new Graphics3DXForm();
	final static Graphics3DXForm cameraXform2 = new Graphics3DXForm();
	final static Graphics3DXForm cameraXform3 = new Graphics3DXForm();

	private static final double AXIS_LENGTH = 250.0;

	final static Graphics3DXForm axisGroup = new Graphics3DXForm();

	private static final double CAMERA_INITIAL_DISTANCE = -350;
	private static final double CAMERA_INITIAL_X_ANGLE = 0.0;
	private static final double CAMERA_INITIAL_Y_ANGLE = 0.0;
	private static final double CAMERA_NEAR_CLIP = 0.1;
	private static final double CAMERA_FAR_CLIP = 10000.0;

	private static final double CONTROL_MULTIPLIER = 0.1;
	private static final double SHIFT_MULTIPLIER = 10.0;
	private static final double MOUSE_SPEED = 2.5;
	private static final double ROTATION_SPEED = 2.0;
	private static final double TRACK_SPEED = 0.3;
	public static final boolean graphics3DActive = false;

	static double mousePosX;
	static double mousePosY;
	static double mouseOldX;
	static double mouseOldY;
	static double mouseDeltaX;
	static double mouseDeltaY;

	public static void initCameraLightAndAxes() {

		buildCamera();
		buildAxes();

		pointLight.setTranslateX(800);
		pointLight.setTranslateY(100);
		pointLight.setTranslateZ(-1100);
		pointLight.setColor(Color.rgb(255, 255, 255, 0.5D));
		pointLight.setLightOn(false);
		
		ambient.setColor(Color.rgb(0, 255, 0, 1));
		ambient.setLightOn(false);

		
		Image cells = new Image("file:./resources/cells.png", true);
		material.setSelfIlluminationMap(cells);
		material.setDiffuseColor(Color.WHITE);
		//material.setBumpMap(new Image("http://www.inserm.fr/var/inserm/storage/images/mediatheque/infr-grand-public/images/images-de-sciences/inserm_52314neuroneaxone4/325924-1-fre-FR/inserm_52314neuroneaxone4.jpg"));
		//material.setDiffuseMap(new Image("http://www.inserm.fr/var/inserm/storage/images/mediatheque/infr-grand-public/images/images-de-sciences/inserm_52314neuroneaxone4/325924-1-fre-FR/inserm_52314neuroneaxone4.jpg"));
		material.setSpecularMap(cells);
		
		world.getChildren().addAll(pointLight, ambient);

	}

	public static void createLayer(ILayer layer) {

		// Shape3D[] meshView = new Shape3D[] { new Box(60, 300, 100) };
		//
		// for (int i = 0; i < meshView.length; ++i) {
		// meshView[i].setMaterial(material);
		// meshView[i].setDrawMode(DrawMode.LINE);
		// meshView[i].setCullFace(CullFace.NONE);
		// meshView[i].setTranslateX(getLayerXYZ(layer)[0]);
		// meshView[i].setTranslateY(getLayerXYZ(layer)[1]);
		// meshView[i].setTranslateZ(getLayerXYZ(layer)[2]);
		// }
		//
		// world.getChildren().addAll(meshView);

	}

	public static Double[] getLayerXYZ(ILayer layer) {
		if(layer == null)
			return new Double[] { 
					0D, 
					0D,
					0D };
		
		if(layer != null && layer.getLayerId() == null)
			return new Double[] { 
					0D, 
					0D,
					0D };
		
		return new Double[] { (layer.getLayerId() + 1D) * -80D - ((layer.getNetwork().getLayers().size() + 1) * -80D) / 2D,
				0D, 0D };
	}

	public static void createArea(Area area) {

		// Shape3D[] meshView = new Shape3D[] { new Box(50, 50, 50) };
		//
		// for (int i = 0; i < meshView.length; ++i) {
		// meshView[i].setMaterial(material);
		// meshView[i].setDrawMode(DrawMode.LINE);
		// meshView[i].setCullFace(CullFace.NONE);
		// meshView[i].setTranslateX(getAreaXYZ(area)[0]);
		// meshView[i].setTranslateY(getAreaXYZ(area)[1]);
		// meshView[i].setTranslateZ(getAreaXYZ(area)[2]);
		// }
		//
		// graph.getChildren().addAll(meshView);

	}

	public static Double[] getAreaXYZ(IArea area) {
		
		if(area == null)
			return new Double[] { 
					0D, 
					0D,
					0D };
		
		if(area != null && area.getAreaId() == null)
			return new Double[] { 
					0D, 
					0D,
					0D };
		
		return new Double[] { getLayerXYZ(area.getLayer())[0],
				getLayerXYZ(area.getLayer())[1] + area.getAreaId() * 60D + 10D, getLayerXYZ(area.getLayer())[2] };
	}

	public static void createNode(Node node) {

		Sphere sphere =  new Sphere(10D);

		sphere.setMaterial(material);
		sphere.setTranslateX(getNodeXYZ(node)[0]);
		sphere.setTranslateY(getNodeXYZ(node)[1]);
		sphere.setTranslateZ(getNodeXYZ(node)[2]);
		sphere.setDrawMode(DrawMode.FILL);
		//sphere.setCullFace(CullFace.BACK);
		
		shapeNodes.put(node, sphere);
		
		world.getChildren().addAll(sphere);

	}

	public static Double[] getNodeXYZ(INode node) {
		
		if(node == null)
			return new Double[] { 
					0D, 
					0D,
					0D };
		
		if(node != null && node.getNodeId() == null)
			return new Double[] { 
					0D, 
					0D,
					0D };
		
		return new Double[] { 
				getAreaXYZ(node.getArea())[0], 
				getAreaXYZ(node.getArea())[1] + node.getNodeId() * 30D,
				getAreaXYZ(node.getArea())[2] };
	}

	public static void createLink(Link link) {

		Line line = shapeLinks.get(link);
		
		if(line != null){
			
			if(link.getTargetNode() == null && link.getSourceNode() != null){
				line.setStartX(getNodeXYZ(link.getSourceNode())[0]);
				line.setStartY(getNodeXYZ(link.getSourceNode())[1]);
			}
			
			if(link.getTargetNode() != null && link.getSourceNode() == null){
				line.setEndX(getNodeXYZ(link.getTargetNode())[0]);
				line.setEndY(getNodeXYZ(link.getTargetNode())[1]);
			}
			
		} else {
			
			if(link.getType() == ELinkType.SELF_NODE_LINK)
				return;
			
			
			if(link.isBias()){
				line = new Line(getNodeXYZ(link.getTargetNode())[0], getNodeXYZ(link.getTargetNode())[1] + 40D,
						getNodeXYZ(link.getTargetNode())[0], getNodeXYZ(link.getTargetNode())[1]);
				shapeLinks.put(link, line);
			
			}
			
			if(link.getSourceNode() != null && link.getTargetNode() == null){
				line = new Line(getNodeXYZ(link.getSourceNode())[0], getNodeXYZ(link.getSourceNode())[1], getNodeXYZ(link.getSourceNode())[0] - 60D, getNodeXYZ(link.getSourceNode())[1]);
				shapeLinks.put(link, line);
			}
			
			if (link.getSourceNode() == null && link.getTargetNode() != null) {
				line = new Line(getNodeXYZ(link.getTargetNode())[0] + 60D, getNodeXYZ(link.getTargetNode())[1], getNodeXYZ(link.getTargetNode())[0], getNodeXYZ(link.getTargetNode())[1]);
				shapeLinks.put(link, line);
			}
			
			line.setSmooth(true);
			
			world.getChildren().addAll(line);
		}
		
		
//		Graphics3DXForm lineWeight = new Graphics3DXForm();
//		
//		
//		Text textnode = new Text("VALUE");
//		textnode.setFont(Font.font("Verdana", 8));
		//textnode.setFill(Paint.valueOf("BLACK"));
		//t.setRotate(180);
		//textnode.setSmooth(true);
//		textnode.setLayoutX( Math.abs(line.getEndX() - line.getStartX()) / 2D - textnode.getLayoutBounds().getMinX());
//		textnode.setLayoutY( Math.abs(line.getEndY() - line.getStartY()) / 2D - textnode.getLayoutBounds().getMinY());
		
//		lineWeight.getChildren().addAll(line, textnode);
		
		

	}

	public static Double[] getLinkXYZ(Link link) {
		
		if(link == null)
			return new Double[] { 
					0D, 
					0D,
					0D };
		
		return new Double[] { getNodeXYZ(link.getSourceNode())[0], getNodeXYZ(link.getSourceNode())[1],
				getNodeXYZ(link.getSourceNode())[2] };
	}

	public static void buildCamera() {
		world.getChildren().add(cameraXform);
		cameraXform.getChildren().add(cameraXform2);
		cameraXform2.getChildren().add(cameraXform3);
		cameraXform3.getChildren().add(camera);
		cameraXform3.setRotateZ(180.0);
		cameraXform2.setRotateY(180.0);

		camera.setNearClip(CAMERA_NEAR_CLIP);
		camera.setFarClip(CAMERA_FAR_CLIP);
		camera.setTranslateZ(CAMERA_INITIAL_DISTANCE);
		cameraXform.ry.setAngle(CAMERA_INITIAL_Y_ANGLE);
		cameraXform.rx.setAngle(CAMERA_INITIAL_X_ANGLE);
	}

	public static void handleMouse(Scene scene) {

		scene.setOnMousePressed(new EventHandler<MouseEvent>() {
			@Override
			public void handle(MouseEvent me) {
				mousePosX = me.getSceneX();
				mousePosY = me.getSceneY();
				mouseOldX = me.getSceneX();
				mouseOldY = me.getSceneY();
			}
		});
		scene.setOnMouseDragged(new EventHandler<MouseEvent>() {
			@Override
			public void handle(MouseEvent me) {
				mouseOldX = mousePosX;
				mouseOldY = mousePosY;
				mousePosX = me.getSceneX();
				mousePosY = me.getSceneY();
				mouseDeltaX = (mousePosX - mouseOldX);
				mouseDeltaY = (mousePosY - mouseOldY);

				double modifier = 1.0;
				double modifierFactor = 0.1;

				if (me.isControlDown()) {
					modifier = CONTROL_MULTIPLIER;
				}
				if (me.isShiftDown()) {
					modifier = SHIFT_MULTIPLIER;
				}
				if (me.isPrimaryButtonDown()) {
					cameraXform.ry.setAngle(
							cameraXform.ry.getAngle() - mouseDeltaX * modifierFactor * modifier * ROTATION_SPEED); //
					cameraXform.rx.setAngle(
							cameraXform.rx.getAngle() + mouseDeltaY * modifierFactor * modifier * ROTATION_SPEED); // -
				} else if (me.isSecondaryButtonDown()) {
					double z = camera.getTranslateZ();
					double newZ = z + mouseDeltaX * MOUSE_SPEED * modifier;
					camera.setTranslateZ(newZ);
				} else if (me.isMiddleButtonDown()) {
					cameraXform2.t.setX(cameraXform2.t.getX() + mouseDeltaX * MOUSE_SPEED * modifier * TRACK_SPEED); // -
					cameraXform2.t.setY(cameraXform2.t.getY() + mouseDeltaY * MOUSE_SPEED * modifier * TRACK_SPEED); // -
				}
			}
		}); // setOnMouseDragged
	} // handleMouse

	public static void handleKeyboard(Scene scene) {

		scene.setOnKeyPressed(new EventHandler<KeyEvent>() {
			@Override
			public void handle(KeyEvent event) {
				switch (event.getCode()) {
				case C:
					cameraXform2.t.setX(0.0);
					cameraXform2.t.setY(0.0);
					cameraXform.ry.setAngle(CAMERA_INITIAL_Y_ANGLE);
					cameraXform.rx.setAngle(CAMERA_INITIAL_X_ANGLE);
					break;
				case A:
					axisGroup.setVisible(!axisGroup.isVisible());
					break;
				case L:
					pointLight.setLightOn(!pointLight.isLightOn());
					break;
				case M:
					ambient.setLightOn(!ambient.isLightOn());
					break;
				case SPACE:
					scene.setFill(scene.getFill() == Color.BLACK ? Color.WHITE : Color.BLACK);
					break;
				// case V:
				// moleculeGroup.setVisible(!moleculeGroup.isVisible());
				// break;
				default:
					break;
				}
			}
		});
	}

	public static void buildAxes() {

		final PhongMaterial redMaterial = new PhongMaterial();
		redMaterial.setDiffuseColor(Color.DARKRED);
		redMaterial.setSpecularColor(Color.RED);

		final PhongMaterial greenMaterial = new PhongMaterial();
		greenMaterial.setDiffuseColor(Color.DARKGREEN);
		greenMaterial.setSpecularColor(Color.GREEN);

		final PhongMaterial blueMaterial = new PhongMaterial();
		blueMaterial.setDiffuseColor(Color.DARKBLUE);
		blueMaterial.setSpecularColor(Color.BLUE);

		final Box xAxis = new Box(AXIS_LENGTH, 1, 1);
		final Box yAxis = new Box(1, AXIS_LENGTH, 1);
		final Box zAxis = new Box(1, 1, AXIS_LENGTH);

		xAxis.setMaterial(redMaterial);
		yAxis.setMaterial(greenMaterial);
		zAxis.setMaterial(blueMaterial);

		axisGroup.getChildren().addAll(xAxis, yAxis, zAxis);
		axisGroup.setVisible(false);
		
		
		world.getChildren().addAll(axisGroup);
	}

	public static void clearShapes() {
		
		shapeLinks.clear();
		shapeNodes.clear();
		world.getChildren().removeIf(new Predicate<javafx.scene.Node>() {

			@Override
			public boolean test(javafx.scene.Node node) {
				return !(node instanceof javafx.scene.PointLight) && !(node instanceof javafx.scene.AmbientLight) && !(node instanceof RN.Graphics3DXForm);
			}

		});
	}
	
	public static void setWeightOnLink(Link link){
		
		Line line = shapeLinks.get(link);
		if(line == null)
			return;
		
		line.setFill(Color.TRANSPARENT);
		
		if(link.getWeight() < 0D){
			line.setStroke(Color.color(1D, 0D, 0D));
		}else if(link.getWeight() > 0D){
			line.setStroke(Color.color(0D, 1D, 0D));
		}else if(link.getWeight() == 0D)
			line.setStroke(Color.WHITE);
		
		line.setStrokeWidth(Math.abs(link.getWeight() / 4D));
		
	}
	
	public static void setOutputValueOnNode(INode node){
		Sphere sphere = shapeNodes.get(node);
		
		if(sphere != null && Math.abs(node.getComputedOutput()) <= 1D ){
			
			material.setDiffuseColor(Color.rgb((node.getComputedOutput() < 0D ? (int) (-node.getComputedOutput() * 255) : 0), 0, (node.getComputedOutput() > 0D ? (int) (node.getComputedOutput() * 255) : 0)));

			sphere.setMaterial(material);
			sphere.setRadius(10D * Math.abs(node.getComputedOutput()));
		}
	}

}
package RN;

/**
 * @author Eric Marchand
 * 
 */
import javafx.scene.Group;
import javafx.scene.transform.Rotate;
import javafx.scene.transform.Scale;
import javafx.scene.transform.Translate;
 
public class Graphics3DXForm extends Group {
 
    public enum RotateOrder {
        XYZ, XZY, YXZ, YZX, ZXY, ZYX
    }
        
    public Translate t  = new Translate();
    public Translate p = new Translate();
    public Translate ip = new Translate();
    public Rotate rx = new Rotate();
    { rx.setAxis(Rotate.X_AXIS); }
    public Rotate ry = new Rotate();
    { ry.setAxis(Rotate.Y_AXIS); }
    public Rotate rz = new Rotate();
    { rz.setAxis(Rotate.Z_AXIS); }
    public Scale s = new Scale();

    public Graphics3DXForm() {
        super();
        getTransforms().addAll(t, rz, ry, rx, s);
    }

    public Graphics3DXForm(RotateOrder rotateOrder) { 
        super();
        // choose the order of rotations based on the rotateOrder
        switch (rotateOrder) {
        case XYZ:
            getTransforms().addAll(t, p, rz, ry, rx, s, ip);
            break;
        case YXZ:
             getTransforms().addAll(t, p, rz, rx, ry, s, ip);
             break;
        case YZX:
             getTransforms().addAll(t, p, rx, rz, ry, s, ip);  // For Camera
             break;
        case ZXY:
             getTransforms().addAll(t, p, ry, rx, rz, s, ip);
             break;
        case ZYX:
             getTransforms().addAll(t, p, rx, ry, rz, s, ip);
             break;
        }
    }

    public void setTranslate(double x, double y, double z) {
        t.setX(x);
        t.setY(y);
        t.setZ(z);
    }

    public void setTranslate(double x, double y) {
        t.setX(x);
        t.setY(y);
    }

    // Cannot override these methods as they are final:
    // public void setTranslateX(double x) { t.setX(x); }
    // public void setTranslateY(double y) { t.setY(y); }
    // public void setTranslateZ(double z) { t.setZ(z); }
    // Use these methods instead:
    public void setTx(double x) { t.setX(x); }
    public void setTy(double y) { t.setY(y); }
    public void setTz(double z) { t.setZ(z); }

    public void setRotate(double x, double y, double z) {
        rx.setAngle(x);
        ry.setAngle(y);
        rz.setAngle(z);
    }

    public void setRotateX(double x) { rx.setAngle(x); }
    public void setRotateY(double y) { ry.setAngle(y); }
    public void setRotateZ(double z) { rz.setAngle(z); }
    public void setRy(double y) { ry.setAngle(y); }
    public void setRz(double z) { rz.setAngle(z); }

    public void setScale(double scaleFactor) {
        s.setX(scaleFactor);
        s.setY(scaleFactor);
        s.setZ(scaleFactor);
    }

    // Cannot override these methods as they are final:
    // public void setScaleX(double x) { s.setX(x); }
    // public void setScaleY(double y) { s.setY(y); }
    // public void setScaleZ(double z) { s.setZ(z); }
    // Use these methods instead:
    public void setSx(double x) { s.setX(x); }
    public void setSy(double y) { s.setY(y); }
    public void setSz(double z) { s.setZ(z); }

    public void setPivot(double x, double y, double z) {
        p.setX(x);
        p.setY(y);
        p.setZ(z);
        ip.setX(-x);
        ip.setY(-y);
        ip.setZ(-z); 
    }

    public void reset() {
        t.setX(0.0);
        t.setY(0.0);
        t.setZ(0.0);
        rx.setAngle(0.0);
        ry.setAngle(0.0);
        rz.setAngle(0.0);
        s.setX(1.0);
        s.setY(1.0);
        s.setZ(1.0);
        p.setX(0.0);
        p.setY(0.0);
        p.setZ(0.0);
        ip.setX(0.0);
        ip.setY(0.0);
        ip.setZ(0.0);
    }

    public void resetTSP() {
        t.setX(0.0);
        t.setY(0.0);
        t.setZ(0.0);
        s.setX(1.0);
        s.setY(1.0);
        s.setZ(1.0);
        p.setX(0.0);
        p.setY(0.0);
        p.setZ(0.0);
        ip.setX(0.0);
        ip.setY(0.0);
        ip.setZ(0.0);
    }

    public void debug() {
        System.out.println("t = (" +
                           t.getX() + ", " +
                           t.getY() + ", " +
                           t.getZ() + ")  " +
                           "r = (" +
                           rx.getAngle() + ", " +
                           ry.getAngle() + ", " +
                           rz.getAngle() + ")  " +
                           "s = (" +
                           s.getX() + ", " +
                           s.getY() + ", " +
                           s.getZ() + ")  " +
                           "p = (" +
                           p.getX() + ", " +
                           p.getY() + ", " +
                           p.getZ() + ")  " +
                           "ip = (" +
                           ip.getX() + ", " +
                           ip.getY() + ", " +
                           ip.getZ() + ")");
    }
}
package RN;

import java.util.List;

import RN.algoactivations.EActivation;
import RN.dataset.inputsamples.ESamples;
import RN.linkage.ELinkage;
import RN.linkage.ELinkageBetweenAreas;
import RN.linkage.IFilterLinkage;
import RN.linkage.ILinkage;
import RN.linkage.SigmaWi;
import RN.nodes.ENodeType;
import RN.nodes.INode;
import RN.nodes.IPixelNode;

/**
 * @author Eric Marchand
 * 
 */
public interface IArea {

	int getNodeCount();

	List<INode> getNodes();

	INode getNode(int index);

	List<INode> createNodes(int nodeCount);

	void addNode(INode node);

	ILinkage getLinkage();
	
	ILayer getLayer();
	
	Integer getAreaId();
	
	void setAreaId(int areaId);
	
	void initGraphics();
	
	Boolean isShowImage();
	
	void showImageArea();
	
	void removeNode(INode node);
	
	void removeNodes(List<INode> nodes);	
	
	ILayer getPreviousLayer();
	
	ILayer getNextLayer();

	IArea getLeftSibilingArea();
	
	Identification getIdentification();
	
	IArea configureNode(boolean bias, EActivation activation, ENodeType type);
		
	IArea configureNode(boolean bias, ENodeType... types);
	
	IArea configureLinkage(ELinkage linkage, ELinkageBetweenAreas linkageAreas, Integer[] targetedAreas, ESamples eSampleFunction, boolean linkageWeightModifiable, Double... optParams);
	
	IArea configureLinkage(ELinkage linkage, ELinkageBetweenAreas linkageAreas, Integer[] targetedAreas, ESamples eSampleFunction, Integer sampling, boolean linkageWeightModifiable,  Double... optParams);
	
	IArea configureLinkage(ELinkage linkage, ELinkageBetweenAreas linkageAreas, ESamples eSampleFunction, Integer sampling, boolean linkageWeightModifiable,  Double... optParams);
	
	IArea configureLinkage(ELinkage linkage, ELinkageBetweenAreas linkageAreas, ESamples eSampleFunction, boolean linkageWeightModifiable, Double... optParams);
	
	IArea configureLinkage(ELinkage linkage, ESamples eSampleFunction, Integer sampling, boolean linkageWeightModifiable,  Double... optParams);
	
	IArea configureLinkage(ELinkage linkage, ESamples eSampleFunction, boolean linkageWeightModifiable, Double... optParams);
	
	int getNodeCountMinusRecurrentOnes();
	
	Double[] propagation(boolean playAgain, Double[] outputValues) throws Exception;
	
	void setLayer(ILayer layer);
	
	IArea deepCopy();
	
	void finalizeConnections();
	
	void applyFilter(IFilterLinkage linkage, int idFilter, IPixelNode thisNode, Float ecartType);
	
	void applyFilter(IFilterLinkage linkage, int idFilter, IPixelNode thisNode, SigmaWi sigmaWI);
	
	IArea getRightSibilingArea();

	void prePropagation();
	
	void postPropagation();
	

}package RN;

import java.util.List;

import RN.dataset.inputsamples.ESamples;
import RN.linkage.Filter;
import RN.linkage.IFilterLinkage;
import RN.linkage.ILinkage;
import RN.linkage.SigmaWi;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import RN.nodes.ImageNode;
import RN.nodes.Node;
import RN.nodes.PixelNode;
import javafx.scene.paint.Color;

/**
 * @author Eric Marchand
 * 
 */
public interface IAreaSquare {

	int getNodeCount();
	
	PixelNode getNode(int index);
	
	List<INode> getNodes();
	
	ILinkage getLinkage();
	
	IPixelNode getNodeXY(int x, int y);
	
	Integer nodeXYToNodeId(int x, int y, int sampling);
	
	IPixelNode getNodeXY(int x, int y, int sampling);

	IPixelNode getNodeXY(int x, int y, int x0, int y0, double theta);

	List<IPixelNode> getNodesInSquareZone(int x0, int y0, int width, int height);

	List<IPixelNode> getNodesInCirclarZone(int x0, int y0, int radius);
	
	List<IPixelNode> getNodesOnCirclarPerimeter(int x0, int y0, int radius);

	IPixelNode getNodeCenterXY();
	
	int getX(Node node);
	
	int getY(Node node);
	
	Integer getWidthPx();
	
	Integer getHeightPx();
	
	ImageNode getImageArea();
	
	Integer getNodeCenterX();
	
	Integer getNodeCenterY();
	
	Integer nodeXYToNodeId(int x, int y);
	
	int[] nodeIdToNodeXY(int id);
	
	Boolean isShowImage();
	
	void showImageArea();
	
	Identification getIdentification();
	
	void applyConvolutionFilter(IFilterLinkage linkage, int idFilter, IPixelNode thisNode, Float ecartType);
	
	void applyConvolutionCompositeFilter(IFilterLinkage linkage, int idFilter1, int idFilter2, ESamples op, IPixelNode thisNode, Float ecartType);
	
	void applyConvolutionCompositeFilter(IFilterLinkage linkage, int idFilter1, int idFilter2, ESamples op, IPixelNode thisNode, SigmaWi sigmaWI);
	
	void applyConvolutionFilter(IFilterLinkage linkage, int idFilter, IPixelNode thisNode, SigmaWi sigmaWI);
	
	void applyMaxPoolingFilter(IFilterLinkage linkage, int width, int stride, IPixelNode thisNode);
	
	void applyMaxPoolingFilter(IFilterLinkage linkage, int width, int stride, IPixelNode thisNode, SigmaWi sigmaWI);
	
	void applyFilter(IFilterLinkage linkage, int idFilter, IPixelNode thisNode, Float ecartType);
	
	void applyFilter(IFilterLinkage linkage, int idFilter, IPixelNode thisNode, SigmaWi sigmaWI);
	
	IArea getLeftSibilingArea();
	
	void pixelsToString(List<IPixelNode> pixels);
	
	void showGradients(double magnitudeFactor, double magnitudeThreshold, int sampling, Color color);
	
	void setShowImage(Boolean showImage);
	
	Filter getFilter(int filterId);
	
	

}package RN;

/**
 * @author Eric Marchand
 * 
 */
public class Identification {
	
	private Integer layerId = null;
	
	private Integer areaId = null;
	
	private Integer nodeId = null;

	public Identification(Integer layerId) {
		this.layerId = layerId;
	}
	
	public Identification(Integer layerId, Integer areaId) {
		this.layerId = layerId;
		this.areaId = areaId;
	}
	
	public Identification(Integer layerId, Integer areaId, Integer nodeId) {
		this.layerId = layerId;
		this.areaId = areaId;
		this.nodeId = nodeId;
	}
	
	public String getIdentification() {
		return " L[" + layerId + "] A[" + areaId + "] N[" + nodeId + "]";
	}
	
	public String toString(){
		return getIdentification();
	}

	public Integer getLayerId() {
		return layerId;
	}

	public void setLayerId(Integer layerId) {
		this.layerId = layerId;
	}

	public Integer getAreaId() {
		return areaId;
	}

	public void setAreaId(Integer areaId) {
		this.areaId = areaId;
	}

	public Integer getNodeId() {
		return nodeId;
	}

	public void setNodeId(Integer nodeId) {
		this.nodeId = nodeId;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((areaId == null) ? 0 : areaId.hashCode());
		result = prime * result + ((layerId == null) ? 0 : layerId.hashCode());
		result = prime * result + ((nodeId == null) ? 0 : nodeId.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Identification other = (Identification) obj;
		
		if (areaId == null) {
			if (other.areaId != null)
				return false;
		} else if (!areaId.equals(other.areaId))
			return false;
		if (layerId == null) {
			if (other.layerId != null)
				return false;
		} else if (!layerId.equals(other.layerId))
			return false;
		if (nodeId == null) {
			if (other.nodeId != null)
				return false;
		} else if (!nodeId.equals(other.nodeId))
			return false;
		return true;
	}
	
	

}
package RN;

import java.util.List;
import java.util.Map;

import RN.algoactivations.EActivation;
import RN.links.Link;
import RN.links.Weight;
import RN.nodes.ENodeType;
import RN.nodes.INode;

/**
 * @author Eric Marchand
 * 
 */
public interface ILayer {


	boolean isLayerReccurent();

	int getAreaCount();

	int getNodeCount();

	int getNodeCountMinusRecurrentOnes();

	Integer getLayerId();

	void setLayerId(int layerId);

	void addArea(IArea area);

	void addAreas(IArea... areas);

	List<IArea> getAreas();

	IArea getArea(int index);

	void setAreas(List<IArea> areas);

	List<INode> getLayerNodes();

	List<INode> getLayerNodes(ENodeType... nodeType);

	String toString();

	Network getNetwork();

	void setNetwork(Network network);

	boolean isFirstLayer();

	boolean isLastLayer();

	Double[] propagate(boolean playAgain) throws Exception;

	EActivation getFunction();

	void setFunction(EActivation function);

	void finalizeConnections();

	void setReccurent(boolean b);

	void setDropOut(Boolean dropOut);

	Boolean isDropOutLayer();

	double getLayerError();

	void setLayerError(double layerError);

	ILayer deepCopy();

	void initGraphics();

	
}package RN;

import java.util.List;
import java.util.ListIterator;

import RN.dataset.InputData;
import RN.dataset.OutputData;
import RN.nodes.INode;

/**
 * @author ericmarchand
 *
 */
public interface INetwork {

	
	OutputData compute(ListIterator<InputData> itr) throws Exception;

	ILayer getFirstLayer();

	ILayer getLastLayer();

	void show();

	ILayer getLayer(int i);

	List<ILayer> getLayers();

	OutputData propagation(boolean playAgain) throws Exception;

	List<INode> getAllNodes();

	void addLayer(ILayer layer);

	void finalizeConnections();

	void init(double d, double e);

	String getString();

	void setTimeSeriesOffset(Integer timeSeriesOffset);

	Integer getTimeSeriesOffset();

	void setRecurrentNodesLinked(Boolean lateralLinkRecurrentNodes);

	Boolean isRecurrentNodesLinked();

	void setAbsoluteError(double absoluteError);
	
	double getAbsoluteError();

	INetwork deepCopy(int generationCount);
	
	void disconnectAll();
	
	String getName();

	void setName(String name);
	
	void appendName(String name);

	String geneticCodec();
	
	void initBiasWeights(double value);
	
	ENetworkImplementation getImpl();
	
	INode getNode(Identification id);

	
	/**
	 * Initialisation de parametres eventuels
	 * @param trainCycleAbsolute 
	 */
	void newLearningCycle(int trainCycleAbsolute);


}
package RN;

import java.util.List;

import javafx.scene.chart.LineChart;

/**
 * @author Eric Marchand
 * 
 */
public interface ITester {

	public final static String NEWLINE = System.getProperty("line.separator");

	public abstract INetwork createNetwork(String networkName);
	
	public abstract void launchRealCompute() throws Exception;

	public abstract INetwork initWeights(double min, double max);
	
	public abstract int getInputsCount();
	
	public abstract int getOutputsCount();
	
	public abstract INetwork getNetwork();

	void setInputsCount(int insize);

	void setOutputsCount(int outsize);
	
	List<LineChart.Series<Number, Number>> getSeriesInList();

	void setSeriesInList(List<LineChart.Series<Number, Number>> seriesInList);

	List<LineChart.Series<Number, Number>> getSeriesOutList();

	void setSeriesOutList(List<LineChart.Series<Number, Number>> seriesOutList);

	List<LineChart.Series<Number, Number>> getSeriesIdealList();

	void setSeriesIdealList(List<LineChart.Series<Number, Number>> seriesIdealList);


	void setNetwork(INetwork net);
	
	String getFilePath();
	
	Integer getTimeSeriesOffset();

	void setTrainingVectorNumber(Integer lastRowNum);

	Integer getLayerHidden0NodesCount();

	void setLayerHidden0NodesCount(Integer layerHidden0NodesCount);
	
	Integer getLayerHidden1NodesCount();

	void setLayerHidden1NodesCount(Integer layerHidden1NodesCount);

	Integer getLayerHidden2NodesCount();

	void setLayerHidden2NodesCount(Integer layerHidden2NodesCount);

	Integer getLayerOutNodesCount();

	void setLayerOutNodesCount(Integer layerOutNodesCount);

	String getLayerOutActivation();

	void setLayerOutActivation(String layerOutActivation);

	Boolean getLayerOutRecurrent();

	void setLayerOutRecurrent(Boolean layerOutRecurrent);

	String getLayerHidden0Activation();

	void setLayerHidden0Activation(String layerHidden0Activation);

	Boolean getLayerHidden0Recurrent();

	void setLayerHidden0Recurrent(Boolean layerHidden0Recurrent);

	String getLayerHidden1Activation();

	void setLayerHidden1Activation(String layerHidden1Activation);

	Boolean getLayerHidden1Recurrent();

	void setLayerHidden1Recurrent(Boolean layerHidden1Recurrent);

	String getLayerHidden2Activation();

	void setLayerHidden2Activation(String layerHidden2Activation);

	Boolean getLayerHidden2Recurrent();

	void setLayerHidden2Recurrent(Boolean layerHidden2Recurrent);

	Integer getLayerInNodesCount();

	void setLayerInNodesCount(Integer layerInNodesCount);

	String getLayerInActivation();

	void setLayerInActivation(String layerInActivation);

	int getOptimizedNumHiddens();

	void setOptimizedNumHiddens(int optimizedNumHiddens);

	INetwork createXLSNetwork(String networkName, NetworkContext netContext);

	void launchTestCompute() throws Exception;

	String getLineChartTitle();

	double getInitWeightRange(int idx);

	boolean isDropOutActive();


}package RN;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import RN.algoactivations.EActivation;
import RN.nodes.ENodeType;
import RN.nodes.INode;
import RN.nodes.RecurrentNode;

/**
 * @author Eric Marchand
 * 
 */
public class Layer extends NetworkElement implements Serializable, ILayer{

	protected int layerId;
	
	private EActivation function;
	
	List<ILayer> sublayers;

	List<IArea> areas;
	
	private boolean recurrent = false;

	private Boolean dropOutNodes = false;
	
	private double layerError = 0.0D;
	
	
	public Layer() {
		this.sublayers = new ArrayList<ILayer>();
		this.areas = new ArrayList<IArea>();
	}
	
	public Layer(EActivation eFunction) {
		this.function = eFunction;
		this.sublayers = new ArrayList<ILayer>();
		this.areas = new ArrayList<IArea>();
	}
	

	public Layer(Area... areas) {
		this();
		for(Area area : areas)
			addArea(area);
	}
	
	
	
	/* (non-Javadoc)
	 * @see RN.ILayer#isLayerReccurent()
	 */
	@Override
	public boolean isLayerReccurent(){
		return recurrent;
	}

	/* (non-Javadoc)
	 * @see RN.ILayer#getAreaCount()
	 */
	@Override
	public int getAreaCount() {
		return areas.size();
	}

	/* (non-Javadoc)
	 * @see RN.ILayer#getNodeCount()
	 */
	@Override
	public int getNodeCount() {
		int count = 0;
		for (IArea area : areas) {
			count += area.getNodeCount();
		}
		return count;
	}
	
	/* (non-Javadoc)
	 * @see RN.ILayer#getNodeCountMinusRecurrentOnes()
	 */
	@Override
	public int getNodeCountMinusRecurrentOnes() {
		int count = 0;
		for (IArea area : areas) {
			count += area.getNodeCountMinusRecurrentOnes();
		}
		return count;
	}
	

	/* (non-Javadoc)
	 * @see RN.ILayer#getLayerId()
	 */
	@Override
	public Integer getLayerId() {
		return layerId;
	}

	/* (non-Javadoc)
	 * @see RN.ILayer#setLayerId(int)
	 */
	@Override
	public void setLayerId(int layerId) {
		this.layerId = layerId;
	}

	/* (non-Javadoc)
	 * @see RN.ILayer#addArea(RN.IArea)
	 */
	@Override
	public void addArea(IArea area) {
		if(area.getLayer() == null){
			area.setAreaId(areas.size());
			area.setLayer(this);
		}
		areas.add(area);
		area.initGraphics();
	}
	
	
	/* (non-Javadoc)
	 * @see RN.ILayer#addAreas(RN.IArea)
	 */
	@Override
	public void addAreas(IArea... areas) {
		for(IArea area : areas){
			addArea(area);
		}
	}

	/* (non-Javadoc)
	 * @see RN.ILayer#getAreas()
	 */
	@Override
	public List<IArea> getAreas() {
		return areas;
	}
	
	/* (non-Javadoc)
	 * @see RN.ILayer#getArea(int)
	 */
	@Override
	public IArea getArea(int index) {
		return areas.get(index);
	}

	/* (non-Javadoc)
	 * @see RN.ILayer#setAreas(java.util.List)
	 */
	@Override
	public void setAreas(List<IArea> areas) {
		this.areas = areas;
	}

	/* (non-Javadoc)
	 * @see RN.ILayer#getLayerNodes()
	 */
	@Override
	public List<INode> getLayerNodes() {
		List<INode> layerNodes = new ArrayList<INode>();
		List<IArea> areas = this.getAreas();
		for (IArea area : areas) {
			List<INode> nodes = area.getNodes();
			for (INode node : nodes) {
				layerNodes.add(node);
			}

		}
		return layerNodes;
	}
	
	/* (non-Javadoc)
	 * @see RN.ILayer#getLayerNodes(RN.nodes.ENodeType)
	 */
	@Override
	public List<INode> getLayerNodes(ENodeType... nodeType) {
		List<INode> layerNodes = new ArrayList<INode>();
		List<IArea> areas = this.getAreas();
		for (IArea area : areas) {
			
			List<INode> nodes = area.getNodes();
			
			for (INode node : nodes) {
				if(node.getNodeType() == ENodeType.ALL)
					layerNodes.add(node);
				else if(Arrays.asList(nodeType).contains(node.getNodeType()) )
					layerNodes.add(node);

			}

		}
		return layerNodes;
	}
	
	
	/* (non-Javadoc)
	 * @see RN.ILayer#toString()
	 */
	@Override
	public String toString(){
		return ITester.NEWLINE + ITester.NEWLINE +"Layer id : " + this.layerId;
	}

	/* (non-Javadoc)
	 * @see RN.ILayer#getNetwork()
	 */
	@Override
	public Network getNetwork() {
		return network;
	}

	/* (non-Javadoc)
	 * @see RN.ILayer#setNetwork(RN.Network)
	 */
	@Override
	public void setNetwork(Network network) {
		this.network = network;
	}
	
	/* (non-Javadoc)
	 * @see RN.ILayer#isFirstLayer()
	 */
	@Override
	public boolean isFirstLayer(){
		return this.getLayerId() == 0;
	}
	
	/* (non-Javadoc)
	 * @see RN.ILayer#isLastLayer()
	 */
	@Override
	public boolean isLastLayer(){
		return this.getLayerId() == network.getLayers().size() - 1;
	}

	/* (non-Javadoc)
	 * @see RN.ILayer#propagate(boolean)
	 */
	@Override
	public Double[] propagate(boolean playAgain) throws Exception {
		
		Double[] outputValues = null;
		
		for (IArea area : areas) {
			
			area.prePropagation();
			outputValues = area.propagation(playAgain, outputValues);
			area.postPropagation();
			
			if(area.isShowImage()){
				area.showImageArea();
			}
		}
		
		
		return outputValues;
		
	}


	/* (non-Javadoc)
	 * @see RN.ILayer#getFunction()
	 */
	@Override
	public EActivation getFunction() {
		return function;
	}

	/* (non-Javadoc)
	 * @see RN.ILayer#setFunction(RN.algoactivations.EActivation)
	 */
	@Override
	public void setFunction(EActivation function) {
		this.function = function;
	}

	/* (non-Javadoc)
	 * @see RN.ILayer#finalizeConnections()
	 */
	@Override
	public void finalizeConnections() {
		
		if (network == null || network.getImpl() == null || network.getImpl() == ENetworkImplementation.LINKED) {
			
			if (isFirstLayer()) {
				for (ILayer layer : getNetwork().getLayers()) {
					if (layer.isLayerReccurent()) {
						for (INode sourceNode : layer.getLayerNodes()) {
							this.getArea(0).addNode(new RecurrentNode(sourceNode));
						}
					}
				}
			}
			
		}

	}
	


	/* (non-Javadoc)
	 * @see RN.ILayer#setReccurent(boolean)
	 */
	@Override
	public void setReccurent(boolean b) {
		this.recurrent = b;
	}

	/* (non-Javadoc)
	 * @see RN.ILayer#setDropOut(java.lang.Boolean)
	 */
	@Override
	public void setDropOut(Boolean dropOut) {
		dropOutNodes  = dropOut;
	}
	
	/* (non-Javadoc)
	 * @see RN.ILayer#isDropOutLayer()
	 */
	@Override
	public Boolean isDropOutLayer() {
		return this.dropOutNodes;
	}

	/* (non-Javadoc)
	 * @see RN.ILayer#getLayerError()
	 */
	@Override
	public double getLayerError() {
		return layerError;
	}

	/* (non-Javadoc)
	 * @see RN.ILayer#setLayerError(double)
	 */
	@Override
	public void setLayerError(double layerError) {
		this.layerError = layerError;
	}

	/* (non-Javadoc)
	 * @see RN.ILayer#deepCopy()
	 */
	@Override
	public Layer deepCopy() {
		Layer copy_layer = new Layer();
		
		List<IArea> copy_areas = new ArrayList<IArea>(areas);
		Collections.copy(copy_areas, areas);
		
		copy_layer.setDropOut(new Boolean(dropOutNodes));
		copy_layer.setFunction(EActivation.valueOf(function.name()));
		copy_layer.setLayerError(layerError);
		copy_layer.setLayerId(layerId);
		copy_layer.setReccurent(recurrent);
		copy_layer.setNetwork(network);
		copy_layer.setAreas(copy_areas);
		
		int idx = 0;
		for(IArea area : areas){
			area.setLayer(copy_layer);
			copy_areas.set(idx++, area.deepCopy());
		}
		
		
		return copy_layer;
	}
	
	/* (non-Javadoc)
	 * @see RN.ILayer#initGraphics()
	 */
	@Override
	public void initGraphics() {
		if(Graphics3D.graphics3DActive)
			Graphics3D.createLayer(this);
	}


}
package RN.linkage;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.Coordinate;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.links.ELinkType;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public class CartesianToLogPolarImageLinkage extends FilterLinkage {
	

	//Number of orientations (between 3 to 20) 8 is a typical value
	private Double n_t = null;
	
	//Number of scales of the multiresolution scheme
	private Double n_s = null;
	
	private Double angle = 360D;
	
	private Double base = null;
	
	private Integer radius = null;
	


	public CartesianToLogPolarImageLinkage() {
	}
	

	
	public void initParameters() {
		
		if(params.length != 2 && params.length != 3)
			throw new RuntimeException("Missing Cartesian to Log Polar parameters'");
		
		
		n_t = params[0];
		n_s = params[1];
		
		if(params.length == 3 && params[2] != null)
			angle = params[2];
		
		base = 1 + (Math.PI / (Math.sqrt(3D) * n_t));
		

	}

	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		// somme des entrees pondérées
		SigmaWi sigmaWI = new SigmaWi();
		
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		IPixelNode pix = (IPixelNode) thisNode;
		
		radius = Math.min(Math.round(subArea.getHeightPx() / 2), Math.round(subArea.getWidthPx() / 2)) - 1;
		
		
		
		double nbPixPerDegree;
		double nbPixPerRadius;
		double a;
		double r;
		
		Coordinate coord = new Coordinate(pix.getX(), pix.getY());
		//coord.setBase(this.base);
		coord.setX0((double) subArea.getNodeCenterX());
		coord.setY0((double) subArea.getNodeCenterY());
		
		nbPixPerDegree = pix.getAreaSquare().getWidthPx() / angle;
		a = coord.getX() / nbPixPerDegree;
		
		nbPixPerRadius = pix.getAreaSquare().getHeightPx() / radius;
		r = coord.getY() / nbPixPerRadius;
		
		coord.setTheta(Math.toRadians(a));
		coord.setP(r);
		coord.setBase(base);
		coord.logPolarToLinearSystem();
		
		IPixelNode subPix = subArea.getNodeXY(coord.getX().intValue(), coord.getY().intValue());
		if(subPix != null){
			sigmaWI.sum(subPix.getComputedOutput());
		}
		
		
		return sigmaWI.value();
	}
	
	private void cartesianToPolar(IPixelNode pix, IAreaSquare subArea) {
		
		int centerX = Math.round(pix.getAreaSquare().getHeightPx() / 2);
		int centerY = Math.round(pix.getAreaSquare().getWidthPx() / 2);
		int i = 1;
		
		int x, y;
		
		for(int r=0; r < this.radius; r++){
			int j = 1;
			for(int a=0; a < 2 * Math.PI - 2 * Math.PI / angle; a +=2 * Math.PI / angle ){
				x = (int) (centerX + Math.round(r * Math.cos(a)));
				y = (int) (centerY + Math.round(r * Math.sin(a)));
				
				pix.getAreaSquare().getNodeXY(i, j).setComputedOutput(subArea.getNodeXY(x, y).getComputedOutput());
				j++;
			}
			i++;
		}
		

	}
	
//	   img         = double(img);
//	   [rows,cols] = size(img);
//	   cy          = round(rows/2);
//	   cx          = round(cols/2);
//	   
//	   if exist('radius','var') == 0
//	      radius = min(round(rows/2),round(cols/2))-1;
//	   end
//	   
//	   if exist('angle','var') == 0
//	      angle = 360;
//	   end
//	  
//	   pcimg = [];
//	   i     = 1;
//	   
//	   for r=0:radius
//	      j = 1;
//	      for a=0:2*pi/angle:2*pi-2*pi/angle
//	         pcimg(i,j) = img(cy+round(r*sin(a)),cx+round(r*cos(a)));
//	         j = j + 1;
//	      end
//	      i = i + 1;
//	   end
//	end



	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		IPixelNode pix = (IPixelNode) thisNode;
		
		radius = Math.min(Math.round(subArea.getHeightPx() / 2), Math.round(subArea.getWidthPx() / 2)) - 1;
		
		double nbPixPerDegree;
		double nbPixPerRadius;
		double a;
		double r;
		
		Coordinate coord = new Coordinate(pix.getX(), pix.getY());
		//coord.setBase(this.base);
		coord.setX0((double) subArea.getNodeCenterX());
		coord.setY0((double) subArea.getNodeCenterY());
		
		nbPixPerDegree = pix.getAreaSquare().getWidthPx() / angle;
		a = coord.getX() / nbPixPerDegree;
		
		nbPixPerRadius = pix.getAreaSquare().getHeightPx() / radius;
		r = coord.getY() / nbPixPerRadius;
		
		coord.setTheta(Math.toRadians(a));
		coord.setP(r);
		coord.setBase(base);
		coord.logPolarToLinearSystem();
		
		IPixelNode subPix = subArea.getNodeXY(coord.getX().intValue(), coord.getY().intValue());
		if(subPix != null){
			subPix.link(thisNode, ELinkType.REGULAR, isWeightModifiable());
		}
		
	}
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		// Calcul du filtre Log-Gabor
		return  InputSample.getInstance().compute(
				filterFunction, 
				(double) subArea.getWidthPx(),
				getN_t(),
				getN_s(),
				(double) (sublayerNode.getX() - subArea.getWidthPx() / 2D) * 4D,
				(double) (sublayerNode.getY() - subArea.getHeightPx() / 2D) * 4D
				);
		
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}
	
	public void addGraphicInterface(Pane pane) {
		
	}


	public Double getN_t() {
		return n_t;
	}



	public void setN_t(Double n_t) {
		this.n_t = n_t;
	}



	public Double getN_s() {
		return n_s;
	}



	public void setN_s(Double n_s) {
		this.n_s = n_s;
	}



}
package RN.linkage;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.Coordinate;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.links.ELinkType;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public class CartesianToPolarImageLinkage extends FilterLinkage {
	

	//Number of orientations (between 3 to 20) 8 is a typical value
	private Double n_t = null;
	
	//Number of scales of the multiresolution scheme
	private Double n_s = null;
	
	private Double angle = 360D;
	
	private Double base = null;
	
	private Integer radius = null;
	


	public CartesianToPolarImageLinkage() {
	}
	

	
	public void initParameters() {
		
		if(params.length != 2 && params.length != 3)
			throw new RuntimeException("Missing Cartesian to Polar parameters'");
		
		
		n_t = params[0];
		n_s = params[1];
		
		if(params.length == 3 && params[2] != null)
			angle = params[2];
		
		base = 1 + (Math.PI / (Math.sqrt(3D) * n_t));
		

	}

	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		// somme des entrees pondérées
		SigmaWi sigmaWI = new SigmaWi();
		
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		IPixelNode pix = (IPixelNode) thisNode;
		
		radius = Math.min(Math.round(subArea.getHeightPx() / 2), Math.round(subArea.getWidthPx() / 2)) - 1;
		
		
		
		double nbPixPerDegree;
		double nbPixPerRadius;
		double a;
		double r;
		
		Coordinate coord = new Coordinate(pix.getX(), pix.getY());
		//coord.setBase(this.base);
		coord.setX0((double) subArea.getNodeCenterX());
		coord.setY0((double) subArea.getNodeCenterY());
		
		nbPixPerDegree = pix.getAreaSquare().getWidthPx() / angle;
		a = coord.getX() / nbPixPerDegree;
		
		nbPixPerRadius = pix.getAreaSquare().getHeightPx() / radius;
		r = coord.getY() / nbPixPerRadius;
		
		coord.setTheta(Math.toRadians(a));
		coord.setR(r);
		coord.polarToLinearSystem();
		
		IPixelNode subPix = subArea.getNodeXY(coord.getX().intValue(), coord.getY().intValue());
		if(subPix != null){
			sigmaWI.sum(subPix.getComputedOutput());
		}
		
		
		return sigmaWI.value();
	}
	
	private void cartesianToPolar(IPixelNode pix, IAreaSquare subArea) {
		
		int centerX = Math.round(pix.getAreaSquare().getHeightPx() / 2);
		int centerY = Math.round(pix.getAreaSquare().getWidthPx() / 2);
		int i = 1;
		
		int x, y;
		
		for(int r=0; r < this.radius; r++){
			int j = 1;
			for(int a=0; a < 2 * Math.PI - 2 * Math.PI / angle; a +=2 * Math.PI / angle ){
				x = (int) (centerX + Math.round(r * Math.cos(a)));
				y = (int) (centerY + Math.round(r * Math.sin(a)));
				
				pix.getAreaSquare().getNodeXY(i, j).setComputedOutput(subArea.getNodeXY(x, y).getComputedOutput());
				j++;
			}
			i++;
		}
		

	}
	
//	   img         = double(img);
//	   [rows,cols] = size(img);
//	   cy          = round(rows/2);
//	   cx          = round(cols/2);
//	   
//	   if exist('radius','var') == 0
//	      radius = min(round(rows/2),round(cols/2))-1;
//	   end
//	   
//	   if exist('angle','var') == 0
//	      angle = 360;
//	   end
//	  
//	   pcimg = [];
//	   i     = 1;
//	   
//	   for r=0:radius
//	      j = 1;
//	      for a=0:2*pi/angle:2*pi-2*pi/angle
//	         pcimg(i,j) = img(cy+round(r*sin(a)),cx+round(r*cos(a)));
//	         j = j + 1;
//	      end
//	      i = i + 1;
//	   end
//	end



	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		IPixelNode pix = (IPixelNode) thisNode;
		
		radius = Math.min(Math.round(subArea.getHeightPx() / 2), Math.round(subArea.getWidthPx() / 2)) - 1;
		
		double nbPixPerDegree;
		double nbPixPerRadius;
		double a;
		double r;
		
		Coordinate coord = new Coordinate(pix.getX(), pix.getY());
		//coord.setBase(this.base);
		coord.setX0((double) subArea.getNodeCenterX());
		coord.setY0((double) subArea.getNodeCenterY());
		
		nbPixPerDegree = pix.getAreaSquare().getWidthPx() / angle;
		a = coord.getX() / nbPixPerDegree;
		
		nbPixPerRadius = pix.getAreaSquare().getHeightPx() / radius;
		r = coord.getY() / nbPixPerRadius;
		
		coord.setTheta(Math.toRadians(a));
		coord.setR(r);
		coord.polarToLinearSystem();
		
		IPixelNode subPix = subArea.getNodeXY(coord.getX().intValue(), coord.getY().intValue());
		if(subPix != null){
			subPix.link(thisNode, ELinkType.REGULAR, isWeightModifiable());
		}
		
	}
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		// Calcul du filtre Log-Gabor
		return  InputSample.getInstance().compute(
				filterFunction, 
				(double) subArea.getWidthPx(),
				getN_t(),
				getN_s(),
				(double) (sublayerNode.getX() - subArea.getWidthPx() / 2D) * 4D,
				(double) (sublayerNode.getY() - subArea.getHeightPx() / 2D) * 4D
				);
		
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}
	
	public void addGraphicInterface(Pane pane) {
		
	}


	public Double getN_t() {
		return n_t;
	}



	public void setN_t(Double n_t) {
		this.n_t = n_t;
	}



	public Double getN_s() {
		return n_s;
	}



	public void setN_s(Double n_s) {
		this.n_s = n_s;
	}



}
package RN.linkage;

import RN.IAreaSquare;
import RN.ILayer;
import RN.links.ELinkType;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import RN.nodes.PixelNode;

/**
 * @author Eric Marchand
 *
 */
public class ContourLinkage extends Linkage {

	
	public ContourLinkage() {
		super();
	}
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode) {

		// somme des entrees pondérées
		Double sigmaWI = 0D;


		PixelNode pxNode = (PixelNode) thisNode;

		sigmaWI += getCheckedPixelNodeXY(pxNode, pxNode.getX(), pxNode.getY()).getComputedOutput() * -8D;

		if (pxNode.getX() >= 0)
			sigmaWI += getCheckedPixelNodeXY(pxNode, pxNode.getX() - 1, pxNode.getY()).getComputedOutput();// * 1D;

		if (pxNode.getX() <= pxNode.getAreaSquare().getWidthPx() - 1)
			sigmaWI += getCheckedPixelNodeXY(pxNode, pxNode.getX() + 1, pxNode.getY()).getComputedOutput();// * 1D;

		if (pxNode.getY() >= 0)
			sigmaWI += getCheckedPixelNodeXY(pxNode, pxNode.getX(), pxNode.getY() - 1).getComputedOutput();// * 1D;

		if (pxNode.getY() <= pxNode.getAreaSquare().getHeightPx() - 1)
			sigmaWI += getCheckedPixelNodeXY(pxNode, pxNode.getX(), pxNode.getY() + 1).getComputedOutput();// * 1D;

		// diagonales

		// en haut à gauche
		if (pxNode.getX() >= 0 && pxNode.getY() >= 0)
			sigmaWI += getCheckedPixelNodeXY(pxNode, pxNode.getX() - 1, pxNode.getY() - 1 ).getComputedOutput();// * 1D;

		// en haut à droite
		if (pxNode.getX() <= pxNode.getAreaSquare().getWidthPx() - 1 && pxNode.getY() >= 0)
			sigmaWI += getCheckedPixelNodeXY(pxNode, pxNode.getX() + 1, pxNode.getY() - 1 ).getComputedOutput();// * 1D;

		// en bas à gauche
		if (pxNode.getY() <= pxNode.getAreaSquare().getHeightPx() - 1 && pxNode.getX() >= 0)
			sigmaWI += getCheckedPixelNodeXY(pxNode, pxNode.getX() - 1, pxNode.getY() + 1 ).getComputedOutput();// * 1D;

		// en bas à droite
		if (pxNode.getY() <= pxNode.getAreaSquare().getHeightPx() - 1 && pxNode.getX() <= pxNode.getAreaSquare().getWidthPx() - 1)
			sigmaWI += getCheckedPixelNodeXY(pxNode, pxNode.getX() + 1, pxNode.getY() + 1 ).getComputedOutput();// * 1D;
		
		sigmaWI -= thisNode.getBiasWeightValue();


		return sigmaWI;
	}
	
	/* (non-Javadoc)
	 * @see RN.linkage.FullFanOutLinkage#sublayerFanOutLinkage(RN.Layer)
	 */
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {

		/**
		 * Filtre délimiteur de contours Implémentation de l'opérateur Laplacien
		 * avec diagonales
		 * 
		 * 1  1  1 
		 * 1 -8  1 
		 * 1  1  1
		 */
		
		PixelNode pxNode = (PixelNode) thisNode;

		getCheckedPixelNodeXY(pxNode, pxNode.getX(), pxNode.getY()).link(pxNode, ELinkType.REGULAR, isWeightModifiable(), -8D);

		if (pxNode.getX() >= 0)
			getCheckedPixelNodeXY(pxNode, pxNode.getX() - 1, pxNode.getY()).link(pxNode, ELinkType.REGULAR, isWeightModifiable(), 1D);

		if (pxNode.getX() <= pxNode.getAreaSquare().getWidthPx() - 1)
			getCheckedPixelNodeXY(pxNode, pxNode.getX() + 1, pxNode.getY()).link(pxNode, ELinkType.REGULAR, isWeightModifiable(), 1D);

		if (pxNode.getY() >= 0)
			getCheckedPixelNodeXY(pxNode, pxNode.getX(), pxNode.getY() - 1).link(pxNode, ELinkType.REGULAR, isWeightModifiable(), 1D);

		if (pxNode.getY() <= pxNode.getAreaSquare().getHeightPx() - 1)
			getCheckedPixelNodeXY(pxNode, pxNode.getX(), pxNode.getY() + 1).link(pxNode, ELinkType.REGULAR, isWeightModifiable(), 1D);

		// diagonales

		// en haut à gauche
		if (pxNode.getX() >= 0 && pxNode.getY() >= 0)
			getCheckedPixelNodeXY(pxNode, pxNode.getX() - 1, pxNode.getY() - 1).link(pxNode, ELinkType.REGULAR, isWeightModifiable(), 1D);

		// en haut à droite
		if (pxNode.getX() <= pxNode.getAreaSquare().getWidthPx() - 1 && pxNode.getY() >= 0)
			getCheckedPixelNodeXY(pxNode, pxNode.getX() + 1, pxNode.getY() - 1).link(pxNode, ELinkType.REGULAR, isWeightModifiable(), 1D);

		// en bas à gauche
		if (pxNode.getY() <= pxNode.getAreaSquare().getHeightPx() - 1 && pxNode.getX() >= 0)
			getCheckedPixelNodeXY(pxNode, pxNode.getX() - 1, pxNode.getY() + 1).link(pxNode, ELinkType.REGULAR, isWeightModifiable(), 1D);

		// en bas à droite
		if (pxNode.getY() <= pxNode.getAreaSquare().getHeightPx() - 1 && pxNode.getX() <= pxNode.getAreaSquare().getWidthPx() - 1)
			getCheckedPixelNodeXY(pxNode, pxNode.getX() + 1, pxNode.getY() + 1).link(pxNode, ELinkType.REGULAR, isWeightModifiable(), 1D);

	}

	private IPixelNode getCheckedPixelNodeXY(INode thisNode, int x, int y) {

		IPixelNode node = null;
		IPixelNode pxNode = (PixelNode) thisNode;
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();

		node = subArea.getNodeXY(x, y);

		if(node == null) {

			// on se trouve à proximité d'un bord, on recopie le pixel du bord
			try {
				
				if(x < 0)
					x += 1;
				
				if(y < 0)
					y += 1;
				
				if(x > pxNode.getAreaSquare().getWidthPx() - 1)
					x -= 1;
				
				if(y > pxNode.getAreaSquare().getHeightPx() - 1)
					y -= 1;
					
				node = subArea.getNodeXY(x, y);
				
			} catch (Exception e1) {
				e1.printStackTrace();
			}

		}

		return node;

	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void initParameters() {
		// TODO Auto-generated method stub
		
	}

}
package RN.linkage;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import RN.IArea;
import RN.IAreaSquare;
import RN.ILayer;
import RN.Identification;
import RN.algoactivations.EActivation;
import RN.dataset.inputsamples.ESamples;
import RN.links.Weight;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import RN.nodes.ImageNode;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Button;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;

/**
 * @author ericmarchand
 * 
 */
public class ConvolutionLinkage extends FilterLinkage {
	
	// Matrice carrée d'ordre N
	//private static int N = 5;

	Integer stride = null;
	Integer filterWidth = null;
	Integer toCenter = null;

	private static Map<Identification,Weight[][]> sharedWeights = null;
	private static Map<Identification,Weight> sharedBiasWeight = null;

	public ConvolutionLinkage() {
	}

	public ConvolutionLinkage(Integer sampling) {
		this.sampling = sampling;
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see RN.linkage.ILinkage#initParameters()
	 */
	public void initParameters() {

		if (params[0] != null)
			filterWidth = params[0].intValue();

		if (params[1] != null)
			stride = params[1].intValue();

		toCenter = ((filterWidth - 1) / 2);
		
		sharedWeights = null;
		sharedBiasWeight = null;

	}
	
	private void initSharedWeights(){
		
		if (sharedWeights == null || sharedWeights.get(getArea().getIdentification()) == null) {
			sharedWeights = new HashMap<Identification, Weight[][]>();
			sharedBiasWeight = new HashMap<Identification, Weight>();
			Weight[][] weights = null;
			Weight biasWeight = null;
			for (IArea area : getArea().getLayer().getAreas()) {
				weights = new Weight[filterWidth][filterWidth];
				biasWeight = new Weight();
				for (int y = 0; y < filterWidth; y++) {
					for (int x = 0; x < filterWidth; x++) {
						weights[x][y] = new Weight();
					}
				}
				sharedWeights.put(area.getIdentification(), weights);
				sharedBiasWeight.put(area.getIdentification(), biasWeight);
				for(INode node : area.getNodes()){
					node.setBiasWeight(biasWeight);
				}
			}
		}
		
	}
	
	public static Weight[][] getSharedFilter(IArea area){
		return sharedWeights.get(area.getIdentification());
	}

	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode) {

		// somme des entrees pondérées
		SigmaWi sigmaWI = new SigmaWi();
		IPixelNode pix = (IPixelNode) thisNode;

		IAreaSquare subArea = null;
		IPixelNode centerPix = null;

		List<IPixelNode> nodesInSquare = null;
		Integer startX = null;
		Integer startY = null;
		int paddingX = 0;
		int paddingY = 0;
		
		initSharedWeights();

		for (IArea area : getLinkedAreas()) {

			subArea = (IAreaSquare) area;
			paddingX = (subArea.getWidthPx() - ((IAreaSquare) getArea()).getWidthPx()) / 2;
			paddingY = (subArea.getHeightPx() - ((IAreaSquare) getArea()).getHeightPx()) / 2;
			centerPix = subArea.getNodeXY(pix.getX() * stride + paddingX, pix.getY() * stride + paddingY);
			startX = centerPix.getX() - toCenter;
			startY = centerPix.getY() - toCenter;

			nodesInSquare = subArea.getNodesInSquareZone(startX, startY, filterWidth, filterWidth);
			for (IPixelNode innerPix : nodesInSquare) {
				sigmaWI.sum(innerPix.getComputedOutput() * getLinkAndPutIfAbsent(thisNode, (INode) innerPix, isWeightModifiable(),
						sharedWeights.get(getArea().getIdentification())[innerPix.getX() - startX][innerPix.getY() - startY]).getWeight());
			}

			sigmaWI.sum(-thisNode.getBiasWeightValue());

		}

		return sigmaWI.value();
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {

		IPixelNode pix = (IPixelNode) thisNode;

		IAreaSquare subArea = null;
		IPixelNode centerPix = null;

		List<IPixelNode> nodesInSquare = null;
		Integer startX = null;
		Integer startY = null;
		
		initSharedWeights();

		for (IArea area : getLinkedAreas()) {

			subArea = (IAreaSquare) area;
			centerPix = subArea.getNodeXY(pix.getX() * stride, pix.getY() * stride);
			startX = centerPix.getX() - toCenter;
			startY = centerPix.getY() - toCenter;
			nodesInSquare = subArea.getNodesInSquareZone(startX, startY, filterWidth, filterWidth);
			for (IPixelNode innerPix : nodesInSquare) {
				innerPix.link(thisNode, isWeightModifiable(), sharedWeights.get(getArea().getIdentification())[innerPix.getX() - startX][innerPix.getY() - startY]);
			}
			
		}

	}
	
//	@Override
//	public double getUnLinkedSigmaPotentials(INode thisNode){
//
//		// somme des entrees pondérées
//		SigmaWi sigmaWI = new SigmaWi();
//
//		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
//		
//		initFilter(this, ID_FILTER_CONVOLUTION, ESamples.RAND, (IPixelNode) thisNode, subArea);
//		
//		subArea.applyConvolutionFilter(this, ID_FILTER_CONVOLUTION, (IPixelNode) thisNode, sigmaWI);
//			
//		
//		return sigmaWI.value();
//	}
//
//
//	
//	@Override
//	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
//		
//		
//		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
//		
//		initFilter(this, ID_FILTER_CONVOLUTION, ESamples.RAND, (IPixelNode) thisNode, subArea);
//		
//		subArea.applyConvolutionFilter(this, ID_FILTER_CONVOLUTION, (IPixelNode) thisNode, 0.0000001f);
//
//	}	

	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {

//		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
//		
//		int x = ((IPixelNode) sublayerNode).getX();
//		int y = ((IPixelNode) sublayerNode).getY();
//		
//		int centerX = subArea.getNodeCenterXY().getX();
//		int centerY = subArea.getNodeCenterXY().getY();
//		
//		int Xmat = x - centerX + ( (N-1) / 2 );
//		int Ymat = y - centerY + ( (N-1) / 2 );
//		
//		if(Xmat >= 0 && Xmat <= (N-1) && Ymat >= 0 && Ymat <= (N-1)){
//			return InputSample.getInstance().compute(filterFunction) * 10D - 5D;
//		}
		
		return 0D;
	}
	
	public void kernelToImage(Integer scale){
		
		Weight[][] weights = sharedWeights.get(getArea().getIdentification());
		if(weights != null){
		ImageNode img = new ImageNode(EActivation.IDENTITY, weights[0].length, weights.length);
		
		img.getStage().setTitle("Shared weights #"+ getArea().getIdentification() +" : "+ weights[0].length + " x " + weights.length);
		
		if(scale != null && scale > 1)
			img.scaleImage(scale);
		
		img.insertDataArray(weights);
		img.drawImageData(null);
		}else{
			System.out.println("you have to do at least one feed forward propagation to fill ");
		}
	}
	
	public void addGraphicInterface(Pane pane) {
		
		Button showFilterBtn = new Button("show filter");
		
		showFilterBtn.setTooltip(new Tooltip("show filter"));
		
		
		HBox hbox = new HBox();
		hbox.getChildren().addAll(showFilterBtn);
		
		showFilterBtn.setOnAction(new EventHandler<ActionEvent>(){

			@Override
			public void handle(ActionEvent event) {
				try {
					kernelToImage(8);
				} catch (Exception e) {
					e.printStackTrace();
				}
				
			}
			
		});
		
		pane.getChildren().addAll(hbox);
		
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub

	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub

	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub

	}

}
package RN.linkage;

import RN.ILayer;
import RN.nodes.INode;

/**
 * @author Eric Marchand
 *
 */
public class DefaultLinkage extends Linkage {

	public DefaultLinkage(){
		
	}
	
	@Override
	public void initParameters() {
		// TODO Auto-generated method stub

	}

	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode) {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		// TODO Auto-generated method stub

	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub

	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub

	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub

	}

}
package RN.linkage;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Button;
import javafx.scene.control.Slider;
import javafx.scene.control.TextField;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public class DifferenceOfGaussianLinkage extends FilterLinkage {
	
	// GAUSSIENNE ELLIPTIQUE
	private Double mu = null;

	// centre
	private Double x1 = null;
	private Double y1 = null;

	// amplitude, hauteur de la forme pixelisée
	private Double alpha1 = null;
	private Double alpha2 = null;

	// ecartement selon x et y
	private Double ox1 = null;
	private Double oy1 = null;
	
	private Double ox2 = null;
	private Double oy2 = null;
	
	// k un paramètre liant les variances des deux fonctions gaussiennes.
	private Double k0 = null;

	// Interface graphique pour ImageNode
	private  Slider kSlider = null;
	


	public DifferenceOfGaussianLinkage() {
	}
	
	public void initParameters() {
		
//		Le traitement repose sur cinq paramètres :
//		
//			N représente la taille du masque (matrice carrée) implantant le filtre LOG. N est impair.
//			σ permet d'ajuster la taille du chapeau mexicain.
//			∆x et ∆y sont les pas d'échantillonnage utilisés pour discrétiser h''(x,y). Généralement ∆x = ∆ y
//			S est le seuil qui permet de sélectionner les contours les plus marqués.
//		
//			Il est à noter que le choix des paramètres N, σ et ∆x ne doit pas se faire de façon indépendante. 
//  		En effet, le masque, même de taille réduite, doit ressembler à un chapeau mexicain. Le problème ici est le même que celui que l'on rencontre lors de l'échantillonnage d'une fonction gaussienne. 
//          Le nombre de points N à considérer doit être tel que l'étendue occupe l'intervalle [-3σ , 3σ].
//			En fonction du pas d'échantillonnage, l'étendue spatiale vaut : (N-1) ∆x  .
//			Cette étendue peut aussi s'écrire en fonction de σ : (N-1) ∆x = kσ  avec k entier.
//			En prenant par exemple  ∆x = 1 , il s'agit de choisir N et σ de sorte que l'étendue du chapeau mexicain soit pertinente. 
//  		Pour le chapeau mexicain, la valeur de k doit être au moins de 4.
		
		double N = 3;
		double deltaX = 1;
		double k = 4D;
		
		k0 = params[0];
		mu = 0D;
		
		initParametersGaussian1(k0);
		initParametersGaussian2();
		
	}

	private void initParametersGaussian1(Double k1) {
		
		ox1 = 0.5D;
		oy1 = ox1;
		alpha1 = 1D; //2.3D;
		
	}
	
	private void initParametersGaussian2() {
		
		ox2 = 0.5D;
		oy2 = ox2;
		alpha2 = 1D; //2.3D;
		
	}
	
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		// somme des entrees pondérées
		SigmaWi sigmaWI = new SigmaWi();
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
				
		
		initFilter(this, ID_FILTER_DOG_0, ESamples.GAUSSIAN_DE_MARR, (IPixelNode)thisNode, subArea, getMu(), getAlpha1(), getOx1(), getOy1(), getK0());
		initFilter(this, ID_FILTER_DOG_1, ESamples.GAUSSIAN_DE_MARR, (IPixelNode)thisNode, subArea, getMu(), getAlpha2(), getOx2(), getOy2());
		
//			thisNode.getArea().initCompositeFilter(this, ID_FILTER_DOG_0, ESamples.SUBSTRACT, ESamples.GAUSSIAN_DOG_DE_MARR, ESamples.GAUSSIAN_DE_MARR, subArea, getMu(), getAlpha1(), getOx1(), getOy1(), getK0(), getMu(), getAlpha2(), getOx2(), getOy2(), getK1());

		subArea.applyConvolutionCompositeFilter(this, ID_FILTER_DOG_0, ID_FILTER_DOG_1, ESamples.SUBSTRACT, (IPixelNode) thisNode, sigmaWI);
			
		
		return sigmaWI.value();
	}
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();

		initFilter(this, ID_FILTER_DOG_0, ESamples.GAUSSIAN_DE_MARR, (IPixelNode) thisNode, subArea, getMu(), getAlpha1(), getOx1(), getOy1(), getK0());
		initFilter(this, ID_FILTER_DOG_1, ESamples.GAUSSIAN_DE_MARR, (IPixelNode) thisNode, subArea, getMu(), getAlpha2(), getOx2(), getOy2());
		
		//thisNode.getArea().initCompositeFilter(this, ID_FILTER_DOG_0, ESamples.SUBSTRACT, ESamples.GAUSSIAN_DOG_DE_MARR, ESamples.GAUSSIAN_DE_MARR, subArea, getMu(), getAlpha1(), getOx1(), getOy1(), getK0(), getMu(), getAlpha2(), getOx2(), getOy2(), getK1());
		
		
		subArea.applyConvolutionCompositeFilter(this, ID_FILTER_DOG_0, ID_FILTER_DOG_1, ESamples.SUBSTRACT, (IPixelNode) thisNode, 0.001f);
		
	}
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		// Calcul du filtre gaussien
		return params[0] + params[1] * InputSample.getInstance().compute(
				filterFunction, 
				(double) subArea.getWidthPx(),
				(double) subArea.getHeightPx(), 
				(double) sublayerNode.getX(),
				(double) sublayerNode.getY(), 
				(double) subArea.getNodeCenterXY().getX(), 
				(double) subArea.getNodeCenterXY().getY(), 
				params[2], 
				params[3],
				params.length == 5 ? params[4] : null);
	}
	
	

	
	public void addGraphicInterface(Pane pane) {
		
		kSlider = new Slider(-2D, 2D, getK0());
		TextField label0 = new TextField("k=" + getK0());
		//TextField label1 = new TextField("k1=" + getK1());
		TextField sigma1 = new TextField("sigma1=" + getOx1());
		TextField sigma2 = new TextField("sigma2=" + getOx2());
		Button showFilterBtn = new Button("show filter");
		
		HBox hbox = new HBox();
		hbox.getChildren().addAll(kSlider);
		
		HBox hbox1 = new HBox(label0);
		HBox hbox2 = new HBox(sigma1, sigma2);
		HBox hbox3 = new HBox(showFilterBtn);
		
			
			
			showFilterBtn.setTooltip(new Tooltip("show filter"));
			
			
			showFilterBtn.setOnAction(new EventHandler<ActionEvent>(){

				@Override
				public void handle(ActionEvent event) {
					try {
						//FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_CONVOLUTION);
						((IAreaSquare)thisArea).getFilter(FilterLinkage.ID_FILTER_DOG_0).filterToImage(8);
						((IAreaSquare)thisArea).getFilter(FilterLinkage.ID_FILTER_DOG_1).filterToImage(8);
						//thisArea.showImageArea();
					} catch (Exception e) {
						e.printStackTrace();
					}
					
				}
				
			});
			

		pane.getChildren().addAll(hbox, hbox1, hbox2, hbox3);

		kSlider.setBlockIncrement(0.1);
		kSlider.valueProperty().addListener(new ChangeListener<Number>() {
			public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
//				if(new_val != old_val){
//					try {
//						setK0(new_val.doubleValue());
//						initParametersGaussian1(getK0());
//						sigma1.setText("sigma1=" + getOx1());
//						label0.setText(new_val.toString());
//						FilterLinkage.removeFilter(new FilterIndex(ID_FILTER_DOG_0));
//						getArea().setFilter(ID_FILTER_DOG_1, null);
//						for (INode node : getArea().getNodes()) {
//							node.computeOutput(false);
//						}
//						getArea().showImageArea();
//						System.out.println("k: " +getK0());
//					} catch (Exception e) {
//						e.printStackTrace();
//					}
//				}
			}
		});
	}


	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	public Double getK0() {
		return k0;
	}

	public void setK0(Double k) {
		this.k0 = k;
	}
	

	public Double getMu() {
		return mu;
	}

	public void setMu(Double mu) {
		this.mu = mu;
	}

	public Double getAlpha1() {
		return alpha1;
	}

	public void setAlpha1(Double alpha1) {
		this.alpha1 = alpha1;
	}

	public Double getAlpha2() {
		return alpha2;
	}

	public void setAlpha2(Double alpha2) {
		this.alpha2 = alpha2;
	}

	public Double getOx1() {
		return ox1;
	}

	public void setOx1(Double ox1) {
		this.ox1 = ox1;
	}

	public Double getOy1() {
		return oy1;
	}

	public void setOy1(Double oy1) {
		this.oy1 = oy1;
	}

	public Double getOx2() {
		return ox2;
	}

	public void setOx2(Double ox2) {
		this.ox2 = ox2;
	}

	public Double getOy2() {
		return oy2;
	}

	public void setOy2(Double oy2) {
		this.oy2 = oy2;
	}

	public Slider getkSlider() {
		return kSlider;
	}

	public void setkSlider(Slider kSlider) {
		this.kSlider = kSlider;
	}


}
package RN.linkage;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.nodes.INode;
import RN.nodes.IPixelNode;

/**
 * @author Eric Marchand
 *
 */
public class DOGStaticLinkage extends DifferenceOfGaussianLinkage {

	
	// Matrice carrée d'ordre N
	private static int N = 7;
	
	private static Double[][] staticFilter = new Double[][]{
																{0D,  0D,  1D,  1D,  1D,  0D,  0D},
																{0D,  1D,  1D,  1D,  1D,  1D,  0D},
																{1D,  1D, -1D, -4D, -1D,  1D,  1D},
																{1D,  1D, -4D, -8D, -4D,  1D,  1D},
																{1D,  1D, -1D, -4D, -1D,  1D,  1D},
																{0D,  1D,  1D,  1D,  1D,  1D,  0D},
																{0D,  0D,  1D,  1D,  1D,  0D,  0D},
	};
	

	public DOGStaticLinkage() {
	}
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		// somme des entrees pondérées
		SigmaWi sigmaWI = new SigmaWi();
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();

		initFilter(this, ID_FILTER_DOG_STATIC, null, (IPixelNode) thisNode, subArea);
			
		subArea.applyConvolutionFilter(this, ID_FILTER_DOG_STATIC, (IPixelNode) thisNode, sigmaWI);
			
		return sigmaWI.value();
	}
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();

		initFilter(this, ID_FILTER_DOG_STATIC, null, (IPixelNode) thisNode, subArea);
		
		subArea.applyConvolutionFilter(this, ID_FILTER_DOG_STATIC, (IPixelNode) thisNode, 0.001f);
	}
	
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double mu, Double alpha, Double ox, Double oy) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		int x = sublayerNode.getX();
		int y = sublayerNode.getY();
		
		int centerX = subArea.getNodeCenterXY().getX();
		int centerY = subArea.getNodeCenterXY().getY();
		
		int Xmat = x - centerX + ( (N-1) / 2 );
		int Ymat = y - centerY + ( (N-1) / 2 );
		
		if(Xmat >= 0 && Xmat <= (N-1) && Ymat >= 0 && Ymat <= (N-1)){
			return staticFilter[Xmat][Ymat];
		}
		
		return 0D;
	}
	
}
package RN.linkage;

/**
 * @author Eric Marchand
 *
 */
public enum EFilterPosition {
	
	CENTER,
	TOP_LEFT;

}
package RN.linkage;

/**
 * @author Eric Marchand
 *
 */
public enum ELinkage {
	
	ONE_TO_ONE("RN.linkage.OneToOneLinkage"),
	ONE_TO_ONE_FILTER("RN.linkage.OneToOneFilterLinkage"),
	//ONE_TO_ONE_FETCH_AREA("RN.linkage.OneToOneFetchAreaLinkage"),
	ONE_TO_ONE_FETCH_OCTAVE_AREA("RN.linkage.OneToOneFetchOctaveAreaLinkage"),
	ONE_TO_ONE_OCTAVE("RN.linkage.OneToOneOctaveAreaLinkage"),
	MANY_TO_MANY("RN.linkage.FullFanOutLinkage"),
	MANY_TO_MANY_INTRA_AREA("RN.linkage.FullFanOutLinkageIntraArea"),
	MANY_TO_MANY_OCTAVE("RN.linkage.FullFanOutOctaveAreaLinkage"),
	FIRST_DERIVATED_GAUSSIAN("RN.linkage.FirstDerivatedGaussianLinkage"),
	SIMPLE_CONTOUR("RN.linkage.ContourLinkage"), 
	DOG("RN.linkage.DifferenceOfGaussianLinkage"),
	DOG_STATIC("RN.linkage.DOGStaticLinkage"),
	SONAG("RN.linkage.SumOfNegativeAndGaussianLinkage"),
	LOG("RN.linkage.LaplacianOfGaussianLinkage"),
	LOG_STATIC("RN.linkage.LOGStaticLinkage"),
	GAUSSIAN("RN.linkage.GaussianLinkage"),
	HESSIAN_COURBURE("RN.linkage.HessianCourbureLinkage"),
	GENERIC("RN.linkage.GenericFilterLinkage"),
	MAX_POOLING("RN.linkage.MaxPoolingLinkage"),
	MAX("RN.linkage.MaxLinkage"),
	MAP("RN.linkage.MapLinkage"),
	SAMPLING("RN.linkage.SamplingLinkage"),
	CONVOLUTION("RN.linkage.ConvolutionLinkage"),
	SUBSAMPLING("RN.linkage.SubsamplingLinkage"),
	
	// Vision
	BIPOLAR("RN.linkage.vision.BiPolarCellLinkage"),
	GANGLIONARY("RN.linkage.vision.GanglionaryCellLinkage"), 
	V1_ORIENTATIONS("RN.linkage.vision.V1OrientationsCellLinkage"),
	LOG_GABOR("RN.linkage.GaborLogLinkage"),
	LOG_GABOR2("RN.linkage.GaborLogLinkage2"),
	LOG_POLAR("RN.linkage.LogPolarLinkage"),
	CARTESIAN_TO_POLAR("RN.linkage.CartesianToPolarImageLinkage"),
	CARTESIAN_TO_LOG_POLAR("RN.linkage.CartesianToLogPolarImageLinkage")
	;
	
	String classPath = null;
	
	ELinkage(String classPath){
		this.classPath = classPath;
	}

	public String getClassPath() {
		return classPath;
	}

	public void setClassPath(String classPath) {
		this.classPath = classPath;
	}


}
package RN.linkage;

/**
 * @author Eric Marchand
 *
 */
public enum ELinkageBetweenAreas {
	
	// DEFAULT MAPPING
	// layer[m].area[n0] <---> layer[m+1].area[n]  : with n0 a constant = {LINKAGETARGETEDAREA else 0}
	ONE_TO_MANY, 
	
	
	// layer[m].area[n] <---> layer[m+1].area[n]
	ONE_TO_ONE,
	
	
	// layer[m].area[n] <---> layer[m+1].area[n0] : with n0 a constant = {LINKAGETARGETEDAREA else 0}
	MANY_TO_ONE;

}
package RN.linkage;

import java.util.Arrays;
import java.util.Map.Entry;

import RN.NetworkElement;
import RN.algoactivations.EActivation;
import RN.dataset.inputsamples.ESamples;
import RN.linkage.FilterLinkage.FilterIndex;
import RN.nodes.ImageNode;

/**
 * @author Eric Marchand
 *
 */
public class Filter extends NetworkElement{
	
	private Integer id = null;
	
	private ESamples filterFunction = null;
	
	private Double[][] values = null;
	
	private Double[] parameters = null;
	
	private Integer width = null;
	
	private Integer height = null;
	
	private int maxX = 0;
	
	private int minX = 0;
	
	private int maxY = 0;
	
	private int minY = 0;
	
	public Filter(int id, ESamples filterFunction, Double[][] values, Double... parameters){
		this.id = id;
		this.filterFunction = filterFunction;
		this.values = values;
		this.parameters = parameters;
		this.minX = values.length;
		this.minY = values[0].length;
		this.width = values.length;
		this.height = values[0].length;
	}
	
	public Filter(int id, Double[][] values, Double... parameters){
		this.id = id;
		this.values = values;
		this.parameters = parameters;
		this.minX = values.length;
		this.minY = values[0].length;
		this.width = values.length;
		this.height = values[0].length;
	}

	public int getLength(){
		return this.values.length;
	}
	
	public Double getValue(int x, int y){
		return this.values[x][y];
	}
	
	public void filterToImage(Integer scale){
		
		ImageNode img = new ImageNode(EActivation.IDENTITY, width, height);
		
		img.getStage().setTitle("Filtre #"+ id +" : "+ height + " x " + width + "  params="+ Arrays.deepToString(parameters));
		
		if(scale != null && scale > 1)
			img.scaleImage(scale);
		
		img.insertDataFilter(this);
		img.drawImageData(null);
	}
	
	
	public void filterToString(){
		
		
		System.out.println("Filtre #"+ id +" : "+ height + " x " + width + "  params="+ Arrays.deepToString(parameters));
		
		for (int idy = 0; idy < height; idy++) {
			for (int idx = 0; idx < width; idx++) {
				Double value = values[idx][idy];
				if(value == null || value == 0D)
					System.out.print(" . ");
				else if(value < 0D)
					System.out.printf(" %.2f ", value);
				else
					System.out.printf(" %.2f ", value);
				
				System.out.print("\t");
			}
			System.out.print("\n");
		}
			
	}



	public Integer getId() {
		return id;
	}



	public void setId(Integer id) {
		this.id = id;
	}



	public ESamples getFilterFunction() {
		return filterFunction;
	}



	public void setFilterFunction(ESamples filterFunction) {
		this.filterFunction = filterFunction;
	}



	public Double[][] getValues() {
		return values;
	}



	public void setValues(Double[][] values) {
		this.values = values;
	}
	
	public void setValue(int x, int y, Double value) {
		
		if(value != 0D){
			
			if(x < minX)
				minX = x;
			
			if(x > maxX)
				maxX = x;
			
			if(y < minY)
				minY = y;
			
			if(y > maxY)
				maxY = y;
		}
		
		this.values[x][y] = value;
	}



	public Double[] getParameters() {
		return parameters;
	}



	public void setParameters(Double[] parameters) {
		this.parameters = parameters;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((filterFunction == null) ? 0 : filterFunction.hashCode());
		result = prime * result + Arrays.hashCode(parameters);
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Filter other = (Filter) obj;
		if (filterFunction != other.filterFunction)
			return false;
		if (!Arrays.equals(parameters, other.parameters))
			return false;
		return true;
	}
	

	public static Filter returnExistingFilter(ESamples filterFunction2, Double[] params) {
		
			for(Entry<FilterIndex, Filter> entry : FilterLinkage.getFilters().entrySet()){
				Filter filter = entry.getValue();
				FilterIndex idx = entry.getKey();
				if(filterFunction2 != ESamples.RAND && filter.getFilterFunction() == filterFunction2 && Arrays.equals(filter.getParameters(), params)){
					System.out.println("Layer : " + idx.getId().getLayerId() + "  Area : " + idx.getId().getAreaId() +"  Filter : " + filter.id + "  " + filter.filterFunction + " réutilisé . " + Arrays.deepToString(params) + "  =  " + Arrays.deepToString(filter.getParameters()));
					return filter;
				}
			}
		return null;
	}

	public void resizeFilter() {
		
		int newWidth = maxX - minX + 1;
		int newHeight = maxY - minY + 1;
		
		if(newWidth <= 0 || newHeight <= 0){
			this.width = 0;
			this.height = 0;
			return;
		}
		
		Double[][] newValues = new Double[newWidth][newHeight];
		
		for(int idy = minY; idy <= maxY; idy++){
			for(int idx = minX; idx <= maxX; idx++){
				newValues[idx-minX][idy-minY] = values[idx][idy];
			}
			
		}
		
		this.values = newValues;
		this.width = newWidth;
		this.height = newHeight;
		
	}

	public Integer getWidth() {
		return width;
	}

	public void setWidth(Integer width) {
		this.width = width;
	}

	public Integer getHeight() {
		return height;
	}

	public void setHeight(Integer height) {
		this.height = height;
	}

}
package RN.linkage;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import RN.IAreaSquare;
import RN.ILayer;
import RN.Identification;
import RN.dataset.inputsamples.ESamples;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import RN.nodes.PixelNode;

/**
 * @author Eric Marchand
 *
 */
public abstract class FilterLinkage extends Linkage implements IFilterLinkage{
	
	public static class FilterIndex {
		private Identification id = null;
		private Integer idFilter = null;
		public FilterIndex(Identification id, Integer idFilter){
			this.id = id;
			this.idFilter = idFilter;
		}
		public Identification getId() {
			return id;
		}
		public void setId(Identification id) {
			this.id = id;
		}
		public Integer getIdFilter() {
			return idFilter;
		}
		public void setIdFilter(Integer idFilter) {
			this.idFilter = idFilter;
		}
		@Override
		public int hashCode() {
			final int prime = 31;
			int result = 1;
			result = prime * result + ((id == null) ? 0 : id.hashCode());
			result = prime * result + ((idFilter == null) ? 0 : idFilter.hashCode());
			return result;
		}
		@Override
		public boolean equals(Object obj) {
			if (this == obj)
				return true;
			if (obj == null)
				return false;
			if (getClass() != obj.getClass())
				return false;
			FilterIndex other = (FilterIndex) obj;
			if (id == null) {
				if (other.id != null)
					return false;
			} else if (!id.equals(other.id))
				return false;
			if (idFilter == null) {
				if (other.idFilter != null)
					return false;
			} else if (!idFilter.equals(other.idFilter))
				return false;
			return true;
		}
	}
	
	// Tableau de filtres, matrices de dimension impaire.
	private final static Map<FilterIndex, Filter> filters = new HashMap<FilterIndex, Filter>();

	public final static int ID_FILTER_V1Orientation = 0;
	public final static int ID_FILTER_DOG_0 = 1;
	public final static int ID_FILTER_DOG_1 = 2;
	public final static int ID_FILTER_DOG_STATIC = 3;
	public final static int ID_FILTER_FIRST_DERIVATED_GAUSSIAN = 4;
	public final static int ID_FILTER_GAUSSIAN = 5;
	public final static int ID_FILTER_LOG = 6;
	public final static int ID_FILTER_LOG_STATIC = 7;
	public final static int ID_FILTER_GENERIC = 8;
	public final static int ID_FILTER_Gxx = 9;
	public final static int ID_FILTER_Gyy = 10;
	public final static int ID_FILTER_Gxy = 11;
	public final static int ID_FILTER_SAMPLING_2 = 12;
	public final static int ID_FILTER_SONAG = 13;
	public final static int ID_FILTER_MAX_POOLING = 14;
	public final static int ID_FILTER_GABOR_LOG = 15;
	public final static int ID_FILTER_CONVOLUTION = 16;
	
	protected ESamples eSampleFunction = null;
	
	@Override
	public abstract void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) ;
	
	@Override
	public abstract void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT);

	@Override
	public abstract void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer);

	@Override
	public abstract void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT);
	
	
	public Double processFilter(ESamples filterFunction, IAreaSquare subArea, IPixelNode sublayerNode){
		throw new RuntimeException("Filtre absent");
	}
	
	public Double processFilter(ESamples filterFunction, IAreaSquare subArea, IPixelNode sublayerNode, Double... params){
		throw new RuntimeException("Filtre absent");
	}

	public void setESampleFunction(ESamples eSampleFunction){
		this.eSampleFunction = eSampleFunction;
	}
	
	public Filter getFilter(FilterIndex idFilter) {
		return filters.get(idFilter);
	}
	
	public static Map<FilterIndex, Filter> getFilters() {
		return filters;
	}
	

	public void setFilter(FilterIndex idx, Filter filter) {
		this.filters.put(idx, filter);
	}
	
	public static void removeFilter(FilterIndex idx){
		filters.remove(idx);
	}
	
	public void initFilter(IFilterLinkage linkage, int idFilter, ESamples filterFunction, IPixelNode thisNode, IAreaSquare subArea, Double... params) {
		initFilter(linkage, idFilter, filterFunction, 0.001D, thisNode, subArea, params);
	}
	
	
	public void initFilter(IFilterLinkage linkage, int idFilter, ESamples filterFunction, Double cacheSensibility, IPixelNode thisNode, IAreaSquare subArea, Double... params) {
		
		
		FilterIndex idx = new FilterIndex(thisNode.getAreaSquare().getIdentification(), idFilter);
		
		if (this.getFilter(idx) == null) {
			
			Filter existingFilter = Filter.returnExistingFilter(filterFunction, params);
			Filter filter = null;
			if(existingFilter == null){
				
				filter = new Filter(idFilter, filterFunction, new Double[subArea.getWidthPx()][subArea.getHeightPx()], params);
				
				double filterValue = 0D;
				
				List<INode> nodeList = subArea.getNodes();
				INode sublayerNode = null;
				for (int index = 0; index < nodeList.size(); index++) {
					
					sublayerNode = nodeList.get(index);
					
					filterValue = linkage.processFilter(filterFunction, (IPixelNode) sublayerNode, params);

					// Ajout des valeurs discretes du filtre dans le cache
					if (Math.abs(filterValue) >= cacheSensibility) {
						filter.setValue(((PixelNode) sublayerNode).getX(), ((PixelNode) sublayerNode).getY(), filterValue);
					}else{
						filter.setValue(((PixelNode) sublayerNode).getX(), ((PixelNode) sublayerNode).getY(), 0D);
					}
				}
				
				filter.resizeFilter();
				
				this.setFilter(idx,  filter);
				
			}else{
				
				this.setFilter(idx,  existingFilter);
				
			}

			this.getFilter(idx).filterToString();
		}
		
	}
	
	public void initFilter(IFilterLinkage linkage, int idFilter, IPixelNode thisNode, int width, int height, float[] values, Double... params) {
		
		
		FilterIndex idx = new FilterIndex(thisNode.getAreaSquare().getIdentification(), idFilter);
		
		if (this.getFilter(idx) == null) {
			
			Filter existingFilter = Filter.returnExistingFilter(ESamples.NONE, params);
			Filter filter = null;
			if(existingFilter == null){
				
				filter = new Filter(idFilter, ESamples.NONE, new Double[width][height], params);
				
				for(int i=0; i < width; i++){
					for(int j=0; j < height; j++){
						filter.setValue(i, j, (double) values[i * j + j]);
					}
				}
				
				
				filter.resizeFilter();
				
				this.setFilter(idx,  filter);
				
			}else{
				
				this.setFilter(idx,  existingFilter);
				
			}

			this.getFilter(idx).filterToString();
		}
		
	}
	
	public void initFilter(IFilterLinkage linkage, int idFilter, IPixelNode thisNode, int width, int height, Double[][] values, Double... params) {
		
		
		FilterIndex idx = new FilterIndex(thisNode.getAreaSquare().getIdentification(), idFilter);
		
		if (this.getFilter(idx) == null) {
			
			Filter existingFilter = Filter.returnExistingFilter(ESamples.NONE, params);
			Filter filter = null;
			if(existingFilter == null){
				
				filter = new Filter(idFilter, ESamples.NONE, new Double[width][height], params);
				
				for(int i=0; i < values.length; i++){
					for(int j=0; j < values[i].length; j++){
						filter.setValue(i, j, values[i][j]);
					}
				}
				
				
				filter.resizeFilter();
				
				this.setFilter(idx,  filter);
				
			}else{
				
				this.setFilter(idx,  existingFilter);
				
			}

			this.getFilter(idx).filterToString();
		}
		
	}
	
	public void initCompositeFilter(IFilterLinkage linkage, int idFilter, ESamples op, ESamples filterFunction, ESamples filter2Function, IPixelNode thisNode, List<IPixelNode> subNodes, Double... params) {
		
		FilterIndex idx = new FilterIndex(thisNode.getAreaSquare().getIdentification(), idFilter);
		
		if (this.getFilter(idx) == null) {
			
			Double[] params0 = Arrays.copyOfRange(params, 0, (params.length / 2));
			Double[] params1 = Arrays.copyOfRange(params, (params.length / 2), params.length);
			
			Filter existingFilter = Filter.returnExistingFilter(filterFunction, params0);
			Filter existingFilter2 = Filter.returnExistingFilter(filter2Function, params1);
			Filter filter = null;
			if(existingFilter == null || existingFilter2 == null){
				
				IAreaSquare area = subNodes.get(0).getAreaSquare();
				
				filter = new Filter(idFilter, filterFunction, new Double[area.getWidthPx()][area.getHeightPx()], params);
				
				double filterValue = 0D;
				double filterValue0 = 0D;
				double filterValue1 = 0D;
				
				
				IPixelNode sublayerNode = null;
				for (int index = 0; index < subNodes.size(); index++) {
					
					sublayerNode = subNodes.get(index);

					if(existingFilter == null){
						filterValue0 = linkage.processFilter(filterFunction, sublayerNode, params0);
					}else{
						filterValue0 = existingFilter.getValue(((PixelNode) sublayerNode).getX(), ((PixelNode) sublayerNode).getY());
					}
					
					if(existingFilter2 == null){
						filterValue1 = linkage.processFilter(filter2Function, sublayerNode, params1);
					}else{
						filterValue1 = existingFilter2.getValue(((PixelNode) sublayerNode).getX(), ((PixelNode) sublayerNode).getY());
					}
					
					
					if(op == ESamples.SUBSTRACT)
						filterValue =  filterValue0 - filterValue1;
					else if(op == ESamples.ADD)
						filterValue = filterValue0 + filterValue1;

					// Ajout des valeurs discretes du filtre dans le cache
					if (Math.abs(filterValue) >= 0.0001D) {
						filter.setValue(((PixelNode) sublayerNode).getX(), ((PixelNode) sublayerNode).getY(), filterValue);
					}else{
						filter.setValue(((PixelNode) sublayerNode).getX(), ((PixelNode) sublayerNode).getY(), 0D);
					}
				}
				
				
				this.setFilter(idx,  filter);
				
			}else{
				this.setFilter(idx,  existingFilter);
			}
			
			
			//filterToString(idFilter);
		}
		
	}
	
	
	public Double getFilterValue(FilterIndex index, EFilterPosition filterPosition, IPixelNode thisNode, IPixelNode sourceNode) {
		
		
		int filterWidth = this.getFilter(index).getWidth();
		int filterHeight = this.getFilter(index).getHeight();
		
		int sourceX;
		int sourceY;
		if(sampling != null && sampling != 1){
			sourceX = ((PixelNode) sourceNode).getX() / sampling;
			sourceY = ((PixelNode) sourceNode).getY() / sampling;
		}else{
			sourceX = ((PixelNode) sourceNode).getX();
			sourceY = ((PixelNode) sourceNode).getY();
		}
		
		int targetX = ((PixelNode) thisNode).getX();
		int targetY = ((PixelNode) thisNode).getY();
		
		
		int valueX = -1;
		int valueY = -1;
		if(filterPosition == EFilterPosition.CENTER){
		 
			valueX =  targetX + ((filterWidth - 1) / 2) - sourceX;
			valueY =  targetY + ((filterHeight - 1) / 2) - sourceY;
		
		}else if(filterPosition == EFilterPosition.TOP_LEFT){
			
			 valueX =  sourceX - targetX;
			 valueY =  sourceY - targetY;
		}
		
		
		if(valueX >= 0D && valueX < filterWidth && valueY >= 0D && valueY < filterHeight){
			return this.getFilter(index).getValue(valueX, valueY);
		}
		
		return 0D;
			
	}
	
	

	
}
package RN.linkage;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Button;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public class FirstDerivatedGaussianLinkage extends FilterLinkage {
	
	// GAUSSIENNE ELLIPTIQUE
	private Double mu = null;

	// centre
	private Double x1 = null;
	private Double y1 = null;

	// amplitude, hauteur de la forme pixelisée
	private Double alpha = null;

	// ecartement selon x et y
	private Double ox = null;
	private Double oy = null;

	

	public FirstDerivatedGaussianLinkage() {
	}
	
	public void initParameters() {
		
//		Le traitement repose sur cinq paramètres :
//		
//			N représente la taille du masque (matrice carrée) implantant le filtre LOG. N est impair.
//			σ permet d'ajuster la taille du chapeau mexicain.
//			∆x et ∆y sont les pas d'échantillonnage utilisés pour discrétiser h''(x,y). Généralement ∆x = ∆ y
//			S est le seuil qui permet de sélectionner les contours les plus marqués.
//		
//			Il est à noter que le choix des paramètres N, σ et ∆x ne doit pas se faire de façon indépendante. 
//  		En effet, le masque, même de taille réduite, doit ressembler à un chapeau mexicain. Le problème ici est le même que celui que l'on rencontre lors de l'échantillonnage d'une fonction gaussienne. 
//          Le nombre de points N à considérer doit être tel que l'étendue occupe l'intervalle [-3σ , 3σ].
//			En fonction du pas d'échantillonnage, l'étendue spatiale vaut : (N-1) ∆x  .
//			Cette étendue peut aussi s'écrire en fonction de σ : (N-1) ∆x = kσ  avec k entier.
//			En prenant par exemple  ∆x = 1 , il s'agit de choisir N et σ de sorte que l'étendue du chapeau mexicain soit pertinente. 
//  		Pour le chapeau mexicain, la valeur de k doit être au moins de 4.
		
		double N = 3;
		double deltaX = 1;
		double k = 4D;
		
		ox = (N-1) * deltaX / k;
		oy = ox;
		alpha = 1D;
		mu = 0D;
		
	}
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		// somme des entrees pondérées
		SigmaWi sigmaWI = new SigmaWi();
				
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
	
		initFilter(this, ID_FILTER_FIRST_DERIVATED_GAUSSIAN, ESamples.G_Dxy_DE_MARR, (IPixelNode) thisNode, subArea);
	
		subArea.applyConvolutionFilter(this, ID_FILTER_FIRST_DERIVATED_GAUSSIAN, (IPixelNode) thisNode, sigmaWI);

		
		return sigmaWI.value();
	}
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer previousLayer) {
		
			
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		initFilter(this, ID_FILTER_FIRST_DERIVATED_GAUSSIAN, ESamples.G_Dxy_DE_MARR, (IPixelNode)thisNode, subArea);
		
		subArea.applyConvolutionFilter(this, ID_FILTER_FIRST_DERIVATED_GAUSSIAN, (IPixelNode)thisNode, 0.0001f);

	}
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		// Calcul du filtre gaussien
		return mu + alpha * InputSample.getInstance().compute(
				filterFunction, 
				(double) subArea.getWidthPx(),
				(double) subArea.getHeightPx(), 
				(double) sublayerNode.getX(),
				(double) sublayerNode.getY(), 
				(double) subArea.getNodeCenterXY().getX(), 
				(double) subArea.getNodeCenterXY().getY(), 
				ox, 
				oy);
	}
	
	public void addGraphicInterface(Pane pane) {
		
		Button showFilterBtn = new Button("show filter");
		
		showFilterBtn.setTooltip(new Tooltip("show filter"));
		
		
		HBox hbox = new HBox();
		hbox.getChildren().addAll(showFilterBtn);
		
		showFilterBtn.setOnAction(new EventHandler<ActionEvent>(){

			@Override
			public void handle(ActionEvent event) {
				try {
					//FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_CONVOLUTION);
					((IAreaSquare)thisArea).getFilter(ID_FILTER_FIRST_DERIVATED_GAUSSIAN).filterToImage(8);
					//thisArea.showImageArea();
				} catch (Exception e) {
					e.printStackTrace();
				}
				
			}
			
		});
		
		pane.getChildren().addAll(hbox);
		
		
		
	}
	
	
	

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

}
package RN.linkage;

import RN.IArea;
import RN.ILayer;
import RN.links.ELinkType;
import RN.links.Link;
import RN.nodes.INode;

/**
 * @author Eric Marchand
 *
 */
public class FullFanOutLinkage extends Linkage implements ILinkage {

	
	
	public FullFanOutLinkage() {
	}
	
	
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		Double sigmaWI = 0D;
		
			
		for(IArea area : getLinkedAreas()){
			for (INode sourceNode : area.getNodes()) {
				//if(getContext().getClock() == -1 || input.getFireTimeT() == getContext().getClock()){
					sigmaWI += sourceNode.getComputedOutput() * getLinkAndPutIfAbsent(thisNode, sourceNode, isWeightModifiable()).getWeight();
					//input.synchFutureFire();
				//}
				
			}
		}
		
		sigmaWI -= thisNode.getBiasWeightValue();
			
		
		
		return sigmaWI;
	}
	
	
	
	/* (non-Javadoc)
	 * @see RN.linkage.ILinkage#sublayerFanOutLinkage(RN.Layer)
	 */
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer){
		
		for(IArea area : getLinkedAreas()){
			for (INode node : area.getNodes()) {
				
					node.link(thisNode, ELinkType.REGULAR, isWeightModifiable());
			}
		}
	}
	
	/* (non-Javadoc)
	 * @see RN.linkage.ILinkage#sublayerFanOutLinkage(RN.Layer, long)
	 */
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT){
		
		for(IArea area : getLinkedAreas()){
			for (INode node : area.getNodes()) {
				
					node.link(thisNode, ELinkType.REGULAR, isWeightModifiable()).setFireTimeT(initFireTimeT);
			}
		}
		
	}
	
	/* (non-Javadoc)
	 * @see RN.linkage.ILinkage#nextLayerFanOutLinkage(RN.Layer)
	 */
	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer){
		
		IArea nextArea = nextlayer.getArea(thisNode.getArea().getAreaId());
		
		for (INode node : nextArea.getNodes()) {
				Link link = thisNode.link(node, ELinkType.REGULAR, isWeightModifiable());
				node.link(thisNode, ELinkType.REGULAR, isWeightModifiable());
				node.getInputs().add(link);
		}
	}
	
	/* (non-Javadoc)
	 * @see RN.linkage.ILinkage#nextLayerFanOutLinkage(RN.Layer, long)
	 */
	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT){
		
		IArea nextArea = nextlayer.getArea(thisNode.getArea().getAreaId());
		
		for (INode node : nextArea.getNodes()) {
				Link link = thisNode.link(node, ELinkType.REGULAR, isWeightModifiable());
				node.link(thisNode, ELinkType.REGULAR, isWeightModifiable()).setFireTimeT(initFireTimeT);
				node.getInputs().add(link);
		}
		
	}

	@Override
	public void initParameters() {
		// TODO Auto-generated method stub
		
	}



	
	
	
}
package RN.linkage;

import RN.IArea;
import RN.ILayer;
import RN.links.ELinkType;
import RN.links.Link;
import RN.nodes.INode;

/**
 * @author Eric Marchand
 *
 */
public class FullFanOutLinkageIntraArea extends Linkage implements ILinkage {

	
	
	public FullFanOutLinkageIntraArea() {
	}
	
	
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		Double sigmaWI = 0D;
		
		IArea subArea = getLinkedArea();
		for (INode sourceNode : subArea.getNodes()) {
			//if(getContext().getClock() == -1 || input.getFireTimeT() == getContext().getClock()){
				sigmaWI += sourceNode.getComputedOutput() * getLinkAndPutIfAbsent(thisNode, sourceNode, isWeightModifiable()).getWeight();
				//input.synchFutureFire();
			//}
			
		}
			
		sigmaWI -= thisNode.getBiasWeightValue();
			
		
		
		return sigmaWI;
	}
	
	
	
	/* (non-Javadoc)
	 * @see RN.linkage.ILinkage#sublayerFanOutLinkage(RN.Layer)
	 */
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer previousLayer){
		
		IArea subArea = getLinkedArea();
		for (INode node : subArea.getNodes()) {
			
				node.link(thisNode, ELinkType.REGULAR, isWeightModifiable());
		}
	}
	
	/* (non-Javadoc)
	 * @see RN.linkage.ILinkage#sublayerFanOutLinkage(RN.Layer, long)
	 */
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT){
		
		for(IArea area : sublayer.getAreas()){
		for (INode node : area.getNodes()) {
			
				node.link(thisNode, ELinkType.REGULAR, isWeightModifiable()).setFireTimeT(initFireTimeT);
		}
		}
		
	}
	
	/* (non-Javadoc)
	 * @see RN.linkage.ILinkage#nextLayerFanOutLinkage(RN.Layer)
	 */
	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer){
		
		IArea nextArea = nextlayer.getArea(thisNode.getArea().getAreaId());
		
		for (INode node : nextArea.getNodes()) {
				Link link = thisNode.link(node, ELinkType.REGULAR, isWeightModifiable());
				node.link(thisNode, ELinkType.REGULAR, isWeightModifiable());
				node.getInputs().add(link);
		}
	}
	
	/* (non-Javadoc)
	 * @see RN.linkage.ILinkage#nextLayerFanOutLinkage(RN.Layer, long)
	 */
	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT){
		
		IArea nextArea = nextlayer.getArea(thisNode.getArea().getAreaId());
		
		for (INode node : nextArea.getNodes()) {
				Link link = thisNode.link(node, ELinkType.REGULAR, isWeightModifiable());
				node.link(thisNode, ELinkType.REGULAR, isWeightModifiable()).setFireTimeT(initFireTimeT);
				node.getInputs().add(link);
		}
		
	}

	@Override
	public void initParameters() {
		// TODO Auto-generated method stub
		
	}



	
	
	
}
package RN.linkage;

import RN.IArea;
import RN.IAreaSquare;
import RN.ILayer;
import RN.linkage.vision.KeyPoint;
import RN.links.ELinkType;
import RN.links.Link;
import RN.nodes.INode;
import RN.nodes.IPixelNode;

/**
 * @author Eric Marchand
 *
 */
public class FullFanOutOctaveAreaLinkage extends Linkage implements ILinkage {

	
	
	public FullFanOutOctaveAreaLinkage() {
	}
	
	
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		Double sigmaWI = 0D;
		Double angleMin = null;
		Double delta = (2D * Math.PI) / 9D;
		
		for(IArea area : getLinkedAreas()){
			
			OneToOneOctaveAreaLinkage linkage = (OneToOneOctaveAreaLinkage) area.getLinkage();
			IPixelNode sourceNode = null;
			
			angleMin = thisNode.getArea().getAreaId() * delta;
			
			Double magnitudeSum = null;
			Link link = null;
			
			for(KeyPoint kp : linkage.getKeyPoints()){
				
				if( kp.getX().intValue() / 4 == ((IPixelNode) thisNode).getX() && kp.getY().intValue() / 4 == ((IPixelNode) thisNode).getY()){
					
					sourceNode = ((IAreaSquare) area).getNodeXY(kp.getX().intValue(), kp.getY().intValue());
					magnitudeSum = kp.getMagnitudeSumByThetaRange(angleMin, delta);
					
					if(Math.abs(magnitudeSum) > 0D){
						link = Linkage.getLinkAndPutIfAbsent(thisNode, (INode) sourceNode, isWeightModifiable());
						sigmaWI += magnitudeSum * link.getWeight();
					}
				}
			}
			
		}
		
		if(thisNode.getBiasWeightValue() != null)
			sigmaWI -= thisNode.getBiasWeightValue();
		
		return sigmaWI;
	}
	
	
	
	/* (non-Javadoc)
	 * @see RN.linkage.ILinkage#sublayerFanOutLinkage(RN.Layer)
	 */
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer previousLayer){
		
		for (INode node : getLinkedArea().getNodes()) {
			
				node.link(thisNode, ELinkType.REGULAR, isWeightModifiable());
		}
	}
	
	/* (non-Javadoc)
	 * @see RN.linkage.ILinkage#sublayerFanOutLinkage(RN.Layer, long)
	 */
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT){
		
		for (IArea area : sublayer.getAreas()) {
			for (INode node : area.getNodes()) {

				node.link(thisNode, ELinkType.REGULAR, isWeightModifiable()).setFireTimeT(initFireTimeT);
			}
		}
		
	}
	
	/* (non-Javadoc)
	 * @see RN.linkage.ILinkage#nextLayerFanOutLinkage(RN.Layer)
	 */
	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer){
		
		IArea nextArea = nextlayer.getArea(thisNode.getArea().getAreaId());
		
		for (INode node : nextArea.getNodes()) {
				Link link = thisNode.link(node, ELinkType.REGULAR, isWeightModifiable());
				node.link(thisNode, ELinkType.REGULAR, isWeightModifiable());
				node.getInputs().add(link);
		}
	}
	
	/* (non-Javadoc)
	 * @see RN.linkage.ILinkage#nextLayerFanOutLinkage(RN.Layer, long)
	 */
	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT){
		
		IArea nextArea = nextlayer.getArea(thisNode.getArea().getAreaId());
		
		for (INode node : nextArea.getNodes()) {
				Link link = thisNode.link(node, ELinkType.REGULAR, isWeightModifiable());
				node.link(thisNode, ELinkType.REGULAR, isWeightModifiable()).setFireTimeT(initFireTimeT);
				node.getInputs().add(link);
		}
		
	}

	@Override
	public void initParameters() {
		// TODO Auto-generated method stub
		
	}



	
	
	
}
package RN.linkage;

import java.awt.image.BufferedImage;
import java.awt.image.ConvolveOp;
import java.awt.image.Kernel;
import java.awt.image.RenderedImage;

/**
 * The class represents Gabor Filter implementation
 *
 * @author Alexander Jipa
 * @version 0.2, 09/03/2011
 */
public class GaborFilter {
   private static final double[] DEFAULT_ORIENTATIONS = new double[] {0};
   private static final double DEFAULT_WAVE_LENGTH = 1;
   private static final double DEFAULT_PHASE_OFFSET = 0;
   private static final double DEFAULT_ASPECT_RATIO = 0.5;
   private static final double DEFAULT_BANDWIDTH = 1;
   private static final int DEFAULT_WIDTH = 3;
   private static final int DEFAULT_HEIGHT = 3;

   private static final double MIN_ASPECT_RATIO = 0;
   private static final double MAX_ASPECT_RATIO = 1;

   private double[] orientations;
   private double waveLength;
   private double phaseOffset;
   private double aspectRatio;
   private double bandwidth;
   private int width;
   private int height;

   /**
    * Default constructor
    */
   public GaborFilter() {
      this(DEFAULT_WAVE_LENGTH);
   }

   public GaborFilter(double waveLength) {
      this(waveLength, DEFAULT_ORIENTATIONS);
   }

   public GaborFilter(double waveLength, double[] orientations) {
      this(waveLength, orientations, DEFAULT_PHASE_OFFSET);
   }

   public GaborFilter(double waveLength, double[] orientations, double phaseOffset) {
      this(waveLength, orientations, phaseOffset, DEFAULT_ASPECT_RATIO);
   }

   public GaborFilter(double waveLength, double[] orientations, double phaseOffset, double aspectRatio) {
      this(waveLength, orientations , phaseOffset, aspectRatio, DEFAULT_BANDWIDTH);
   }

   public GaborFilter(double waveLength, double[] orientations, double phaseOffset, double aspectRatio, double bandwidth) {
      this(waveLength, orientations, phaseOffset, aspectRatio, bandwidth, DEFAULT_WIDTH, DEFAULT_HEIGHT);
   }

   public GaborFilter(double waveLength, double[] orientations, double phaseOffset, double aspectRatio, double bandwidth, int width, int height) {
      this.waveLength = waveLength;
      this.orientations = orientations;
      this.phaseOffset = phaseOffset;
      this.aspectRatio = aspectRatio;
      this.bandwidth = bandwidth;
      this.width = width;
      this.height = height;
   }

   /**
    * Gets the Orientations array
    *
    * @return - an array of Orientations
    */
   public double[] getOrientations() {
      return orientations;
   }

   /**
    * Sets the Orientations array
    *
    * @param orientations - a new Orientations array
    */
   public void setOrientations(double[] orientations) {
      this.orientations = orientations;
   }

   /**
    * Gets the Wave Length
    *
    * @return - Wave Length
    */
   public double getWaveLength() {
      return waveLength;
   }

   /**
    * Sets the Wave Length
    *
    * @param waveLength - a new Wave Length
    */
   public void setWaveLength(double waveLength) {
      if(waveLength > 0) {
         this.waveLength = waveLength;
      } else {
         System.out.println("The Wave Length should be a positive number");
      }
   }

   /**
    * Gets the Phase Offset
    *
    * @return - Phase Offset
    */
   public double getPhaseOffset() {
      return phaseOffset;
   }

   /**
    * Sets the Phase Offset
    *
    * @param phaseOffset - a new Phase Offset
    */
   public void setPhaseOffset(double phaseOffset) {
      this.phaseOffset = phaseOffset;
   }

   /**
    * Gets the Aspect Ratio
    *
    * @return - Aspect Ratio
    */
   public double getAspectRatio() {
      return aspectRatio;
   }

   /**
    * Sets the Aspect Ratio
    *
    * @param aspectRatio - a new Aspect Ratio
    */
   public void setAspectRatio(double aspectRatio) {
      if(aspectRatio <= MAX_ASPECT_RATIO && aspectRatio >= MIN_ASPECT_RATIO) {
         this.aspectRatio = aspectRatio;
      } else {
         System.out.println("The Aspect Ratio should be in the range [" + MIN_ASPECT_RATIO + "; " + MAX_ASPECT_RATIO +"]");
      }
   }

   /**
    * Gets the Bandwidth
    *
    * @return - Bandwidth
    */
   public double getBandwidth() {
      return bandwidth;
   }

   /**
    * Sets the Bandwidth
    *
    * @param bandwidth - a new Bandwidth
    */
   public void setBandwidth(double bandwidth) {
      this.bandwidth = bandwidth;
   }

   /**
    * Calculates the Sigma for the given Wave Length and Bandwidth
    *
    * @param waveLength - Wave Length
    * @param bandwidth - Bandwidth
    * @return - Sigma (Deviation)
    */
   private static double calculateSigma(double waveLength, double bandwidth) {
      return waveLength*Math.sqrt(Math.log(2)/2)*(Math.pow(2, bandwidth) + 1)/((Math.pow(2, bandwidth) - 1)*Math.PI);
   }

   /**
    * Calculates Gabor function value for the given data
    *
    * @param x - X
    * @param y - Y
    * @param sigma - Sigma
    * @param aspectRatio - Aspect Ratio
    * @param waveLength - Wave Length
    * @param phaseOffset - Phase Offset
    * @return - Gabor function value
    */
   private static double gaborFunction(double x, double y, double sigma, double aspectRatio, double waveLength, double phaseOffset) {
      double gaborReal = Math.exp(-(Math.pow(x/sigma, 2) + Math.pow(y*aspectRatio/sigma, 2))/2) * Math.cos(2*Math.PI*x/waveLength + phaseOffset);
      double gaborImage = Math.exp(-(Math.pow(x/sigma, 2) + Math.pow(y*aspectRatio/sigma, 2))/2) * Math.sin(2*Math.PI*x/waveLength + phaseOffset);
      return Math.sqrt(Math.pow(gaborReal, 2) + Math.pow(gaborImage, 2));
   }

   /**
    * Returns the ConvolveOp for the Gabor Filter
    *
    * @return - ConvolveOp
    */
   public ConvolveOp getConvolveOp() {
      return new ConvolveOp(getKernel(), ConvolveOp.EDGE_NO_OP, null);
   }

   /**
    * Returns the Kernel for the Gabor filter
    *
    * @return - Kernel
    */
   public Kernel getKernel() {
	   
      double sigma = calculateSigma(waveLength, bandwidth);
      
      float[] data = new float[width*height];
      
      int oddW = width % 2 == 0 ? 0 : 1;
      int oddH = width % 2 == 0 ? 0 : 1;
      
      int startX = -(width - oddW) / 2;
      int stopX = (width - oddW) / 2 + oddW;
      int startY = -(height - oddH) / 2;
      int stopY = (height - oddH) / 2 + oddW;
      
      for(int k = 0, x = startX; x < stopX; x++) {
         for(int y = startY; y < stopY; y++) {
            for(double orientation : orientations) {
               double x1 = x * Math.cos(orientation) + y * Math.sin(orientation);
               double y1 = -x * Math.sin(orientation) + y * Math.cos(orientation);
               data[k] += (float) (gaborFunction(x1, y1, sigma, aspectRatio, waveLength, phaseOffset));
            }
            k++;
         }
      }
      
      float sum = 0f;
      for(int i = 0; i < width; i++) {
         for(int j = 0; j < height; j++) {
            sum += data[i*j + j];
         }
      }
      sum /= width*height;
      for(int i = 0; i < width; i++) {
         for(int j = 0; j < height; j++) {
            data[i*j + j] -= sum;
         }
      }
      
      return new Kernel(width, height, data);
   }

   /**
    * Gets the Width
    *
    * @return - Width
    */
   public int getWidth() {
      return width;
   }

   /**
    * Sets the Width
    *
    * @param width - a new Width
    */
   public void setWidth(int width) {
      this.width = width;
   }

   /**
    * Gets the Height
    *
    * @return - Height
    */
   public int getHeight() {
      return height;
   }

   /**
    * Sets the Height
    *
    * @param height - a new Height
    */
   public void setHeight(int height) {
      this.height = height;
   }

   /**
    * Filters the bufferedImage using the Gabor filter. If the bufferedImageDestination is not null
    * the bufferedImage is used as the destination
    *
    * @param bufferedImage - buffered image to be used as the source
    * @param bufferedImageDestination - buffered image to be used as the destination
    * @return - the rendered image
    */
   public RenderedImage filter(BufferedImage bufferedImage, BufferedImage bufferedImageDestination) {
      return getConvolveOp().filter(bufferedImage, bufferedImageDestination);
   }
}package RN.linkage;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Button;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public class GaborLogLinkage extends FilterLinkage {

	//Number of orientations (between 3 to 20) 8 is a typical value
	private Double n_t = null;
	private Double t = null;
	
	//Number of scales of the multiresolution scheme
	private Double n_s = null;
	private Double s = null;
	
	


	public GaborLogLinkage() {
	}
	

	
	public void initParameters() {
		
		if(params.length != 4)
			throw new RuntimeException("Missing Gabor parameters'");
		
		
		n_t = params[0];
		n_s = params[1];
		t = params[2];
		s = params[3];
		
		
	}
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		// somme des entrees pondérées
		SigmaWi sigmaWI = new SigmaWi();
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		initFilter(this, ID_FILTER_GABOR_LOG, ESamples.LOG_GABOR, 0.1D, (IPixelNode) thisNode, subArea, getN_t(), getN_s(), getT(), getS());
		
		subArea.applyConvolutionFilter(this, ID_FILTER_GABOR_LOG, (IPixelNode) thisNode, sigmaWI);
			
		
		
		return sigmaWI.value();
	}
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		
			IAreaSquare subArea = (IAreaSquare) getLinkedArea();
			
			initFilter(this, ID_FILTER_GABOR_LOG, ESamples.LOG_GABOR, 0.1D, (IPixelNode) thisNode, subArea, getN_t(), getN_s(), getT(), getS());
			
			subArea.applyConvolutionFilter(this, ID_FILTER_GABOR_LOG, (IPixelNode)thisNode, 0.001f);
		
	}
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		// Calcul du filtre Log-Gabor
		return  InputSample.getInstance().compute(
				filterFunction, 
				(double) subArea.getWidthPx(),
				(double) sublayerNode.getX(), // - subArea.getWidthPx() / 2D) * 4D,
				(double) sublayerNode.getY(), // - subArea.getHeightPx() / 2D) * 4D,
				(double) subArea.getNodeCenterX(),
				(double) subArea.getNodeCenterY(),
				getN_s(),
				getS(),
				getN_t(),
				getT()
				);
		
		
	}
	
	

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}
	
	public void addGraphicInterface(Pane pane) {
		
		Button showFilterBtn = new Button("show filter");
		
		showFilterBtn.setTooltip(new Tooltip("show filter"));
		
		
		HBox hbox = new HBox();
		hbox.getChildren().addAll(showFilterBtn);
		
		showFilterBtn.setOnAction(new EventHandler<ActionEvent>(){

			@Override
			public void handle(ActionEvent event) {
				try {
					//FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_CONVOLUTION);
					((IAreaSquare)thisArea).getFilter(ID_FILTER_GABOR_LOG).filterToImage(8);
					//thisArea.showImageArea();
				} catch (Exception e) {
					e.printStackTrace();
				}
				
			}
			
		});
		
		pane.getChildren().addAll(hbox);
		
	}






	public Double getN_t() {
		return n_t;
	}



	public void setN_t(Double n_t) {
		this.n_t = n_t;
	}



	public Double getN_s() {
		return n_s;
	}



	public void setN_s(Double n_s) {
		this.n_s = n_s;
	}



	public Double getS() {
		return s;
	}



	public void setS(Double s) {
		this.s = s;
	}



	public Double getT() {
		return t;
	}



	public void setT(Double t) {
		this.t = t;
	}

}
package RN.linkage;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.linkage.FilterLinkage.FilterIndex;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import RN.utils.StatUtils;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Button;
import javafx.scene.control.Slider;
import javafx.scene.control.TextField;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public class GaborLogLinkage2 extends FilterLinkage {
	
	private Slider maskSizeSlider = null;
	private Slider numOrientsSlider = null;
	private Slider numScalesSlider = null;
	
	private Slider idThetaSlider = null;
	private Slider idScaleSlider = null;

	//Number of orientations (between 3 to 20) 8 is a typical value
	private Double numOrients = null;
	private Double t = null;
	
	//Number of scales of the multiresolution scheme
	private Double numScales = null;
	private Double s = null;
	
	private Integer maskSize = null;
	private Integer maskSizeTotal = null;
	
	private GaborFilter gaborFilter = null;
	private float[] data = null;
	
	private int widthPx;
	private int heightPx;
	
	
	private Double[][] gaborReal;
	private Double[][] gaborImag;

	public GaborLogLinkage2() {
	}
	

	
	public void initParameters() {
		
		if(params.length != 4)
			throw new RuntimeException("Missing Gabor parameters'");
		
		
		numOrients = params[0];
		numScales = params[1];
		t = params[2];
		s = params[3];
		
		maskSize = 2;
		
		computeMaskSize(maskSize);
		
//		widthPx = ((IAreaSquare) thisArea).getWidthPx();
//		heightPx = ((IAreaSquare) thisArea).getHeightPx();
//		
//		if(data == null){
//			gaborFilter = new GaborFilter(16, new double[] {t * Math.PI /numOrients}, 0, 0.5, 1, widthPx, heightPx);
//			data = gaborFilter.getKernel().getKernelData(null);
//		}
		
		
	}
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		// somme des entrees pondérées
		SigmaWi sigmaWI = new SigmaWi();
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		//initFilter(this, ID_FILTER_GABOR_LOG, (IPixelNode) thisNode, widthPx, heightPx, data, getNumOrients(), getNumScales(), getT());
		
		initFilter(this, ID_FILTER_GABOR_LOG, ESamples.LOG_GABOR, 0.0001D, (IPixelNode) thisNode, subArea, getNumOrients(), getNumScales(), getT(), getS());
		
		subArea.applyConvolutionFilter(this, ID_FILTER_GABOR_LOG, (IPixelNode) thisNode, sigmaWI);
			
		
		
		return sigmaWI.value();
	}
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		
			IAreaSquare subArea = (IAreaSquare) getLinkedArea();
			
			//initFilter(this, ID_FILTER_GABOR_LOG, (IPixelNode) thisNode, widthPx, heightPx, data, getNumOrients(), getNumScales(), getT());
			
			initFilter(this, ID_FILTER_GABOR_LOG, ESamples.LOG_GABOR, 0.0001D, (IPixelNode) thisNode, subArea, getNumOrients(), getNumScales(), getT(), getS());
			
			subArea.applyConvolutionFilter(this, ID_FILTER_GABOR_LOG, (IPixelNode)thisNode, 0.001f);
		
	}
	
	
	private void computeMaskSize(int maskSize){
		this.maskSize = maskSize;
		this.maskSizeTotal = 2 * maskSize + 1; // gaborReal and gaborImag = new Double[maskSizeTotal][maskSizeTotal]
	}
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		//IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		if(gaborReal == null || gaborImag == null){
			
			gaborReal = new Double[maskSizeTotal][maskSizeTotal];
			gaborImag = new Double[maskSizeTotal][maskSizeTotal];
			
			gaborFilter(gaborReal, gaborImag, numScales.intValue(), numOrients.intValue(), s.intValue(), t.intValue(), true);
			
            double real_weight = StatUtils.absoluteSum(gaborReal);
            double imag_weight = StatUtils.absoluteSum(gaborImag);
            
            real_weight /= maskSizeTotal * maskSizeTotal;
            imag_weight /= maskSizeTotal * maskSizeTotal;
            
            for(int i = 0; i < maskSizeTotal; i++) {
                for(int j = 0; j < maskSizeTotal; j++) {
                	gaborReal[i][j] -= real_weight;
                	gaborImag[i][j] -= imag_weight;
                }
             }
            
		}
		
		if(sublayerNode.getX() >= maskSizeTotal || sublayerNode.getY() >= maskSizeTotal)
			return 0D;
		
		
		return Math.sqrt(Math.pow(gaborReal[ sublayerNode.getX() ][ sublayerNode.getY() ], 2) + Math.pow(gaborImag[ sublayerNode.getX() ][ sublayerNode.getY() ], 2));
		
		//return Math.sqrt(Math.pow( gaborReal[ sublayerNode.getX() ][ sublayerNode.getY() ]/real_weight, 2.0 ) + Math.pow( gaborImag[ sublayerNode.getX() ][ sublayerNode.getY() ]/imag_weight, 2.0 ) );
		
        //compute the magnitude of the complex
        //filtering results
//        int data_index = 0;
//        for(int r = 0; r < image.height; r++ ) {
//                for(int c = 0; c < image.width; c++, data_index++ ) {
//                        features.data[ data_index ][ filter_index ] = Math.sqrt(
//                                Math.pow( real[ r ][ c ]/real_weight, 2.0 ) +
//                                Math.pow( imag[ r ][ c ]/imag_weight, 2.0 ) );
//                }
//        }
		
		// Calcul du filtre Log-Gabor
//		return  InputSample.getInstance().compute(
//				filterFunction, 
//				(double) subArea.getWidthPx(),
//				(double) sublayerNode.getX(), // - subArea.getWidthPx() / 2D) * 4D,
//				(double) sublayerNode.getY(), // - subArea.getHeightPx() / 2D) * 4D,
//				(double) subArea.getNodeCenterX(),
//				(double) subArea.getNodeCenterY(),
//				getNumScales(),
//				getS(),
//				getNumOrients(),
//				getT()
//				);
		
		
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}
	
	  //method to generate Gabor filter masks in time domain
	  public static void gaborFilter(Double[][] gaborReal, Double[][] gaborImag,  int numScales, int numOrients, int s, int n, boolean removeDC) {

		  	double freqLower = 0.15;	//lower frequency
		  	double freqUpper = 0.4;  //upper frequency
		  
	          double freqBase, a, u0, z, v, x0, y0, g, t1, t2, m;
	          int x, y, side;

	          freqBase = freqUpper / freqLower;
	          a = Math.pow( freqBase, 1.0 / (double) ( numScales - 1 ) );

	          u0 = freqUpper / Math.pow( a, (double) ( numScales - s ) );

	          v = Math.pow( 0.6 / freqUpper * Math.pow( a, (double) ( numScales - s ) ), 2.0 );

	          t1 = Math.cos( (double) Math.PI / numOrients * ( n - 1.0 ) );
	          t2 = Math.sin( (double) Math.PI / numOrients * ( n - 1.0 ) );

	          side = (int) ( gaborReal[0].length - 1 ) / 2;

	          for( x = 0; x < ( 2 * side + 1 ); x++ ) {
	                  for( y = 0; y < ( 2 * side + 1 ); y++ ) {
	                          x0 = (double) ( x - side) * t1 + (double) ( y - side ) * t2;
	                          y0 = (double) - ( x - side ) * t2 + (double) ( y - side ) * t1;
	                          g = 1.0 / ( 2.0 * Math.PI * v ) * Math.pow( a, (double) ( numScales - s ) ) * Math.exp( - 0.5 * ( x0 * x0 + y0 * y0 ) / v );
	                          gaborReal[x][y] = g * Math.cos( 2.0 * Math.PI * u0 * x0 );
	                          gaborImag[x][y] = g * Math.sin( 2.0 * Math.PI * u0 * x0 );
	                  }
	          }

	          //if removeDC flag is set, then remove the average value
	          //from the real part of Gabor
	          if( removeDC  ) {

	                  m = 0;
	                  for( x = 0; x < ( 2 * side + 1 ); x++ )
	                          for( y = 0; y < ( 2 * side + 1 ); y++ )
	                                  m += Math.abs(gaborReal[x][y]);

	                  m /= Math.pow( (double) 2.0 * side + 1, 2.0 );

	                  for( x = 0; x < ( 2 * side + 1 ); x++ )
	                          for( y = 0; y < ( 2 * side + 1 ); y++ )
	                                  gaborReal[x][y] -= m;

	          }

	  }
	
	public void addGraphicInterface(Pane pane) {
		
		TextField maskSizeTF = new TextField("mask size total = " + getMaskSizeTotal());
		
		maskSizeSlider = new Slider(0D, 8D, maskSize);
		maskSizeSlider.setBlockIncrement(0.05D);
		
		numOrientsSlider = new Slider(0D, 60D, numOrients);
		numOrientsSlider.setBlockIncrement(1D);
		
		numScalesSlider = new Slider(0D, 8D, numScales);
		numScalesSlider.setBlockIncrement(1D);
		
		idThetaSlider = new Slider(0D, numOrients, t);
		idThetaSlider.setBlockIncrement(1D);
		
		idScaleSlider = new Slider(0D, numScales, s);
		idScaleSlider.setBlockIncrement(1D);
		
		
		
		HBox hbox = new HBox();
		hbox.getChildren().addAll(maskSizeSlider, maskSizeTF);
		HBox hbox2 = new HBox();
		hbox2.getChildren().addAll(numOrientsSlider, numScalesSlider);
		HBox hbox3 = new HBox();
		hbox3.getChildren().addAll(idThetaSlider, idScaleSlider);
		
		
		maskSizeSlider.valueProperty().addListener(new ChangeListener<Number>() {
			public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
				computeMaskSize(new_val.intValue());
				maskSizeTF.setText("mask size = " + new_val.doubleValue());
				try {
					gaborReal = null;
					gaborImag = null;
					FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_GABOR_LOG);
					FilterLinkage.removeFilter(idx);
					Double[] outputs = null;
					thisArea.propagation(false, outputs);
					((IAreaSquare) thisArea).showImageArea();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
		
		numOrientsSlider.valueProperty().addListener(new ChangeListener<Number>() {
			public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
				setNumOrients(new_val.doubleValue());
				idThetaSlider.setMax(new_val.intValue());
				maskSizeTF.setText("num orientations = " + new_val.doubleValue());
				try {
					gaborReal = null;
					gaborImag = null;
					FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_GABOR_LOG);
					FilterLinkage.removeFilter(idx);
					Double[] outputs = null;
					thisArea.propagation(false, outputs);
					((IAreaSquare) thisArea).showImageArea();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
		
		numScalesSlider.valueProperty().addListener(new ChangeListener<Number>() {
			public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
				setNumScales(new_val.doubleValue());
				idScaleSlider.setMax(new_val.intValue());
				maskSizeTF.setText("num scales = " + new_val.doubleValue());
				try {
					gaborReal = null;
					gaborImag = null;
					FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_GABOR_LOG);
					FilterLinkage.removeFilter(idx);
					Double[] outputs = null;
					thisArea.propagation(false, outputs);
					((IAreaSquare) thisArea).showImageArea();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
		
		idThetaSlider.valueProperty().addListener(new ChangeListener<Number>() {
			public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
				setT(new_val.doubleValue());
				maskSizeTF.setText("id theta = " + new_val.doubleValue());
				try {
					gaborReal = null;
					gaborImag = null;
					FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_GABOR_LOG);
					FilterLinkage.removeFilter(idx);
					Double[] outputs = null;
					thisArea.propagation(false, outputs);
					((IAreaSquare) thisArea).showImageArea();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
		
		idScaleSlider.valueProperty().addListener(new ChangeListener<Number>() {
			public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
				setS(new_val.doubleValue());
				maskSizeTF.setText("id scale = " + new_val.doubleValue());
				try {
					gaborReal = null;
					gaborImag = null;
					FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_GABOR_LOG);
					FilterLinkage.removeFilter(idx);
					Double[] outputs = null;
					thisArea.propagation(false, outputs);
					((IAreaSquare) thisArea).showImageArea();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
		
		Button showFilterBtn = new Button("show filter");
		
		showFilterBtn.setTooltip(new Tooltip("show filter"));
		
		
		HBox hbox4 = new HBox();
		hbox4.getChildren().addAll(showFilterBtn);
		
		showFilterBtn.setOnAction(new EventHandler<ActionEvent>(){

			@Override
			public void handle(ActionEvent event) {
				try {
					//FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_CONVOLUTION);
					((IAreaSquare)thisArea).getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
					//thisArea.showImageArea();
				} catch (Exception e) {
					e.printStackTrace();
				}
				
			}
			
		});
		
		
		pane.getChildren().addAll(hbox, hbox2, hbox3, hbox4);
		
		
		
	}






	public Double getS() {
		return s;
	}



	public void setS(Double s) {
		this.s = s;
	}



	public Double getT() {
		return t;
	}



	public void setT(Double t) {
		this.t = t;
	}



	public Double getNumOrients() {
		return numOrients;
	}



	public void setNumOrients(Double numOrients) {
		this.numOrients = numOrients;
	}



	public Double getNumScales() {
		return numScales;
	}



	public void setNumScales(Double numScales) {
		this.numScales = numScales;
	}



	public Integer getMaskSizeTotal() {
		return maskSizeTotal;
	}



	public void setMaskSizeTotal(Integer maskSizeTotal) {
		this.maskSizeTotal = maskSizeTotal;
	}



	public Integer getMaskSize() {
		return maskSize;
	}



	public void setMaskSize(Integer maskSize) {
		this.maskSize = maskSize;
	}

}
package RN.linkage;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Button;
import javafx.scene.control.Slider;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public class GaussianLinkage extends FilterLinkage {
	
	private  Slider sigmaSlider = null;

	// GAUSSIENNE ELLIPTIQUE
	private Double mu = null;

	// centre
	private Double x1 = null;
	private Double y1 = null;

	// amplitude, hauteur de la forme pixelisée
	private Double alpha = null;

	// ecartement selon x et y
	private Double sigmaX = null;
	private Double sigmaY = null;
	
	private Double k = null;
	


	public GaussianLinkage() {
	}
	

	
	public void initParameters() {
		
//		Le traitement repose sur cinq paramètres :
//		
//			N représente la taille du masque (matrice carrée) implantant le filtre LOG. N est impair.
//			σ permet d'ajuster la taille du chapeau mexicain.
//			∆x et ∆y sont les pas d'échantillonnage utilisés pour discrétiser h''(x,y). Généralement ∆x = ∆ y
//			S est le seuil qui permet de sélectionner les contours les plus marqués.
//		
//			Il est à noter que le choix des paramètres N, σ et ∆x ne doit pas se faire de façon indépendante. 
//  		En effet, le masque, même de taille réduite, doit ressembler à un chapeau mexicain. Le problème ici est le même que celui que l'on rencontre lors de l'échantillonnage d'une fonction gaussienne. 
//          Le nombre de points N à considérer doit être tel que l'étendue occupe l'intervalle [-3σ , 3σ].
//			En fonction du pas d'échantillonnage, l'étendue spatiale vaut : (N-1) ∆x  .
//			Cette étendue peut aussi s'écrire en fonction de σ : (N-1) ∆x = kσ  avec k entier.
//			En prenant par exemple  ∆x = 1 , il s'agit de choisir N et σ de sorte que l'étendue du chapeau mexicain soit pertinente. 
//  		Pour le chapeau mexicain, la valeur de k doit être au moins de 4.
		
//		double N = 9D;
//		double deltaX = 1D;
		k = params[0];
		
//		ox = (N-1) * deltaX / k;
		sigmaX = 0.5D;
		sigmaY = sigmaX;
		alpha = 1D;
		mu = 0D;
		
	}
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		// somme des entrees pondérées
		SigmaWi sigmaWI = new SigmaWi();
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		initFilter(this, ID_FILTER_GAUSSIAN, ESamples.GAUSSIAN_DE_MARR, (IPixelNode) thisNode, subArea, getMu(), getAlpha(), getSigmaX(), getSigmaY(), getK());
		
		subArea.applyConvolutionFilter(this, ID_FILTER_GAUSSIAN, (IPixelNode) thisNode, sigmaWI);
			
		
		return sigmaWI.value();
	}
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		
			IAreaSquare subArea = (IAreaSquare) getLinkedArea();
			
			initFilter(this, ID_FILTER_GAUSSIAN, ESamples.GAUSSIAN_DE_MARR, (IPixelNode) thisNode, subArea, getMu(), getAlpha(), getSigmaX(), getSigmaY(), getK());
			
			subArea.applyConvolutionFilter(this, ID_FILTER_GAUSSIAN, (IPixelNode)thisNode, 0.001f);
		
	}
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		// Calcul du filtre gaussien
		return mu + alpha * InputSample.getInstance().compute(
				filterFunction, 
				(double) subArea.getWidthPx(),
				(double) subArea.getHeightPx(), 
				(double) sublayerNode.getX(),
				(double) sublayerNode.getY(), 
				(double) subArea.getNodeCenterXY().getX(), 
				(double) subArea.getNodeCenterXY().getY(), 
				sigmaX, 
				sigmaY,
				k);
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}
	
	public void addGraphicInterface(Pane pane) {
		
		sigmaSlider = new Slider(0D, 5D, 0.5D);
		sigmaSlider.setBlockIncrement(0.1D);
		sigmaSlider.setTooltip(new Tooltip("Sigma"));
		
		HBox hbox = new HBox();
		hbox.getChildren().addAll(sigmaSlider);
		
		
		sigmaSlider.valueProperty().addListener(new ChangeListener<Number>() {
			public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
				setSigmaX(new_val.doubleValue());
				System.out.println(String.format("Sigma : %.2f", new_val));
				try {
					FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_GAUSSIAN);
					FilterLinkage.removeFilter(idx);
					Double[] outputs = null;
					thisArea.propagation(false, outputs);
					((IAreaSquare) thisArea).showImageArea();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
		
		Button showFilterBtn = new Button("show filter");
		
		showFilterBtn.setTooltip(new Tooltip("show filter"));
		
		
		HBox hbox2 = new HBox();
		hbox2.getChildren().addAll(showFilterBtn);
		
		showFilterBtn.setOnAction(new EventHandler<ActionEvent>(){

			@Override
			public void handle(ActionEvent event) {
				try {
					//FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_CONVOLUTION);
					((IAreaSquare)thisArea).getFilter(ID_FILTER_GAUSSIAN).filterToImage(8);
					//thisArea.showImageArea();
				} catch (Exception e) {
					e.printStackTrace();
				}
				
			}
			
		});
		

		pane.getChildren().addAll(hbox, hbox2);
		
	}

	public Double getMu() {
		return mu;
	}

	public void setMu(Double mu) {
		this.mu = mu;
	}

	public Double getX1() {
		return x1;
	}

	public void setX1(Double x1) {
		this.x1 = x1;
	}

	public Double getY1() {
		return y1;
	}

	public void setY1(Double y1) {
		this.y1 = y1;
	}

	public Double getAlpha() {
		return alpha;
	}

	public void setAlpha(Double alpha) {
		this.alpha = alpha;
	}

	public Double getSigmaX() {
		return sigmaX;
	}

	public Double getK() {
		return k;
	}

	public void setK(Double k) {
		this.k = k;
	}

	public Slider getSigmaSlider() {
		return sigmaSlider;
	}

	public void setSigmaSlider(Slider sigmaSlider) {
		this.sigmaSlider = sigmaSlider;
	}

	public Double getSigmaY() {
		return sigmaY;
	}

	public void setSigmaY(Double sigmaY) {
		this.sigmaY = sigmaY;
	}

	public void setSigmaX(Double sigmaX) {
		this.sigmaX = sigmaX;
	}

}
package RN.linkage;

import java.util.List;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import RN.nodes.PixelNode;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Button;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public class GenericFilterLinkage extends FilterLinkage {


	public GenericFilterLinkage() {
	}
	
	@Override
	public void initParameters() {
		

	}
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		SigmaWi sigmaWI = new SigmaWi();
		
		// somme des entrees pondérées
		ILayer sublayer = thisNode.getArea().getPreviousLayer();
		if(sublayer != null){
			
			IAreaSquare subArea = (IAreaSquare) getLinkedArea();
			
			initFilter(this, ID_FILTER_GENERIC, (IPixelNode) thisNode, subArea);
			
			subArea.applyConvolutionFilter(this, ID_FILTER_GENERIC, (IPixelNode)thisNode, sigmaWI);
			
		}
		
		return sigmaWI.value();
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		initFilter(this, ID_FILTER_GENERIC, (IPixelNode) thisNode, subArea);
		
		subArea.applyConvolutionFilter(this, ID_FILTER_GENERIC, (IPixelNode) thisNode, 0.0000001f);

	}
	
	public void initFilter(IFilterLinkage linkage, int idFilter, IPixelNode thisNode, IAreaSquare subArea) {
		
		
		FilterIndex idx = new FilterIndex(thisNode.getAreaSquare().getIdentification(), idFilter);
		
		if (this.getFilter(idx) == null) {
			
			Filter existingFilter = Filter.returnExistingFilter(eSampleFunction, params);
			Filter filter = null;
			if(existingFilter == null){
				
				filter = new Filter(idFilter, eSampleFunction, new Double[subArea.getWidthPx()][subArea.getHeightPx()], params);
				
				double filterValue = 0D;
				
				List<INode> nodeList = subArea.getNodes();
				INode sublayerNode = null;
				for (int index = 0; index < nodeList.size(); index++) {
					
					sublayerNode = nodeList.get(index);
					
					filterValue = linkage.processFilter(eSampleFunction, (IPixelNode) sublayerNode, params);

					// Ajout des valeurs discretes du filtre dans le cache matriciel
					if (Math.abs(filterValue) > 0.001D) {
						filter.setValue(((PixelNode) sublayerNode).getX(), ((PixelNode) sublayerNode).getY(), filterValue);
					}else{
						filter.setValue(((PixelNode) sublayerNode).getX(), ((PixelNode) sublayerNode).getY(), 0D);
					}
				}
				
				filter.resizeFilter();
				
				this.setFilter(idx,  filter);
				
			}else{
				
				this.setFilter(idx,  existingFilter);
				
			}

			this.getFilter(idx).filterToString();
		}
		
	}
	
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		return  InputSample.getInstance().compute(
				filterFunction, 
				(double) subArea.getWidthPx(),
				(double) subArea.getHeightPx(), 
				(double) ((PixelNode) sublayerNode).getX(),
				(double) ((PixelNode) sublayerNode).getY(), 
				(double) ((PixelNode) subArea.getNodeCenterXY()).getX(), 
				(double) ((PixelNode) subArea.getNodeCenterXY()).getY());
	}
	
	public void addGraphicInterface(Pane pane) {
		
		Button showFilterBtn = new Button("show filter");
		
		showFilterBtn.setTooltip(new Tooltip("show filter"));
		
		
		HBox hbox = new HBox();
		hbox.getChildren().addAll(showFilterBtn);
		
		showFilterBtn.setOnAction(new EventHandler<ActionEvent>(){

			@Override
			public void handle(ActionEvent event) {
				try {
					//FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_CONVOLUTION);
					((IAreaSquare)thisArea).getFilter(ID_FILTER_GENERIC).filterToImage(8);
					//thisArea.showImageArea();
				} catch (Exception e) {
					e.printStackTrace();
				}
				
			}
			
		});
		
		pane.getChildren().addAll(hbox);
		
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub

	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub

	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub

	}



}
package RN.linkage;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.nodes.INode;
import RN.nodes.IPixelNode;

/**
 * @author Eric Marchand
 *
 */
public class HessianCourbureLinkage extends FilterLinkage {

	// GAUSSIENNE ELLIPTIQUE
	private Double mu = null;

	// centre
	private Double x1 = null;
	private Double y1 = null;

	// amplitude, hauteur de la forme pixelisée
	private Double alpha = null;

	// ecartement selon x et y
	private Double ox = null;
	private Double oy = null;
	


	public HessianCourbureLinkage() {
	}
	

	
	public void initParameters() {
		
//		Le traitement repose sur cinq paramètres :
//		
//			N représente la taille du masque (matrice carrée) implantant le filtre LOG. N est impair.
//			σ permet d'ajuster la taille du chapeau mexicain.
//			∆x et ∆y sont les pas d'échantillonnage utilisés pour discrétiser h''(x,y). Généralement ∆x = ∆ y
//			S est le seuil qui permet de sélectionner les contours les plus marqués.
//		
//			Il est à noter que le choix des paramètres N, σ et ∆x ne doit pas se faire de façon indépendante. 
//  		En effet, le masque, même de taille réduite, doit ressembler à un chapeau mexicain. Le problème ici est le même que celui que l'on rencontre lors de l'échantillonnage d'une fonction gaussienne. 
//          Le nombre de points N à considérer doit être tel que l'étendue occupe l'intervalle [-3σ , 3σ].
//			En fonction du pas d'échantillonnage, l'étendue spatiale vaut : (N-1) ∆x  .
//			Cette étendue peut aussi s'écrire en fonction de σ : (N-1) ∆x = kσ  avec k entier.
//			En prenant par exemple  ∆x = 1 , il s'agit de choisir N et σ de sorte que l'étendue du chapeau mexicain soit pertinente. 
//  		Pour le chapeau mexicain, la valeur de k doit être au moins de 4.
		
//		double N = 9D;
//		double deltaX = 1D;
//		double k = params[0];
		
//		ox = (N-1) * deltaX / k;
//		ox = 0.5D * k;
//		oy = ox;
//		alpha = 1D;
//		mu = 0D;
		
	}
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		Double sigmaWI = 0D;

		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		FilterIndex index1 = new FilterIndex(((IPixelNode) thisNode).getAreaSquare().getIdentification(), ID_FILTER_Gxx);
		FilterIndex index2 = new FilterIndex(((IPixelNode) thisNode).getAreaSquare().getIdentification(), ID_FILTER_Gyy);
		FilterIndex index3 = new FilterIndex(((IPixelNode) thisNode).getAreaSquare().getIdentification(), ID_FILTER_Gxy);

		double divisor = 1D;
		double gxx = 0D;
		double gyy = 0D;
		double gxy = 0D;

		for (INode sourceNode : subArea.getNodes()) {

			gxx += getFilterValue(index1, EFilterPosition.CENTER, (IPixelNode) thisNode, (IPixelNode) sourceNode) * sourceNode.getComputedOutput();
			gyy += getFilterValue(index2, EFilterPosition.CENTER, (IPixelNode) thisNode, (IPixelNode) sourceNode) * sourceNode.getComputedOutput();
			gxy += getFilterValue(index3, EFilterPosition.CENTER, (IPixelNode) thisNode, (IPixelNode) sourceNode) * sourceNode.getComputedOutput();

		}

		sigmaWI = (gxx * gyy - Math.pow(gxy, 2D)) / Math.pow(gxx + gyy, 2D);

		// double r = 10D;
		// double R = r / Math.pow(r + 1, 2D);
		// System.out.println("criterion = " + (criterion *
		// interestPointNode.getComputedOutput()) + " >= " + R);
		//
		// sigmaWI -= thisNode.getBiasWeight();

		return sigmaWI;
	}
	

	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
//		double weight = 0D;
//		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
//		
//		thisNode.getArea().initFilter(this, ID_FILTER_GAUSSIAN, ESamples.GAUSSIAN_DE_MARR, subArea);
//		
//		for (INode sublayerNode : subArea.getNodes()) {
//			if (sublayerNode.getNodeType() == ENodeType.PIXEL) {
//				
//				// on connecte les neurones suivant la dérivée seconde de la gaussienne
//				// réalisant ainsi le filtre de Marr ou Laplacien de Gaussienne ou chapeau mexicain
//				weight = thisNode.getArea().getFilterValue(thisNode, ID_FILTER_GAUSSIAN, sublayerNode);
//				if(Math.abs(weight) > 0.001D){
//					sublayerNode.link(thisNode, ELinkType.REGULAR, isWeightModifiable(), weight);
//				}
//				
//			}
//		}
	}
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		// Calcul du filtre gaussien
		return mu + alpha * InputSample.getInstance().compute(
				filterFunction, 
				(double) subArea.getWidthPx(),
				(double) subArea.getHeightPx(), 
				(double) sublayerNode.getX(),
				(double) sublayerNode.getY(), 
				(double) subArea.getNodeCenterXY().getX(), 
				(double) subArea.getNodeCenterXY().getY(), 
				ox, 
				oy);
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	public Double getMu() {
		return mu;
	}

	public void setMu(Double mu) {
		this.mu = mu;
	}

	public Double getX1() {
		return x1;
	}

	public void setX1(Double x1) {
		this.x1 = x1;
	}

	public Double getY1() {
		return y1;
	}

	public void setY1(Double y1) {
		this.y1 = y1;
	}

	public Double getAlpha() {
		return alpha;
	}

	public void setAlpha(Double alpha) {
		this.alpha = alpha;
	}

	public Double getOx() {
		return ox;
	}

	public void setOx(Double ox) {
		this.ox = ox;
	}

	public Double getOy() {
		return oy;
	}

	public void setOy(Double oy) {
		this.oy = oy;
	}

}
package RN.linkage;

import RN.IAreaSquare;
import RN.dataset.inputsamples.ESamples;
import RN.linkage.FilterLinkage.FilterIndex;
import RN.nodes.IPixelNode;

/**
 * @author Eric Marchand
 *
 */
public interface IFilterLinkage {
	
	Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params);
	
	Double processFilter(ESamples filterFunction, IAreaSquare subArea, IPixelNode sublayerNode);
	
	Double processFilter(ESamples filterFunction, IAreaSquare subArea, IPixelNode sublayerNode, Double... params);
	
	void setESampleFunction(ESamples eSampleFunction);
	
	void setSampling(Integer sampling);
	
	Integer getSampling();
	
	Double getFilterValue(FilterIndex index, EFilterPosition filterPosition, IPixelNode thisNode, IPixelNode sourceNode);
	
	Boolean isWeightModifiable();
	
	Filter getFilter(FilterIndex idFilter);
	
	void initFilter(IFilterLinkage linkage, int idFilter, ESamples filterFunction, IPixelNode thisNode, IAreaSquare subArea, Double... params);
	
	void initFilter(IFilterLinkage linkage, int idFilter, ESamples filterFunction, Double cacheSensibility, IPixelNode thisNode, IAreaSquare subArea, Double... params);
	
	void initFilter(IFilterLinkage linkage, int idFilter, IPixelNode thisNode, int width, int height, Double[][] values, Double... params);
	
	void initFilter(IFilterLinkage linkage, int idFilter, IPixelNode thisNode, int width, int height, float[] values, Double... params);
	
}
package RN.linkage;

import java.util.List;

import RN.IArea;
import RN.ILayer;
import RN.nodes.INode;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public interface ILinkage {
	
	
	void sublayerFanOutLinkage(INode thisNode, ILayer sublayer);

	void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT);

	void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer);

	void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT);

	void setWeightModifiable(boolean weightModifiable);
	
	Boolean isWeightModifiable();

	void setParams(Double[] params);
	
	Double[] getParams();

	void initParameters();
	
	void addGraphicInterface(Pane pane);
	
	void setLinkageType(ELinkage linkageType);
	
	ELinkage getLinkageType();

	double getSigmaPotentials(INode thisNode);
	
	double getLinkedSigmaPotentials(INode thisNode);
	
	double getUnLinkedSigmaPotentials(INode thisNode);

	IArea getArea();

	void setArea(IArea thisArea);

	void setSampling(Integer sampling);
	
	Integer getSampling();
	
	void setLinkageAreas(ELinkageBetweenAreas linkageAreas);

	void setTargetedAreas(List<Integer> targetedArea);
	
	List<IArea> getLinkedAreas();

	IArea getLinkedArea();

	void prePropagation();
	
	void postPropagation();
	
	//Area initAreaSubSampling(Area subArea);
	

}package RN.linkage;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Button;
import javafx.scene.control.Slider;
import javafx.scene.control.TextField;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public class LaplacianOfGaussianLinkage extends FilterLinkage {
	
	private  Slider sigmaSlider = null;
	
	// GAUSSIENNE ELLIPTIQUE
	private Double mu = null;

	// centre
	private Double x1 = null;
	private Double y1 = null;

	// amplitude, hauteur de la forme pixelisée
	private Double alpha = null;
	
	// ecartement selon x et y
	private Double sigmaX = null;
	private Double sigmaY = null;

	

	public LaplacianOfGaussianLinkage() {
	}
	
	public void initParameters() {
		
//		Le traitement repose sur cinq paramètres :
//		
//			N représente la taille du masque (matrice carrée) implantant le filtre LOG. N est impair.
//			σ permet d'ajuster la taille du chapeau mexicain.
//			∆x et ∆y sont les pas d'échantillonnage utilisés pour discrétiser h''(x,y). Généralement ∆x = ∆ y
//			S est le seuil qui permet de sélectionner les contours les plus marqués.
//		
//			Il est à noter que le choix des paramètres N, σ et ∆x ne doit pas se faire de façon indépendante. 
//  		En effet, le masque, même de taille réduite, doit ressembler à un chapeau mexicain. Le problème ici est le même que celui que l'on rencontre lors de l'échantillonnage d'une fonction gaussienne. 
//          Le nombre de points N à considérer doit être tel que l'étendue occupe l'intervalle [-3σ , 3σ].
//			En fonction du pas d'échantillonnage, l'étendue spatiale vaut : (N-1) ∆x  .
//			Cette étendue peut aussi s'écrire en fonction de σ : (N-1) ∆x = kσ  avec k entier.
//			En prenant par exemple  ∆x = 1 , il s'agit de choisir N et σ de sorte que l'étendue du chapeau mexicain soit pertinente. 
//  		Pour le chapeau mexicain, la valeur de k doit être au moins de 4.
		
		double N = 5;
		double deltaX = 1;
		double k = 6D;
		
		sigmaX = 0.5;//(N-1) * deltaX / k;
		sigmaY = sigmaX;
		alpha = 1D;
		mu = 0D;
		
	}
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		// somme des entrees pondérées
		SigmaWi sigmaWI = new SigmaWi();
			
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		initFilter(this, ID_FILTER_LOG, ESamples.G_D2xy_DE_MARR,(IPixelNode) thisNode, subArea, getSigmaX(), getSigmaY());
		
		subArea.applyConvolutionFilter(this, ID_FILTER_LOG,(IPixelNode) thisNode, sigmaWI);
			
		
		return sigmaWI.value();
	}


	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		initFilter(this, ID_FILTER_LOG, ESamples.G_D2xy_DE_MARR, (IPixelNode) thisNode, subArea, getSigmaX(), getSigmaY());
		
		subArea.applyConvolutionFilter(this, ID_FILTER_LOG, (IPixelNode) thisNode, 0.0000001f);

	}
	

	
	
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		// Calcul du filtre gaussien
		return mu + alpha * InputSample.getInstance().compute(
				filterFunction, 
				(double) subArea.getWidthPx(),
				(double) subArea.getHeightPx(), 
				(double) sublayerNode.getX(),
				(double) sublayerNode.getY(), 
				(double) subArea.getNodeCenterXY().getX(), 
				(double) subArea.getNodeCenterXY().getY(), 
				sigmaX, 
				sigmaY);
	}
	
	public void addGraphicInterface(Pane pane) {
			
			TextField sigma = new TextField("sigma = " + getSigmaX());
			
			sigmaSlider = new Slider(0D, 4D, sigmaX);
			sigmaSlider.setBlockIncrement(0.025D);
			sigmaSlider.setTooltip(new Tooltip("Sigma"));
			

			
			HBox hbox = new HBox();
			hbox.getChildren().addAll( sigmaSlider, sigma);
			
			
			
			sigmaSlider.valueProperty().addListener(new ChangeListener<Number>() {
				public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
					setSigmaX(new_val.doubleValue());
					setSigmaY(new_val.doubleValue());
					sigma.setText("sigma = " + new_val.doubleValue());
					System.out.println(String.format("Sigma : %.2f", new_val));
					try {
						FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_LOG);
						FilterLinkage.removeFilter(idx);
						Double[] outputs = null;
						thisArea.propagation(false, outputs);
						((IAreaSquare) thisArea).showImageArea();
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
			});
			
			Button showFilterBtn = new Button("show filter");
			showFilterBtn.setTooltip(new Tooltip("show filter"));
			
			
			HBox hbox2 = new HBox();
			hbox2.getChildren().addAll(showFilterBtn);
			
			showFilterBtn.setOnAction(new EventHandler<ActionEvent>(){

				@Override
				public void handle(ActionEvent event) {
					try {
						//FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_CONVOLUTION);
						((IAreaSquare)thisArea).getFilter(FilterLinkage.ID_FILTER_LOG).filterToImage(8);
						//thisArea.showImageArea();
					} catch (Exception e) {
						e.printStackTrace();
					}
					
				}
				
			});
			

			pane.getChildren().addAll(hbox, hbox2);
			
			
			
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	public Double getMu() {
		return mu;
	}

	public void setMu(Double mu) {
		this.mu = mu;
	}

	public Double getX1() {
		return x1;
	}

	public void setX1(Double x1) {
		this.x1 = x1;
	}

	public Double getY1() {
		return y1;
	}

	public void setY1(Double y1) {
		this.y1 = y1;
	}

	public Double getAlpha() {
		return alpha;
	}

	public void setAlpha(Double alpha) {
		this.alpha = alpha;
	}

	public Slider getSigmaSlider() {
		return sigmaSlider;
	}

	public void setSigmaSlider(Slider sigmaSlider) {
		this.sigmaSlider = sigmaSlider;
	}

	public Double getSigmaX() {
		return sigmaX;
	}

	public void setSigmaX(Double sigmaX) {
		this.sigmaX = sigmaX;
	}

	public Double getSigmaY() {
		return sigmaY;
	}

	public void setSigmaY(Double sigmaY) {
		this.sigmaY = sigmaY;
	}



}
package RN.linkage;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import RN.ENetworkImplementation;
import RN.IArea;
import RN.ILayer;
import RN.Identification;
import RN.NetworkElement;
import RN.links.ELinkType;
import RN.links.Link;
import RN.links.Weight;
import RN.nodes.INode;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public abstract class Linkage extends NetworkElement implements ILinkage {
	
	protected ELinkage linkageType = null;
	protected ELinkageBetweenAreas linkageAreas = ELinkageBetweenAreas.ONE_TO_MANY;
	protected List<Integer> targetedAreas = null;
	Boolean weightModifiable = Boolean.FALSE;
	protected Double[] params = null;
	protected IArea thisArea = null;
	protected Integer sampling = 1;
	
	// When we have no link, weights are stored here.
	protected static Map<Identification, Map<Identification, Link>> linksByTargetNode = new HashMap<Identification, Map<Identification, Link>>();
	protected static Map<Identification, Map<Identification, Link>> linksBySourceNode = new HashMap<Identification, Map<Identification, Link>>();
	
	
	@Override
	public abstract void sublayerFanOutLinkage(INode thisNode, ILayer sublayer);

	@Override
	public abstract void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT);

	@Override
	public abstract void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer);

	@Override
	public abstract void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT);
	

	
	public List<IArea> getLinkedAreas(){
		
		List<IArea> list = new ArrayList<IArea>();
		
		if(linkageAreas == ELinkageBetweenAreas.MANY_TO_ONE){
			
			if(targetedAreas == null || targetedAreas.isEmpty()){
				return thisArea.getPreviousLayer().getAreas();
			}else{
				
				for(IArea area : thisArea.getPreviousLayer().getAreas()){
					for(Integer id : targetedAreas){
						if(area.getAreaId() == id)
							list.add(area);
					}
				}
				
				return list;
				
			}
			
		}else if(linkageAreas == ELinkageBetweenAreas.ONE_TO_MANY){
			
			list.add(thisArea.getPreviousLayer().getArea(targetedAreas == null ? 0 : targetedAreas.get(0)));
			
		}else if(linkageAreas == ELinkageBetweenAreas.ONE_TO_ONE){
			
			list.add(thisArea.getPreviousLayer().getArea(thisArea.getAreaId()));
		}
		
		return list;
	}
	

	
	public IArea getLinkedArea(){
		
		if(thisArea.getLayer().isFirstLayer())
			return null;
		
		if(linkageAreas == ELinkageBetweenAreas.MANY_TO_ONE){
			
			return thisArea.getPreviousLayer().getAreas().get(0);
			
		}else if(linkageAreas == ELinkageBetweenAreas.ONE_TO_MANY){
			
			return thisArea.getPreviousLayer().getArea(targetedAreas == null ? 0 : targetedAreas.get(0));
			
		}else if(linkageAreas == ELinkageBetweenAreas.ONE_TO_ONE){
			
			if(targetedAreas == null){
				return thisArea.getLeftSibilingArea();
			}else{
				return thisArea.getPreviousLayer().getArea(targetedAreas.get(0));
			}
			
		}
		
		if(targetedAreas != null){
			return thisArea.getPreviousLayer().getArea(targetedAreas.get(0));
		}
		
		
		return null;
	}
	
	
	public double getLinkedSigmaPotentials(INode thisNode){
		
		Double sigmaWI = 0D;
		
		// somme des entrees pondérées
		for (Link input : thisNode.getInputs()) {
			if(getContext().getClock() == -1 || input.getFireTimeT() == getContext().getClock()){
				
				sigmaWI += input.getValue() * input.getWeight();
				
				input.synchFutureFire();
			}
			
		}
		
		// ajout du biais
		if (thisNode.getBiasInput() != null){
			if(getContext().getClock() == -1 || thisNode.getBiasInput().getFireTimeT() == getContext().getClock()){
				
				sigmaWI -= thisNode.getBiasInput().getValue() * thisNode.getBiasInput().getWeight();
				
				thisNode.getBiasInput().synchFutureFire();
			}
		}
		
		return sigmaWI;
	}
	
	public double getSigmaPotentials(INode thisNode){
		
		Double sigmaWI = 0D;
		
		if(network != null && network.getImpl() == ENetworkImplementation.UNLINKED){
			
			sigmaWI = getUnLinkedSigmaPotentials(thisNode);
			
		}else{
			
			sigmaWI = getLinkedSigmaPotentials(thisNode);
			
		}
		
		return sigmaWI;
		
	}
	
	
	public void addGraphicInterface(Pane pane){
	}
	
	public void prePropagation(){
	}
	
	public void postPropagation(){
	}
	

	public Boolean isWeightModifiable() {
		return weightModifiable;
	}

	@Override
	public void setWeightModifiable(boolean weightModifiable) {
		this.weightModifiable = weightModifiable;
	}
	
	@Override
	public void setParams(Double[] params){
		this.params = params;
	}
	
	@Override
	public Double[] getParams(){
		return this.params;
	}

	public ELinkage getLinkageType() {
		return linkageType;
	}

	public void setLinkageType(ELinkage linkageType) {
		this.linkageType = linkageType;
	}

	public IArea getArea() {
		return thisArea;
	}

	public void setArea(IArea thisArea) {
		this.thisArea = thisArea;
	}
	
	public void setSampling(Integer sampling){
		this.sampling = sampling;
	}

	public Integer getSampling() {
		return sampling;
	}

	public ELinkageBetweenAreas getLinkageAreas() {
		return linkageAreas;
	}

	public void setLinkageAreas(ELinkageBetweenAreas linkageAreas) {
		this.linkageAreas = linkageAreas;
	}

	public List<Integer> getTargetedAreas() {
		return targetedAreas;
	}

	public void setTargetedAreas(List<Integer> targetedArea) {
		this.targetedAreas = targetedArea;
	}
	
	public static Map<Identification, Map<Identification, Link>> getLinks() {
		return linksByTargetNode;
	}
	
	public static Map<Identification, Link> getInputLinks(Identification targetNodeId) {
		
		Map<Identification, Link> results = linksByTargetNode.get(targetNodeId);
		
		if(results == null){
			return new HashMap<Identification, Link>();
		}
		
		return results;
		
	}
	
	public Link getLink(Identification targetNodeId, Identification sourceNodeId, Link defaultWeight) {
		
		Link weight = linksByTargetNode.get(targetNodeId).get(sourceNodeId);
		
		if(weight == null)
			return defaultWeight;
		
		return weight;
	}

	private static void putLink(Identification targetNode, Identification sourceNode, Link link) {
		
		Map<Identification, Link> linksByTarget = linksByTargetNode.putIfAbsent(targetNode, new HashMap<Identification, Link>());
		if(linksByTarget != null){
			linksByTarget.put(sourceNode, link);
		}else{
			linksByTargetNode.get(targetNode).put(sourceNode, link);
		}
		
		Map<Identification, Link> linksBySource = linksBySourceNode.putIfAbsent(sourceNode, new HashMap<Identification, Link>());
		if(linksBySource != null){
			linksBySource.put(targetNode, link);
		}else{
			linksBySourceNode.get(sourceNode).put(targetNode, link);
		}
		
	}
	
	public static Link getLinkAndPutIfAbsent(INode targetNode, INode sourceNode, boolean isWeightModifiable) {
		return getLinkAndPutIfAbsent( targetNode, sourceNode, isWeightModifiable, null);
	}
	
	public static Link getLinkAndPutIfAbsent(INode targetNode, INode sourceNode, boolean isWeightModifiable, Weight weight) {
		
		Link link = null;
		Link defaultLink = null;
		
		try{
			
			link = linksByTargetNode.get(targetNode.getIdentification()).get(sourceNode.getIdentification());
			
		}catch(Throwable e){
			
			if(weight == null)
				defaultLink = Link.getInstance(ELinkType.REGULAR, isWeightModifiable);
			else
				defaultLink = Link.getInstance(weight, isWeightModifiable);
			
			defaultLink.setTargetNode(targetNode);
			defaultLink.setSourceNode(sourceNode);
			
			putLink(targetNode.getIdentification(), sourceNode.getIdentification(), defaultLink);
			link = defaultLink;
			
		}finally{
			
			if(link == null){
				
				if(weight == null)
					defaultLink = Link.getInstance(ELinkType.REGULAR, isWeightModifiable);
				else
					defaultLink = Link.getInstance(weight, isWeightModifiable);
				
				defaultLink.setTargetNode(targetNode);
				defaultLink.setSourceNode(sourceNode);
				
				putLink(targetNode.getIdentification(), sourceNode.getIdentification(), defaultLink);
				link = defaultLink;
			}
			
		}
		
		return link;
	}
	
	public static Map<Identification, Map<Identification, Link>> getLinksBySourceNode() {
		return linksBySourceNode;
	}

	public static void setLinksBySourceNode(Map<Identification, Map<Identification, Link>> linksBySource) {
		linksBySourceNode = linksBySource;
	}

	


}
package RN.linkage;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.Coordinate;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.links.ELinkType;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import RN.nodes.PixelNode;
import RN.utils.MathUtils;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.scene.control.Slider;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public class LogPolarLinkage extends FilterLinkage {
	
	private Slider numOrientsSlider = null;
	private Slider numScalesSlider = null;
	
	// cache radius by angle of concentric circles zones.
	private static Map<Integer, List<Coordinate>> retina = new HashMap<Integer, List<Coordinate>>();

	//Number of orientations (between 3 to 20) 8 is a typical value
	private Double n_t = null;
	
	//Number of scales of the multiresolution scheme
	private Double n_s = null;
	
	private Double base = null;
	
	private static boolean cleaningDone = false;
	


	public LogPolarLinkage() {
		cleaningDone = false;
	}
	

	
	public void initParameters() {
		
		if(params.length == 0)
			throw new RuntimeException("Missing Log Polar parameters' (theta)");
		
		
		n_t = params[0];
		
		if(params.length == 2)
			n_s = params[1];
		
		base = 1 + (Math.PI / (Math.sqrt(3D) * n_t));
		
		cleaningDone = false;
		
	}
	
	public void postPropagation(){
		
		if(!cleaningDone){
			System.out.println("Begin cleaning... Node's count is : " + getArea().getNodeCount());
			
			IAreaSquare subArea = (IAreaSquare) getLinkedArea();
			List<INode> nodesToRemove = new ArrayList<INode>();
			Coordinate coord = null;
			for(INode node : getArea().getNodes()){
				
				coord = isAtCenter(subArea, (PixelNode) node);
				
				if(coord == null){
					nodesToRemove.add((PixelNode) node);
				}
				
			}
			
			INode nodeToRemove = null;
			for(int idx=0; idx < nodesToRemove.size(); idx++){
				nodeToRemove = nodesToRemove.get(idx);
				getArea().removeNode(nodeToRemove);
			}
			
			nodesToRemove = null;
			
			
			System.out.println("Layer cleared. (Pixels deleted) Node's count is now : " + getArea().getNodeCount());
			
			cleaningDone = true;
		}
		
	}



	
	private void concentricCircleCenters(IAreaSquare area, Double angleCount, Double scaleCount) {
		
		
		double arc = 2D * Math.PI / angleCount;
		double p_fovea = angleCount / (2D * Math.PI);
		
		Double p_r = null;
		
		//double t_radius = arc * 1/3;
		
		double theta = 0D;
		List<Coordinate> ys = null;
		Coordinate coord = null;
		Integer idScale = 0;
		/*for(int idScale=0; idScale <= scaleCount; idScale++)*/
		do{
			
			for(int idAngle=0; idAngle <= angleCount; idAngle++){
				
				theta = arc * (idAngle + MathUtils.odd(idScale) / 2D);
				p_r = p_fovea * Math.pow(this.base, idScale);
				
				coord = new Coordinate();
				coord.setBase(this.base);
				coord.setTheta(theta);
				coord.setP(p_r);
				coord.setX0((double) ((IAreaSquare) getArea()).getNodeCenterX());
				coord.setY0((double) ((IAreaSquare) getArea()).getNodeCenterY());
				coord.logPolarToLinearSystem();
				
				if(retina.containsKey(coord.getX().intValue())){
					retina.get(coord.getX().intValue()).add(coord);
				}else{
					ys = new ArrayList<Coordinate>();
					ys.add(coord);
					retina.put(coord.getX().intValue(), ys);
				}
				
			}
			
			idScale++;
			
			if(scaleCount != null && idScale == scaleCount.intValue())
				break;
			
		}while( (Math.abs(coord.getX()) <= area.getWidthPx()) && Math.abs(coord.getY()) <= area.getHeightPx());
		
	}
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		// somme des entrees pondérées
		SigmaWi sigmaWI = new SigmaWi();
		
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		IPixelNode pix = (IPixelNode) thisNode;
		
		Double t_radius = null;
		Coordinate coord = isAtCenter(subArea, pix);
		
		if(coord != null){
			
			t_radius = (2D * Math.PI * coord.getP()) / (3D * n_t);
			
//			for(IPixelNode innerPix : pix.getAreaSquare().getNodesOnCirclarPerimeter(pix.getX(), pix.getY(), t_radius.intValue())){
//				((INode)innerPix).setComputedOutput(1D);
//			}
			
			// Champ récépteur
			List<IPixelNode> pixels = subArea.getNodesInCirclarZone(pix.getX(), pix.getY(), t_radius.intValue());
			System.out.println(pix + " : " + pixels.size() + " pixels.");
			for(IPixelNode innerPix : pixels){
				// Cellule ON/OFF center exitateur, pourtour inihibiteur
				if(innerPix.distance(pix) <= t_radius / 2D)
					sigmaWI.sum(innerPix.getComputedOutput());
				else
					sigmaWI.sum(-innerPix.getComputedOutput());
			}
			
		}
		
		//return thisNode.getComputedOutput();
		return sigmaWI.value();
	}
	
	private Coordinate isAtCenter(IAreaSquare area, IPixelNode pix) {
		
		if(retina.isEmpty()){
			concentricCircleCenters(area, n_t, n_s);
		}
		
		List<Coordinate> ysByXs = retina.get(pix.getX());
		
		if(ysByXs != null){
			for(Coordinate coord : ysByXs){
				if(coord != null && Math.abs(coord.getY() - pix.getY()) < 0.5D)
					return coord;
			}
		}
		
		return null;
	}



	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		IPixelNode pix = (IPixelNode) thisNode;
		
		Double t_radius = null;
		Coordinate coord = isAtCenter(subArea, pix);
		
		if(coord != null){
			
			t_radius = (2D * Math.PI * coord.getP()) / (3D * n_t);
			
//			for(IPixelNode innerPix : pix.getAreaSquare().getNodesOnCirclarPerimeter(pix.getX(), pix.getY(), t_radius.intValue())){
//				((INode)innerPix).setComputedOutput(1D);
//			}
			
			// Champ récépteur
			for(IPixelNode innerPix : subArea.getNodesInCirclarZone(pix.getX(), pix.getY(), t_radius.intValue())){
				// Cellule ON/OFF center exitateur, pourtour inihibiteur
				if(innerPix.distance(pix) <= t_radius / 2D)
					innerPix.link(thisNode, ELinkType.REGULAR, isWeightModifiable(), 1D);
				else
					innerPix.link(thisNode, ELinkType.REGULAR, isWeightModifiable(), -1D);
			}
			
		}
		
	}
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		// Calcul du filtre Log-Gabor
		return  InputSample.getInstance().compute(
				filterFunction, 
				(double) subArea.getWidthPx(),
				getN_t(),
				getN_s(),
				(double) (sublayerNode.getX() - subArea.getWidthPx() / 2D) * 4D,
				(double) (sublayerNode.getY() - subArea.getHeightPx() / 2D) * 4D
				);
		
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}
	
	public void addGraphicInterface(Pane pane) {
		
		TextField logTF = new TextField("");
		
		numOrientsSlider = new Slider(0D, 360D, n_t);
		numOrientsSlider.setBlockIncrement(1D);
		
		double numScales = 0D;
		if(n_s == null)
			numScales = 0D;
		else
			numScales = n_s;
		
		numScalesSlider = new Slider(0D, 8D, numScales);
		numScalesSlider.setBlockIncrement(1D);
		
		
		HBox hbox = new HBox();
		hbox.getChildren().addAll(logTF);
		HBox hbox2 = new HBox();
		hbox2.getChildren().addAll(numOrientsSlider, numScalesSlider);
		
		
		numOrientsSlider.valueProperty().addListener(new ChangeListener<Number>() {
			public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
				setN_t(new_val.doubleValue());
				retina.clear();
				logTF.setText("num orientations = " + new_val.doubleValue());
				try {
//					FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_GABOR_LOG);
//					FilterLinkage.removeFilter(idx);
					Double[] outputs = null;
					thisArea.propagation(false, outputs);
					((IAreaSquare) thisArea).showImageArea();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
		
		numScalesSlider.valueProperty().addListener(new ChangeListener<Number>() {
			public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
				setN_s(new_val.doubleValue());
				retina.clear();
				logTF.setText("num scales = " + new_val.doubleValue());
				try {
//					FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_GABOR_LOG);
//					FilterLinkage.removeFilter(idx);
					Double[] outputs = null;
					thisArea.propagation(false, outputs);
					((IAreaSquare) thisArea).showImageArea();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
		
		
		pane.getChildren().addAll(hbox, hbox2);
		
	}


	public Double getN_t() {
		return n_t;
	}



	public void setN_t(Double n_t) {
		this.n_t = n_t;
	}



	public Double getN_s() {
		return n_s;
	}



	public void setN_s(Double n_s) {
		this.n_s = n_s;
	}



}
package RN.linkage;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.nodes.INode;
import RN.nodes.IPixelNode;

/**
 * @author Eric Marchand
 *
 */
public class LOGStaticLinkage extends LaplacianOfGaussianLinkage {

	// Coefficients issus du calcul avec :
	//	double N = 3D;
	//	double deltaX = 1;
	//	double k = 4D;
	//	double Ox = (N-1) * deltaX / k;
	//	double Oy = Ox;
	//	double alpha = 1D;
	//	double Mu = 0D;
	
	
	// Matrice carrée d'ordre N
	private static int N = 5;
	
	private static Double[][] staticFilter = new Double[][]{
																	{ 0.00, 0.00, 0.01, 0.00, 0.00 },
																	{ 0.00, 0.28, 0.69, 0.28, 0.00 },
																	{ 0.01, 0.69, -5.09, 0.69, 0.01},
																	{ 0.00, 0.28, 0.69, 0.28, 0.00 },
																	{ 0.00, 0.00, 0.01, 0.00, 0.00 }};
																	
																	

	public LOGStaticLinkage() {
	}
	
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		SigmaWi sigmaWI = new SigmaWi();
			
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		initFilter(this, ID_FILTER_LOG_STATIC, null, (IPixelNode) thisNode, subArea);
		
		subArea.applyConvolutionFilter(this, ID_FILTER_LOG_STATIC, (IPixelNode) thisNode, sigmaWI);
			
		
		return sigmaWI.value();
	}
	
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		initFilter(this, ID_FILTER_LOG_STATIC, null, (IPixelNode) thisNode, subArea);
		
		subArea.applyConvolutionFilter(this, ID_FILTER_LOG_STATIC, (IPixelNode) thisNode, 0.0001f);
	}
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		int x = ((IPixelNode) sublayerNode).getX();
		int y = ((IPixelNode) sublayerNode).getY();
		
		int centerX = subArea.getNodeCenterXY().getX();
		int centerY = subArea.getNodeCenterXY().getY();
		
		int Xmat = x - centerX + ( (N-1) / 2 );
		int Ymat = y - centerY + ( (N-1) / 2 );
		
		if(Xmat >= 0 && Xmat <= (N-1) && Ymat >= 0 && Ymat <= (N-1)){
			return staticFilter[Xmat][Ymat];
		}
		
		return 0D;
	}

}
package RN.linkage;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.links.ELinkType;
import RN.nodes.INode;
import RN.nodes.IPixelNode;

/**
 * @author Eric Marchand
 *
 */
public class MapLinkage extends FilterLinkage {

	Integer stride = null;
	Integer mapWidth = null;
	
	public MapLinkage() {
	}
	
	public MapLinkage(Integer sampling) {
		this.sampling = sampling;
	}
	
	public void initParameters() {
		
		if(params[0] != null)
			mapWidth = params[0].intValue();
		
		
		if(params[1] != null)
			stride = params[1].intValue();
		
	}
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		IPixelNode pix = (IPixelNode) thisNode;
		
		Double max = null;
			
		for(IPixelNode subPix : subArea.getNodesInSquareZone(pix.getX() * stride, pix.getY() * stride, mapWidth, mapWidth)){
			max = (max == null ? subPix.getComputedOutput() : Math.max(subPix.getComputedOutput(), max)); 
		}
			
		
		return max == null ? 0D : max;
	}
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		IPixelNode pix = (IPixelNode) thisNode;
		
		IPixelNode maxNode = null;
		
			
		for (IPixelNode subPix : subArea.getNodesInSquareZone(pix.getX() * stride, pix.getY() * stride, mapWidth, mapWidth)) {
			if(maxNode == null || subPix.getComputedOutput() > maxNode.getComputedOutput())
				maxNode = subPix;
		}

		if(maxNode != null)
			maxNode.link(thisNode, ELinkType.REGULAR, isWeightModifiable());
		
	}
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		// Calcul du filtre gaussien
		return  InputSample.getInstance().compute(
				filterFunction, 
				(double) sublayerNode.getX(),
				(double) sublayerNode.getY(), 
				(double) sampling
				);
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}


}
package RN.linkage;

import java.util.ArrayList;
import java.util.List;

import RN.IArea;
import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.nodes.INode;
import RN.nodes.IPixelNode;

/**
 * @author ericmarchand
 * 
 */
public class MaxLinkage extends FilterLinkage {

	
	Integer stride = null;
	Integer filterWidth = null;
	Integer halfWidth = null;
	
	private static List<IPixelNode> maxMinNodes = new ArrayList<IPixelNode>();
	
	
	//private static Double[][] staticFilter = null;
	

	public MaxLinkage() {
	}
	
	public MaxLinkage(Integer sampling) {
		this.sampling = sampling;
	}
	
	/* (non-Javadoc)
	 * @see RN.linkage.ILinkage#initParameters()
	 */
	public void initParameters() {
		
		if(params[0] != null)
			filterWidth = params[0].intValue();
		
		if(params[1] != null)
			stride = params[1].intValue();
		
		halfWidth = ((filterWidth - 1) / 2);
		
//		staticFilter = new Double[filterWidth][filterWidth];
//		
//		for(int y=0; y < filterWidth; y++){
//			for(int x=0; x < filterWidth; x++){
//				staticFilter[x][y] = 1D;
//			}
//		}
		
	}
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		// somme des entrees pondérées
		//SigmaWi sigmaWI = new SigmaWi();
		IPixelNode pix = (IPixelNode) thisNode;
		
		
		IAreaSquare subArea = null;
		IPixelNode centerPix = null;

		List<IPixelNode> nodesInSquare = null;
		
		boolean isMinMax = true;
		
		int x = pix.getX() * stride;
		int y = pix.getY() * stride;
		int x0 = x - halfWidth;
		int y0 = y - halfWidth;
		
		for(IArea area : getLinkedAreas()){
			
			isMinMax = true;
			
			 subArea = (IAreaSquare) area;
			 centerPix = subArea.getNodeXY(x, y);
			 
			 if(isMinMax && centerPix.getPreviousAreaSquare() != null){
				 nodesInSquare = centerPix.getPreviousAreaSquare().getNodesInSquareZone(x0, y0, filterWidth, filterWidth);
				 isMinMax &= isMinMax(centerPix, nodesInSquare);
			 }
			 
			 if(isMinMax){
				 nodesInSquare = subArea.getNodesInSquareZone(x0, y0, filterWidth, filterWidth);
				 isMinMax &= isMinMax(centerPix, nodesInSquare);
			 }
			 
			 if(isMinMax && centerPix.getNextAreaSquare() != null){
				 nodesInSquare = centerPix.getNextAreaSquare().getNodesInSquareZone(x0, y0, filterWidth, filterWidth);
				 isMinMax &= isMinMax(centerPix, nodesInSquare);
			 }
			 
			 if(isMinMax){
				 maxMinNodes.add(pix);
				 //return 1D;
				 return centerPix.getComputedOutput();
			 }
			
		}
			
		return  0D;
	}
	
	private boolean isMinMax(IPixelNode centerPix, List<IPixelNode> nodesInSquare){
		
		boolean isMin = true;
		boolean isMax = true;
		
		for(IPixelNode node : nodesInSquare){
			
			if(node == centerPix)
				continue;
			
			isMin &= centerPix.compareOutputTo(node) < 0D;
			isMax &= centerPix.compareOutputTo(node) > 0D;
				
			if(!isMin && !isMax)
				return false;
		}
		
		return true;
		
	}
	
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();

		//initFilter(this, ID_FILTER_MAX_POOLING, null, (IPixelNode) thisNode, subArea);
		
		subArea.applyMaxPoolingFilter(this, filterWidth, stride, (IPixelNode) thisNode);
	}
	
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
//		int x = sublayerNode.getX();
//		int y = sublayerNode.getY();
//		
//		if(x >= 0 && x <= (filterWidth-1) && y >= 0 && y <= (filterWidth-1)){
//			return staticFilter[x][y];
//		}
		
		return 0D;
	}




	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	public static List<IPixelNode> getMaxMinNodes() {
		return maxMinNodes;
	}

	public static void setMaxMinNodes(List<IPixelNode> maxMinNodes) {
		MaxLinkage.maxMinNodes = maxMinNodes;
	}
	
}
package RN.linkage;

import RN.IArea;
import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.nodes.INode;
import RN.nodes.IPixelNode;

/**
 * @author ericmarchand
 * 
 */
public class MaxPoolingLinkage extends FilterLinkage {

	
	Integer stride = null;
	Integer filterWidth = null;
	
	

	public MaxPoolingLinkage() {
	}
	
	public MaxPoolingLinkage(Integer sampling) {
		this.sampling = sampling;
	}
	
	/* (non-Javadoc)
	 * @see RN.linkage.ILinkage#initParameters()
	 */
	public void initParameters() {
		
		if(params[0] != null)
			filterWidth = params[0].intValue();
		
		if(params[1] != null)
			stride = params[1].intValue();
		
		
	}
	
	/* (non-Javadoc)
	 * @see RN.linkage.Linkage#getLinkedSigmaPotentials(RN.nodes.INode)
	 */
	@Override
	public double getLinkedSigmaPotentials(INode thisNode){
		
		// Max Pooling depends on the outputs' computed of the previous layer
		// We can't links the nodes for the maxpooling process during the 'finalize network connections' phase, 
		// because previous layer outputs' are not yet computed.
		// So the linking is done during the feed-forward propagation.
		IAreaSquare subArea = null;
		for(IArea area : getLinkedAreas()){
			 subArea = (IAreaSquare) area;
					
			subArea.applyMaxPoolingFilter(this, filterWidth, stride, (IPixelNode) thisNode);
		
		}
			
		return super.getLinkedSigmaPotentials(thisNode);
	}
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		// Max Pooling depends on the outputs' computed of the previous layer
		// We can't get the max value for the maxpooling process during the 'finalize network connections' phase, 
		// because previous layer outputs' are not yet computed.
		// So this is done during the feed-forward propagation.
		
		// somme des entrees pondérées
		SigmaWi sigmaWI = new SigmaWi();
		
		IAreaSquare subArea = null;
		for(IArea area : getLinkedAreas()){
			 subArea = (IAreaSquare) area;
					
			subArea.applyMaxPoolingFilter(this, filterWidth, stride, (IPixelNode) thisNode, sigmaWI);
		
		}
			
		return sigmaWI.value();
	}
	
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {

	}
	
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		
		return 0D;
	}




	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}
	
}
package RN.linkage;

import RN.AreaSquare;
import RN.IArea;
import RN.ILayer;
import RN.links.ELinkType;
import RN.nodes.INode;
import RN.nodes.IPixelNode;

/**
 * @author Eric Marchand
 *
 */
public class OneToOneFetchAreaLinkage extends Linkage {

	
	
	public OneToOneFetchAreaLinkage() {
	}

	
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		Double sigmaWI = 0D;
		
		// somme des entrees pondérées
		ILayer previouslayer = thisNode.getArea().getPreviousLayer();
		if(previouslayer != null){
			
			
			INode sourceNode = null;
			for(IArea area : getLinkedAreas()){
				
				if(area instanceof AreaSquare && thisNode.getArea() instanceof AreaSquare){
					sourceNode = (INode) ((AreaSquare) area).getNodeXY(((IPixelNode)thisNode).getX(), ((IPixelNode)thisNode).getY(), sampling);
					sigmaWI += sourceNode.getComputedOutput();
				}else{
					sourceNode = area.getNode(thisNode.getNodeId());
					sigmaWI += sourceNode.getComputedOutput();
				}
				
			}
			
		}else{
			//if(getContext().getClock() == -1 || input.getFireTimeT() == getContext().getClock()){
			sigmaWI = thisNode.getInputValue() ; //* input.getWeight();
				//input.synchFutureFire();
			//}
				
		}
		
		if(thisNode.getBiasWeightValue() != null)
			sigmaWI -= thisNode.getBiasWeightValue();
		
		return sigmaWI;
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer previouslayer) {
		
		if(previouslayer != null){
			
			try{
					
				for(IArea area : getLinkedAreas()){
					
					if(area instanceof AreaSquare && thisNode.getArea() instanceof AreaSquare ){
						((AreaSquare) area).getNodeXY(((IPixelNode)thisNode).getX(), ((IPixelNode)thisNode).getY(), sampling).link(thisNode, ELinkType.REGULAR, false, 1D);
					}else{
						area.getNode(thisNode.getNodeId()).link(thisNode, ELinkType.REGULAR, false, 1D);
					}
				}
				
			}catch(Exception e){
				System.err.println("Unable to fan out one to one linkage from node :" + thisNode.getIdentification());
			}
			
		}else{
			thisNode.incomingLink(ELinkType.REGULAR);
		}
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void initParameters() {
		// TODO Auto-generated method stub
		
	}




}
package RN.linkage;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.linkage.vision.EKeyPointType;
import RN.linkage.vision.Gradient;
import RN.linkage.vision.Histogram;
import RN.linkage.vision.KeyPoint;
import RN.linkage.vision.KeyPointDescriptor;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import RN.nodes.PixelNode;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public class OneToOneFetchOctaveAreaLinkage extends FilterLinkage {

	// GAUSSIENNE ELLIPTIQUE
	private Double mu = null;

	// centre
	private Double x1 = null;
	private Double y1 = null;

	// amplitude, hauteur de la forme pixelisée
	private Double alpha = null;

	// ecartement selon x et y
	private Double ox = null;
	private Double oy = null;
	
	// seuil de suppression des pixels de bas contraste
	private double C = 0.05D;
	
	private static int maxSuppressed = 0;
	private static int minSuppressed = 0;
	
	private static List<KeyPoint> keyPoints = new ArrayList<KeyPoint>();
	
	public OneToOneFetchOctaveAreaLinkage() {
	}

	
	public void initParameters() {
		
//		Le traitement repose sur cinq paramètres :
//		
//			N représente la taille du masque (matrice carrée) implantant le filtre LOG. N est impair.
//			σ permet d'ajuster la taille du chapeau mexicain.
//			∆x et ∆y sont les pas d'échantillonnage utilisés pour discrétiser h''(x,y). Généralement ∆x = ∆ y
//			S est le seuil qui permet de sélectionner les contours les plus marqués.
//		
//			Il est à noter que le choix des paramètres N, σ et ∆x ne doit pas se faire de façon indépendante. 
//  		En effet, le masque, même de taille réduite, doit ressembler à un chapeau mexicain. Le problème ici est le même que celui que l'on rencontre lors de l'échantillonnage d'une fonction gaussienne. 
//          Le nombre de points N à considérer doit être tel que l'étendue occupe l'intervalle [-3σ , 3σ].
//			En fonction du pas d'échantillonnage, l'étendue spatiale vaut : (N-1) ∆x  .
//			Cette étendue peut aussi s'écrire en fonction de σ : (N-1) ∆x = kσ  avec k entier.
//			En prenant par exemple  ∆x = 1 , il s'agit de choisir N et σ de sorte que l'étendue du chapeau mexicain soit pertinente. 
//  		Pour le chapeau mexicain, la valeur de k doit être au moins de 4.
		
//		double N = 9D;
//		double deltaX = 1D;
		
//		ox = (N-1) * deltaX / k;
		ox = 0.5D;
		oy = ox;
		alpha = 1D;
		mu = 0D;
		
	}
	
	public double getUnLinkedSigmaPotentials(INode thisNode) {

		Double sigmaWI = 0D;
		List<KeyPoint> maxPointInterest = null;
		List<KeyPoint> minPointInterest = null;

		// somme des entrees pondérées
		ILayer previousLayer = thisNode.getArea().getPreviousLayer();
		IAreaSquare area = null;
		for (int idxArea = 0; idxArea < previousLayer.getAreaCount(); idxArea++) {
			area = (IAreaSquare) previousLayer.getArea(idxArea);

			maxPointInterest = maxLocal(area, (IPixelNode) thisNode);
			if (maxPointInterest != null) {
				sigmaWI = 1D;
				// for(KeyPoint maxKP : maxPointInterest){
				// sigmaWI += maxKP.getValue();
				// }
			}

			minPointInterest = minLocal(area, (IPixelNode) thisNode);
			if (minPointInterest != null) {
				sigmaWI = 1D;
				// for(KeyPoint minKP : minPointInterest){
				// sigmaWI += Math.abs(minKP.getValue());
				// }
			}

		}

		if (thisNode.getBiasWeightValue() != null)
			sigmaWI -= thisNode.getBiasWeightValue();

		return sigmaWI;
	}
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		List<KeyPoint> maxPointInterest = null;
		List<KeyPoint> minPointInterest = null;
		
		
//		// somme des entrees pondérées
//		if(sublayer != null){
//			
//			for(IArea area : sublayer.getAreas()){
//				
//					if(area.getAreaId() > 0 && area.getAreaId() < sublayer.getAreas().size() - 1){
//							
//						maxPointInterest = maxLocal(area, (IPixelNode) thisNode);
//						if(maxPointInterest != null){
//							for(KeyPoint maxKP : maxPointInterest){
//								maxKP.getKeyPointNode().link(thisNode, ELinkType.REGULAR, false, maxKP.getValue());
//							}
//						}
//						
//						minPointInterest = minLocal(area, (IPixelNode) thisNode);
//						if(minPointInterest != null){
//							for(KeyPoint minKP : minPointInterest){
//								minKP.getKeyPointNode().link(thisNode, ELinkType.REGULAR, false, minKP.getValue());
////								sigmaWI += Math.abs(minKP.getValue());
//							}
//						}
//							
//					}
//				
//			}
//			
//		}else{
//			thisNode.incomingLink(ELinkType.REGULAR);
//		}
		
	}
	
	
	
	public List<KeyPoint> maxLocal(IAreaSquare area, IPixelNode thisNode){
		
		IPixelNode interestPointNode =  area.getNodeXY(thisNode.getX(), thisNode.getY());
		IAreaSquare gaussianArea = (IAreaSquare) interestPointNode.getAreaSquare().getLeftSibilingArea();
		
		boolean isMax = true;
		
//		if(interestPointNode.getComputedOutput() < C)
//			return null;
		
		if(interestPointNode.getPreviousAreaSquare() != null){
			isMax &= maxLocalOnArea(interestPointNode, interestPointNode.getPreviousAreaSquare().getNode(interestPointNode.getNodeId()));
			if(!isMax)
				return null;
		}
		
		isMax &= maxLocalOnArea(interestPointNode, interestPointNode);
		if(!isMax)
			return null;
		
		if(interestPointNode.getNextAreaSquare() != null){
			isMax &= maxLocalOnArea(interestPointNode, interestPointNode.getNextAreaSquare().getNode(interestPointNode.getNodeId()));
			if(!isMax)
				return null;
		}
		
		if(!hessianCriterion(thisNode, interestPointNode)){
			maxSuppressed++;
			return null;
		}
		
		List<KeyPoint> maxKeyPoints = computeSegmentedOrientationsAtKeyPoint(EKeyPointType.MAX, interestPointNode, gaussianArea);
		
		computeDescriptors(maxKeyPoints);
		
		return maxKeyPoints;
		
	}
	
	public List<KeyPoint> minLocal(IAreaSquare area, IPixelNode thisNode){
		
		boolean isMin = true;
		
		IPixelNode interestPointNode =  area.getNodeXY(thisNode.getX(), thisNode.getY());
		IAreaSquare gaussianArea = (IAreaSquare) interestPointNode.getAreaSquare().getLeftSibilingArea();
		
//		if(interestPointNode.getComputedOutput() < C)
//			return null;
		
		if(interestPointNode.getPreviousAreaSquare() != null){
			isMin &= minLocalOnSameArea(interestPointNode, interestPointNode.getPreviousAreaSquare().getNode(interestPointNode.getNodeId()));
			if(!isMin)
				return null;
		}
		
		isMin &= minLocalOnSameArea(interestPointNode, interestPointNode);
		if(!isMin)
			return null;
		
		if(interestPointNode.getNextAreaSquare() != null){
			isMin &= minLocalOnSameArea(interestPointNode, interestPointNode.getNextAreaSquare().getNode(interestPointNode.getNodeId()));
			if(!isMin)
				return null;
		}
		
		if(!hessianCriterion(thisNode, interestPointNode)){
			minSuppressed++;
			return null;
		}
		
		List<KeyPoint> minKeyPoints = computeSegmentedOrientationsAtKeyPoint(EKeyPointType.MIN, interestPointNode, gaussianArea);
		
		computeDescriptors(minKeyPoints);
		
		return minKeyPoints;
		
		
	}
	

	private List<KeyPointDescriptor> computeDescriptors(List<KeyPoint> maxKeyPoints) {
		
		List<KeyPointDescriptor> descriptors = new ArrayList<KeyPointDescriptor>();
		
		for(KeyPoint kp : maxKeyPoints){
			
			// Rotation de l'axe des absisses sur le gradient du point d'interet
			// Calcul des gradients dans chacune des cellules de la zone des 16x16 pixels.
			Gradient[][] gradients = computeRotatedGridGradients(kp, 16);
	
			// Création d'une grille 4x4 autour du point d'interet.
			// Calcul d'histogrammes de 9 orientations dans chacune des cellules.
			// Normalisation des valeurs des gradients.
			// Création des vecteurs descripteurs de 4x4x8 dimensions par point d'interet.
			descriptors.add(computeGridXBinsHistograms(kp, gradients, 9, 16, 4));
			
			// Normalisation des descripteurs.
			normalizeDescriptor(kp);
		
		}
		
		return descriptors;
		
	}


	private void normalizeDescriptor(KeyPoint kp) {
		
	}


	private KeyPointDescriptor computeGridXBinsHistograms(KeyPoint kp, Gradient[][] gradients, int binCount, int matrixOrder, int cellSizeOrder) {
		
		KeyPointDescriptor descriptor = new KeyPointDescriptor();
		kp.setDescriptor(descriptor);
		
		int gridHalfWidth = matrixOrder / 2;
		
		// radius + overlapping
		int radius = cellSizeOrder / 2 + 1;
		
		// TODO Change it to 28 foveal gaussian overlapping zones
		// Blocks' iteration.
		// Each block point's starts at top left.
		for(int cellY = - gridHalfWidth; cellY <= gridHalfWidth; cellY += cellSizeOrder){
			for(int cellX = - gridHalfWidth; cellX <= gridHalfWidth; cellX += cellSizeOrder){
				
				try {
					descriptor.concatenateHistogram(computeHistogram(kp, binCount, getGradientsInCircularOverlappingZone(cellX + kp.getX().intValue(), cellY + kp.getY().intValue(), radius, gradients)));
				} catch (Exception e) {
					e.printStackTrace();
					System.err.println("Calcul de l'histogramme 8 bins impossible pour : " + kp + " cellX : " + cellX + "  cellY : ");
				}
				
			}
		
		}
		
		return descriptor;
		
	}
	
	
	private Histogram computeHistogram(KeyPoint kp, int binsCount, List<Gradient> gradientsInOverlappingBlock) {
		
		Histogram histogram = new Histogram();
		Double value = null;
		
		for (Gradient gradient : gradientsInOverlappingBlock) {
				
				Double segmentedIdx = getSegmentedAngleDegree(gradient.getTheta(), 360D / binsCount);
				
				value = gradient.getMagnitude() * gradient.getDistanceToKeyPoint() * kp.getKeyPointNode().getComputedOutput();
				
				// Normalize vote with small constant e = 0.333
				value = value / Math.sqrt(Math.pow(value, 2) + Math.pow(0.333, 2));
				
				histogram.putIfAbsent(segmentedIdx, 0D);
				histogram.put(segmentedIdx, histogram.get(segmentedIdx) + value);
		}
		
		return histogram;
	}
	

	
	/**
	 * Return nodes in a circlar zone
	 * @param x0 x center point
	 * @param y0 y center point
	 * @param radius
	 * @return List<Gradient>
	 * @throws Exception
	 */
	public List<Gradient> getGradientsInCircularOverlappingZone(int x0, int y0, int radius, Gradient[][] gradients) {
		List<Gradient> gradientList = new ArrayList<Gradient>();
		for(int y = y0 - radius; y < y0 + radius; y++){
			for(int x = x0 - radius; x < x0 + radius; x++){
				double distance = Math.sqrt(Math.pow(x0 - x, 2D) + Math.pow(y0 - y, 2D));
				if(distance <= radius){
					try {
						gradientList.add(gradients[x][y]);
					} catch (Exception ignore) {
						//e.printStackTrace();
						//System.err.println("getGradientsInCircularOverlappingZone() : Impossible de recuperer le gradient pour (x,y) = " + x + "," + y + ")" );
					}
				}
			}
		}
		return gradientList;
	}


	private Gradient[][] computeRotatedGridGradients(KeyPoint kp, int matrixOrder) {
		
			PixelNode neighbor = null;
			Gradient[][] gradients = new Gradient[matrixOrder][matrixOrder];
			int halfWidth = matrixOrder / 2;
			Gradient gradient = null;
			for(int y = - halfWidth; y < halfWidth; y++){
				for(int x = - halfWidth; x < halfWidth; x++){
					
					neighbor = (PixelNode) kp.getKeyPointNode().getAreaSquare().getNodeXY(x + kp.getX().intValue(), y + kp.getY().intValue(), kp.getX().intValue(), kp.getY().intValue(), -kp.getTheta());
					
					if(neighbor == null)
						continue;
					
					gradient = kp.getGradient(neighbor.getX() - kp.getX().intValue(), neighbor.getY() - kp.getY().intValue()); 
					
					if(gradient == null)
						continue;
					
					gradient.setTheta(gradient.getTheta() - kp.getTheta());
					gradients[x + halfWidth][y + halfWidth] = gradient;
					
				}
			}
			
			// Magnitude Threshold at 0.1 times the max for illumination stability
			gradientThreshold(gradients);
			
			return gradients;
	}

	// TODO
	// 1.6D / Math.sqrt(D) with D is the descriptor dimensionality 
	private void gradientThreshold(Gradient[][] gradients, double threshold) {
		for(int idy = 0; idy < gradients.length; idy++){
			for(int idx = 0; idx < gradients[idy].length; idx++){
				gradients[idx][idy].thresholdAt(threshold);
			}
		}
	}
	
	private void gradientThreshold(Gradient[][] gradients) {
		for(int idy = 0; idy < gradients.length; idy++){
			for(int idx = 0; idx < gradients[idy].length; idx++){
				if(gradients[idx][idy] != null){
					gradients[idx][idy].thresholdAtMax(0.1D);
				}
			}
		}
	}
	
	
	
	
	private Gradient[][] computeGradients(IPixelNode interestPtNode, IAreaSquare gradientArea) {
		
		// Gradients on G * I
		Gradient gradient = null;
		GaussianLinkage dogLinkage = (GaussianLinkage) gradientArea.getLinkage();
		IPixelNode centerKpNode = gradientArea.getNodeXY(interestPtNode.getX(), interestPtNode.getY());
		
		// Sigma is 3 times that of the current smoothing scale.
		// More over, we use the calcul of the FWHM to evaluate the radius at 1/1000 from 0 on y.
		// y= σ * sqrt{2ln(1000)} + x_{center}
		// radius = 3 * σ * sqrt{2ln(1000)} + x_{center}
		Long radius = Math.round(dogLinkage.getK() * dogLinkage.getSigmaX() * 11.1501D);
		
		
		int gradientWidth = 2*radius.intValue();
		Gradient[][] gradients = new Gradient[gradientWidth][gradientWidth];

		List<IPixelNode> neighborhood = gradientArea.getNodesInCirclarZone(centerKpNode.getX(), centerKpNode.getY(), radius.intValue());
		//gradientArea.pixelsToString(neighborhood);
		
		IPixelNode pix = null;
		int idx;
		int idy;
		for (IPixelNode neighbor : neighborhood) {
				
				pix = (IPixelNode) neighbor;
				gradient = computeGradient(centerKpNode, neighbor);
				
				idx = pix.getX() - centerKpNode.getX() + radius.intValue();
				idy = pix.getY() - centerKpNode.getY() + radius.intValue();
				
				if(gradient != null && idx >= 0 && idx < gradientWidth && idy >= 0 && idy < gradientWidth)
					gradients[idx][idy] = gradient;
				
		}
		
		// Magnitude Threshold at 0.1 times the max for illumination stability
		gradientThreshold(gradients);
		
		return gradients;
}


	private List<KeyPoint> computeSegmentedOrientationsAtKeyPoint(EKeyPointType kpType, IPixelNode interestPointNode, IAreaSquare gaussianArea) {
		
		List<KeyPoint> localKeyPoints = new ArrayList<KeyPoint>();
		Map<Double,Double> neighboorsGradientsByTheta = new HashMap<Double,Double>();
		double f = 1.5D;
		Double magnitude = null;
		Double magnitudeMax = null;
		Double segmentedIdx = null;
		
		// Calcul d'un histogramme sur une zone circulaire gaussienne
		Gradient[][] gradients = computeGradients(interestPointNode, gaussianArea);
		
		for(Gradient[] gradientRow : gradients){
			for(Gradient gradient : gradientRow){
				
				if(gradient == null)
					continue;
				
				magnitude = gradient.getMagnitude() * gradient.getDistanceToKeyPoint() ; //* interestPointNode.getComputedOutput();
				
				segmentedIdx = getSegmentedAngleDegree(gradient.getTheta(), 10D);
				
				neighboorsGradientsByTheta.putIfAbsent(segmentedIdx, 0D);
				neighboorsGradientsByTheta.put(segmentedIdx, neighboorsGradientsByTheta.get(segmentedIdx) + magnitude);
			}
		}
		
		Comparator<Double> comp = (p1, p2) -> Double.compare( p1.doubleValue(), p2.doubleValue());
		magnitudeMax = neighboorsGradientsByTheta.values().stream().max(comp).get();

		// Suppression des orientations < 80% du max et création des points d'interets ainsi que les supplémentaires.
		GaussianLinkage dogLinkage = (GaussianLinkage) gaussianArea.getLinkage();
		
		Iterator<Entry<Double, Double>> it = neighboorsGradientsByTheta.entrySet().iterator();
		KeyPoint kp = null;
		while (it.hasNext())
		{
		   Entry<Double, Double> entry = it.next();
		   
			if(Math.abs(entry.getValue() / magnitudeMax) < 0.8D){
				it.remove();
			}else{
				kp = new KeyPoint(kpType, interestPointNode, (double) interestPointNode.getX(), (double) interestPointNode.getY(), dogLinkage.getK() * dogLinkage.getSigmaX() * f, Math.toRadians(entry.getKey()), interestPointNode.getComputedOutput());
				kp.setGradients(gradients);
				localKeyPoints.add(kp);
			}
		}
		
		keyPoints.addAll(localKeyPoints);
		
		return localKeyPoints;
		
	}
	
	private Double distance(IPixelNode n1, IPixelNode n2){
		
		return Math.sqrt(Math.pow(n1.getX() - n2.getX(), 2D) + Math.pow(n1.getY() - n2.getY(), 2D));
		
	}
	
	private Double getSegmentedAngleDegree(double theta, double deltaThetaDegree){
		
		Double angleDegree = Math.toDegrees(theta);
		
		angleDegree = Math.floor(angleDegree / deltaThetaDegree) * deltaThetaDegree;

		return angleDegree;
	}
	

	private Gradient computeGradient(IPixelNode kp, IPixelNode neighboor) {
		
		try{
			double magnitude = Math.sqrt(
					Math.pow(neighboor.getLeft().getComputedOutput() - neighboor.getRight().getComputedOutput() , 2D) +
					Math.pow(neighboor.getDown().getComputedOutput() - neighboor.getUp().getComputedOutput() , 2D)
					);
			
			double theta = Math.atan2(
					(neighboor.getUp().getComputedOutput() - neighboor.getDown().getComputedOutput()),
					(neighboor.getLeft().getComputedOutput() - neighboor.getRight().getComputedOutput())
					);
			
			double distanceToKeyPoint = distance(kp, neighboor);
			
			return new Gradient(neighboor, theta, magnitude, distanceToKeyPoint);
			
		}catch(Exception ignore){
			
		}
		
		return null;
		
	}


	private boolean maxLocalOnArea(IPixelNode refNode, IPixelNode localCenterNode){
		
		boolean isMax = true;
		
		isMax &= refNode.compareOutputTo(localCenterNode.getLeft()) == 1;
		if(!isMax)
			return isMax;
		isMax &= refNode.compareOutputTo(localCenterNode.getRight()) == 1;
		if(!isMax)
			return isMax;
		isMax &= refNode.compareOutputTo(localCenterNode.getUp()) == 1;
		if(!isMax)
			return isMax;
		isMax &= refNode.compareOutputTo(localCenterNode.getUpLeft()) == 1;
		if(!isMax)
			return isMax;
		isMax &= refNode.compareOutputTo(localCenterNode.getUpRight()) == 1;
		if(!isMax)
			return isMax;
		isMax &= refNode.compareOutputTo(localCenterNode.getDown()) == 1;
		if(!isMax)
			return isMax;
		isMax &= refNode.compareOutputTo(localCenterNode.getDownLeft()) == 1;
		if(!isMax)
			return isMax;
		isMax &= refNode.compareOutputTo(localCenterNode.getDownRight()) == 1;
		if(!isMax)
			return isMax;
		
//		if(refNode.getArea() != localCenterNode.getArea()){
//			isMax &= refNode.compareOutputTo(localCenterNode) == 1;
//			if(!isMax)
//				return isMax;
//		}		
			
		return isMax;
	}
	
	
	private boolean hessianCriterion(IPixelNode thisNode, IPixelNode interestPointNode) {
		
		double criterion = 0D;
		double divisor = 1D;
		double gxx = 0D;
		double gyy = 0D;
		double gxy = 0D;
//		for(INode node : interestPointNode.getArea().getNextLayer().getLayerNodes()){
//			
//			//gxx += interestPointNode.getArea().getFilterValue(node, ID_FILTER_DOG_0, interestPointNode) * interestPointNode.getComputedOutput();
//			
//			gxx += interestPointNode.getArea().getFilterValue(node, ID_FILTER_Gxx, interestPointNode) * interestPointNode.getComputedOutput();
//			gyy += interestPointNode.getArea().getFilterValue(node, ID_FILTER_Gyy, interestPointNode) * interestPointNode.getComputedOutput();
//			gxy += interestPointNode.getArea().getFilterValue(node, ID_FILTER_Gxy, interestPointNode) * interestPointNode.getComputedOutput();
//			
//		}
		
		int x = ((PixelNode) interestPointNode).getX();
		int y = ((PixelNode) interestPointNode).getY();
		
		gxx = interestPointNode.getAreaSquare().getNodeXY(x + 1, y).getComputedOutput() - 2D * interestPointNode.getAreaSquare().getNodeXY(x, y).getComputedOutput() + interestPointNode.getAreaSquare().getNodeXY(x - 1, y).getComputedOutput();
		gyy = interestPointNode.getAreaSquare().getNodeXY(x, y + 1).getComputedOutput() - 2D * interestPointNode.getAreaSquare().getNodeXY(x, y).getComputedOutput() + interestPointNode.getAreaSquare().getNodeXY(x, y - 1).getComputedOutput();
		gxy = (interestPointNode.getAreaSquare().getNodeXY(x + 1, y + 1).getComputedOutput() 
				- interestPointNode.getAreaSquare().getNodeXY(x + 1, y - 1).getComputedOutput() 
				- interestPointNode.getAreaSquare().getNodeXY(x - 1, y + 1).getComputedOutput() 
				+ interestPointNode.getAreaSquare().getNodeXY(x - 1, y - 1).getComputedOutput()) / 4D;
		
		
		divisor = Math.pow(gxx + gyy, 2D);
		
		if(divisor != 0D){
			criterion =  (gxx * gyy - Math.pow(gxy, 2D)) / divisor ;
		}
		
		double r = 10D;
		double R =  r / Math.pow(r + 1, 2D);
		//System.out.println("criterion = " + (criterion * interestPointNode.getComputedOutput()) + " >= " + R);
		return criterion  >= R;
	}
	

	
	private boolean minLocalOnSameArea(IPixelNode refNode, IPixelNode localNode){
		
		boolean isMin = true;
		
		isMin &= refNode.compareOutputTo(localNode.getLeft()) < 0;
		if(!isMin)
			return isMin;
		isMin &= refNode.compareOutputTo(localNode.getRight()) < 0;
		if(!isMin)
			return isMin;
		isMin &= refNode.compareOutputTo(localNode.getUp()) < 0;
		if(!isMin)
			return isMin;
		isMin &= refNode.compareOutputTo(localNode.getUpLeft()) < 0;
		if(!isMin)
			return isMin;
		isMin &= refNode.compareOutputTo(localNode.getUpRight()) < 0;
		if(!isMin)
			return isMin;
		isMin &= refNode.compareOutputTo(localNode.getDown()) < 0;
		if(!isMin)
			return isMin;
		isMin &= refNode.compareOutputTo(localNode.getDownLeft()) < 0;
		if(!isMin)
			return isMin;
		isMin &= refNode.compareOutputTo(localNode.getDownRight()) < 0;
		if(!isMin)
			return isMin;
		
// TODO voir pourquoi ça enleve tout les min
//		if(refNode.getArea() != localNode.getArea()){
//			isMin &= refNode.compareOutputTo(localNode) < 0;
//			if(!isMin)
//				return isMin;
//		}
			
		return isMin;
	}
	


	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		IAreaSquare subArea = sublayerNode.getAreaSquare();
		
		// Calcul du filtre gaussien
		return mu + alpha * InputSample.getInstance().compute(
				filterFunction, 
				(double) subArea.getWidthPx(),
				(double) subArea.getHeightPx(), 
				(double) sublayerNode.getX(),
				(double) sublayerNode.getY(), 
				(double) subArea.getNodeCenterXY().getX(), 
				(double) subArea.getNodeCenterXY().getY(), 
				ox, 
				oy);
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}
	
	public void addGraphicInterface(Pane pane) {
		
		for(KeyPoint point : keyPoints){
			//System.out.println(point);
			point.produceCircle();
		}
		
	}


	public Double getMu() {
		return mu;
	}


	public void setMu(Double mu) {
		this.mu = mu;
	}


	public Double getX1() {
		return x1;
	}


	public void setX1(Double x1) {
		this.x1 = x1;
	}


	public Double getY1() {
		return y1;
	}


	public void setY1(Double y1) {
		this.y1 = y1;
	}


	public Double getAlpha() {
		return alpha;
	}


	public void setAlpha(Double alpha) {
		this.alpha = alpha;
	}


	public Double getOx() {
		return ox;
	}


	public void setOx(Double ox) {
		this.ox = ox;
	}


	public Double getOy() {
		return oy;
	}


	public void setOy(Double oy) {
		this.oy = oy;
	}


	public static List<KeyPoint> getKeyPoints() {
		return keyPoints;
	}


	public static void setKeyPoints(List<KeyPoint> keyPoints) {
		OneToOneFetchOctaveAreaLinkage.keyPoints = keyPoints;
	}




}
package RN.linkage;

import RN.AreaSquare;
import RN.IArea;
import RN.ILayer;
import RN.links.ELinkType;
import RN.nodes.INode;
import RN.nodes.IPixelNode;

/**
 * @author Eric Marchand
 *
 */
public class OneToOneFilterLinkage extends Linkage {

	
	
	public OneToOneFilterLinkage() {
	}

	
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		Double sigmaWI = 0D;
		
			
		IArea subArea = getLinkedArea();
		INode sourceNode = null;
		
		if(subArea instanceof AreaSquare && thisNode.getArea() instanceof AreaSquare){
			
			sourceNode = (INode) ((AreaSquare) subArea).getNodeXY(((IPixelNode) thisNode).getX(), ((IPixelNode) thisNode).getY(), sampling);
			//sigmaWI +=  thisNode.getArea().getLayer().getLinkAndPutIfAbsent(thisNode, sourceNode, Link.getInstance(ELinkType.REGULAR, isWeightModifiable())).getWeight();
			
			// GAUSSIENNE - NEGATIF de l'image
			sigmaWI += sourceNode.getComputedOutput() - ((AreaSquare) network.getFirstLayer().getArea(0)).getNodeXY(((IPixelNode) thisNode).getX(), ((IPixelNode) thisNode).getY(), sampling).getComputedOutput();
			
			//sigmaWI = Math.max(0D, sigmaWI);
			
		}else{
			sourceNode = subArea.getNode(thisNode.getNodeId());
			sigmaWI += sourceNode.getComputedOutput() * Linkage.getLinkAndPutIfAbsent(thisNode, sourceNode, isWeightModifiable()).getWeight();
		}
			
		
		if(thisNode.getBiasWeightValue() != null)
			sigmaWI -= thisNode.getBiasWeightValue();
		
		return sigmaWI;
	}
	

	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
			
			IArea subArea = getLinkedArea();
			
			if(subArea instanceof AreaSquare && thisNode.getArea() instanceof AreaSquare){
				((AreaSquare) subArea).getNodeXY(((IPixelNode)thisNode).getX(), ((IPixelNode)thisNode).getY(), sampling).link(thisNode, ELinkType.REGULAR, false, 1D);
				((AreaSquare) network.getFirstLayer().getArea(0)).getNodeXY(((IPixelNode) thisNode).getX(), ((IPixelNode) thisNode).getY(), sampling).link(thisNode, ELinkType.REGULAR, false, -1D);
			}else{
				subArea.getNode(thisNode.getNodeId()).link(thisNode, ELinkType.REGULAR, false, 1D);
			}
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void initParameters() {
		// TODO Auto-generated method stub
		
	}




}
package RN.linkage;

import RN.AreaSquare;
import RN.IArea;
import RN.ILayer;
import RN.links.ELinkType;
import RN.nodes.INode;
import RN.nodes.IPixelNode;

/**
 * @author Eric Marchand
 *
 */
public class OneToOneLinkage extends Linkage {

	
	
	public OneToOneLinkage() {
	}

	
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		Double sigmaWI = 0D;
		
		// somme des entrees pondérées
		IArea subArea = getLinkedArea();
		if(subArea != null){
			
			INode sourceNode = null;
			if(subArea instanceof AreaSquare && thisNode.getArea() instanceof AreaSquare){
				
				sourceNode = (INode) ((AreaSquare) subArea).getNodeXY(((IPixelNode) thisNode).getX(), ((IPixelNode) thisNode).getY(), sampling);
				sigmaWI += sourceNode.getComputedOutput() * getLinkAndPutIfAbsent(thisNode, sourceNode, isWeightModifiable()).getWeight();
				
			}else{
				sourceNode = subArea.getNode(thisNode.getNodeId());
				sigmaWI += sourceNode.getComputedOutput() * getLinkAndPutIfAbsent(thisNode, sourceNode, isWeightModifiable()).getWeight();
			}
			
		}else{
			//if(getContext().getClock() == -1 || input.getFireTimeT() == getContext().getClock()){
			sigmaWI = thisNode.getInputValue() ; //* input.getWeight();
				//input.synchFutureFire();
			//}
				
		}
		
		if(thisNode.getBiasWeightValue() != null)
			sigmaWI -= thisNode.getBiasWeightValue();
		
		return sigmaWI;
	}
	

	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		IArea subArea = getLinkedArea();
		
		if(subArea != null){
			
			if(subArea instanceof AreaSquare && thisNode.getArea() instanceof AreaSquare){
				((AreaSquare) subArea).getNodeXY(((IPixelNode)thisNode).getX(), ((IPixelNode)thisNode).getY(), sampling).link(thisNode, ELinkType.REGULAR, isWeightModifiable(), 1D);
			}else{
				subArea.getNode(thisNode.getNodeId()).link(thisNode, ELinkType.REGULAR, isWeightModifiable(), 1D);
			}
			
			
		}else{
			thisNode.incomingLink(ELinkType.REGULAR);
		}
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void initParameters() {
		// TODO Auto-generated method stub
		
	}




}
package RN.linkage;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;
import java.util.Map.Entry;
import java.util.Optional;

import RN.AreaSquare;
import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.linkage.vision.EKeyPointType;
import RN.linkage.vision.Gradient;
import RN.linkage.vision.Histogram;
import RN.linkage.vision.KeyPoint;
import RN.linkage.vision.KeyPointDescriptor;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import RN.nodes.PixelNode;
import javafx.scene.layout.Pane;

public class OneToOneOctaveAreaLinkage extends FilterLinkage {

	// GAUSSIENNE ELLIPTIQUE
	private Double mu = null;

	// centre
	private Double x1 = null;
	private Double y1 = null;

	// amplitude, hauteur de la forme pixelisée
	private Double alpha = null;

	// ecartement selon x et y
	private Double ox = null;
	private Double oy = null;
	
	// seuil de suppression des pixels de bas contraste
	private double C = 0D;
	
	private static int maxSuppressed = 0;
	private static int minSuppressed = 0;
	
	private List<KeyPoint> keyPoints = new ArrayList<KeyPoint>();
	
	public OneToOneOctaveAreaLinkage() {
	}
	
	public void prePropagation(){
		keyPoints.clear();
	}

	
	public void initParameters() {
		
//		Le traitement repose sur cinq paramètres :
//		
//			N représente la taille du masque (matrice carrée) implantant le filtre LOG. N est impair.
//			σ permet d'ajuster la taille du chapeau mexicain.
//			∆x et ∆y sont les pas d'échantillonnage utilisés pour discrétiser h''(x,y). Généralement ∆x = ∆ y
//			S est le seuil qui permet de sélectionner les contours les plus marqués.
//		
//			Il est à noter que le choix des paramètres N, σ et ∆x ne doit pas se faire de façon indépendante. 
//  		En effet, le masque, même de taille réduite, doit ressembler à un chapeau mexicain. Le problème ici est le même que celui que l'on rencontre lors de l'échantillonnage d'une fonction gaussienne. 
//          Le nombre de points N à considérer doit être tel que l'étendue occupe l'intervalle [-3σ , 3σ].
//			En fonction du pas d'échantillonnage, l'étendue spatiale vaut : (N-1) ∆x  .
//			Cette étendue peut aussi s'écrire en fonction de σ : (N-1) ∆x = kσ  avec k entier.
//			En prenant par exemple  ∆x = 1 , il s'agit de choisir N et σ de sorte que l'étendue du chapeau mexicain soit pertinente. 
//  		Pour le chapeau mexicain, la valeur de k doit être au moins de 4.
		
//		double N = 9D;
//		double deltaX = 1D;
		
//		ox = (N-1) * deltaX / k;
		ox = 0.5D;
		oy = ox;
		alpha = 1D;
		mu = 0D;
		
	}
	
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		Double sigmaWI = 0D;
		List<KeyPoint> maxPointInterest = null;
		List<KeyPoint> minPointInterest = null;
		
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		INode sourceNode = null;
		Double maxValue = 0D;
					
		maxPointInterest = maxLocal(subArea, (IPixelNode) thisNode);
		if(maxPointInterest != null){
			
			for(KeyPoint maxKP : maxPointInterest){
				
				maxValue = Math.max(maxValue, maxKP.getValue());
				System.out.println(maxKP);
				keyPoints.add(maxKP);
			}
			
			sourceNode = (INode) ((AreaSquare) subArea).getNodeXY(((IPixelNode) thisNode).getX(), ((IPixelNode) thisNode).getY(), sampling);
			sigmaWI += maxValue * Linkage.getLinkAndPutIfAbsent(thisNode, sourceNode, isWeightModifiable()).getWeight();
			
		}
		
		Double minValue = 0D;
		minPointInterest = minLocal(subArea, (IPixelNode) thisNode);
		if(minPointInterest != null){

			for(KeyPoint minKP : minPointInterest){
				
				minValue = Math.min(minValue, minKP.getValue());
				System.out.println(minKP);
				keyPoints.add(minKP);
			}
			
			sourceNode = (INode) ((AreaSquare) subArea).getNodeXY(((IPixelNode) thisNode).getX(), ((IPixelNode) thisNode).getY(), sampling);
			sigmaWI += minValue * Linkage.getLinkAndPutIfAbsent(thisNode, sourceNode, isWeightModifiable()).getWeight();
			
		}
							
				
			
		if(thisNode.getBiasWeightValue() != null)
			sigmaWI -= thisNode.getBiasWeightValue();
		
		return sigmaWI;
	}
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer previousLayer) {
		
		List<KeyPoint> maxPointInterest = null;
		List<KeyPoint> minPointInterest = null;
			
//			for(IArea area : getLinkedAreas()){
//				
//					if(area.getAreaId() > 0 && area.getAreaId() < sublayer.getAreas().size() - 1){
//							
//						maxPointInterest = maxLocal(area, (IPixelNode) thisNode);
//						if(maxPointInterest != null){
//							for(KeyPoint maxKP : maxPointInterest){
//								maxKP.getKeyPointNode().link(thisNode, ELinkType.REGULAR, false, maxKP.getValue());
//							}
//						}
//						
//						minPointInterest = minLocal(area, (IPixelNode) thisNode);
//						if(minPointInterest != null){
//							for(KeyPoint minKP : minPointInterest){
//								minKP.getKeyPointNode().link(thisNode, ELinkType.REGULAR, false, minKP.getValue());
////								sigmaWI += Math.abs(minKP.getValue());
//							}
//						}
//							
//					}
//				
//			}
			
		
	}
	
	
	
	public List<KeyPoint> maxLocal(IAreaSquare area, IPixelNode thisNode){
		
		IPixelNode interestPointNode =  area.getNodeXY(thisNode.getX(), thisNode.getY());
		IAreaSquare gaussianArea = (IAreaSquare) interestPointNode.getAreaSquare().getLeftSibilingArea();
		
		boolean isMax = true;
		
//		if(interestPointNode.getComputedOutput() < C)
//			return null;
		
		if(interestPointNode.getPreviousAreaSquare() != null){
			isMax &= maxLocalOnArea(interestPointNode, interestPointNode.getPreviousAreaSquare().getNode(interestPointNode.getNodeId()));
			if(!isMax)
				return null;
		}
		
		isMax &= maxLocalOnArea(interestPointNode, interestPointNode);
		if(!isMax)
			return null;
		
		if(interestPointNode.getNextAreaSquare() != null){
			isMax &= maxLocalOnArea(interestPointNode, interestPointNode.getNextAreaSquare().getNode(interestPointNode.getNodeId()));
			if(!isMax)
				return null;
		}
		
		if(!hessianCriterion(thisNode, interestPointNode)){
			maxSuppressed++;
			return null;
		}
		
		List<KeyPoint> maxKeyPoints = computeSegmentedOrientationsAtKeyPoint(EKeyPointType.MAX, interestPointNode, gaussianArea);
		
		computeDescriptors(maxKeyPoints);
		
		return maxKeyPoints;
		
	}
	
	public List<KeyPoint> minLocal(IAreaSquare area, IPixelNode thisNode){
		
		boolean isMin = true;
		
		IPixelNode interestPointNode =  area.getNodeXY(thisNode.getX(), thisNode.getY());
		IAreaSquare gaussianArea = (IAreaSquare) interestPointNode.getAreaSquare().getLeftSibilingArea();
		
//		if(interestPointNode.getComputedOutput() < C)
//			return null;
		
		if(interestPointNode.getPreviousAreaSquare() != null){
			isMin &= minLocalOnSameArea(interestPointNode, interestPointNode.getPreviousAreaSquare().getNode(interestPointNode.getNodeId()));
			if(!isMin)
				return null;
		}
		
		
		isMin &= minLocalOnSameArea(interestPointNode, interestPointNode);
		if(!isMin)
			return null;
		
		
		if(interestPointNode.getNextAreaSquare() != null){
			isMin &= minLocalOnSameArea(interestPointNode, interestPointNode.getNextAreaSquare().getNode(interestPointNode.getNodeId()));
			if(!isMin)
				return null;
		}
		
		if(!hessianCriterion(thisNode, interestPointNode)){
			minSuppressed++;
			return null;
		}
		
		List<KeyPoint> minKeyPoints = computeSegmentedOrientationsAtKeyPoint(EKeyPointType.MIN, interestPointNode, gaussianArea);
		
		computeDescriptors(minKeyPoints);
		
		return minKeyPoints;
		
		
	}
	

	private List<KeyPointDescriptor> computeDescriptors(List<KeyPoint> keyPoints) {
		
		List<KeyPointDescriptor> descriptors = new ArrayList<KeyPointDescriptor>();
		
		KeyPointDescriptor descriptor = null;
		for(KeyPoint kp : keyPoints){
			
			// Rotation de l'axe des absisses sur le gradient du point d'interet
			// Calcul des gradients dans chacune des cellules de la zone des 16x16 pixels (+1 colonne centrale).
			Gradient[][] gradients = computeRotatedGridGradients(kp, 17);
			
			// Magnitude Threshold at 0.1 times the max for illumination stability
			gradientThreshold(gradients);
	
			// Création d'une grille 4x4 autour du point d'interet.
			// Calcul d'histogrammes de 9 orientations dans chacune des cellules.
			// Normalisation des valeurs des gradients.
			// Création des vecteurs descripteurs de 4x4x8 dimensions par point d'interet.
			descriptor = computeGridXBinsHistograms(kp, gradients, 9, 17, 4);
			kp.setDescriptor(descriptor);
			descriptors.add(descriptor);
			
			// Normalisation des descripteurs.
			normalizeDescriptor(kp);
			
		}
		
		return descriptors;
		
	}


	private void normalizeDescriptor(KeyPoint kp) {

		KeyPointDescriptor descriptor = kp.getDescriptor();

		for (Histogram histogram : descriptor.getHistograms()) {

			if (histogram.isEmpty()) {
				//histogram.put(0D, 0D);
			} else {
				for (Entry<Double, Double> entry : histogram.entrySet()) {
					entry.setValue(kp.normalizeValue(entry.getValue()));
				}
			}
		}

	}


	private KeyPointDescriptor computeGridXBinsHistograms(KeyPoint kp, Gradient[][] gradients, int binCount, int matrixOrder, int cellSizeOrder) {
		
		KeyPointDescriptor descriptor = new KeyPointDescriptor();
		
		// TODO Change it to 28 foveal gaussian overlapping zones
		// Blocks' iteration.
		// Each block point's starts at top left.
		for(int cellY = 0; cellY < matrixOrder - 1; cellY += cellSizeOrder){
			for(int cellX = 0; cellX < matrixOrder - 1; cellX += cellSizeOrder){
				
				try {
					descriptor.concatenateHistogram(computeHistogram(kp, binCount, getGradientsInSquarredOverlappingZone(cellX, cellY, cellSizeOrder, gradients)));
				} catch (Exception e) {
					e.printStackTrace();
					System.err.println("Calcul de l'histogramme 8 bins impossible pour : " + kp + " cellX : " + cellX + "  cellY : " + cellY);
				}
				
			}
		
		}
		
		return descriptor;
		
	}
	
	
	private Histogram computeHistogram(KeyPoint kp, int binsCount, List<Gradient> gradientsInOverlappingBlock) {
		
		Histogram histogram = new Histogram();
		Double value = null;
		
		for (Gradient gradient : gradientsInOverlappingBlock) {
				
				Double segmentedIdx = getSegmentedAngle(gradient.getTheta(), (2D * Math.PI) / binsCount);
				
				value = gradient.getMagnitude(); // * gradient.getDistanceToKeyPoint();// * kp.getKeyPointNode().getComputedOutput();
				
				// Normalize vote with small constant
				value = kp.normalizeValue(value);
				
				histogram.putIfAbsent(segmentedIdx, 0D);
				histogram.put(segmentedIdx, histogram.get(segmentedIdx) + value);
		}
		
		return histogram;
	}
	
	
	
	/**
	 * Return nodes in a circlar zone
	 * @param x0 x center point
	 * @param y0 y center point
	 * @param radius
	 * @return List<Gradient>
	 * @throws Exception
	 */
	public List<Gradient> getGradientsInCircularOverlappingZone(int x0, int y0, int radius, Gradient[][] gradients) {
		List<Gradient> gradientList = new ArrayList<Gradient>();
		for(int y = y0 - radius; y < y0 + radius; y++){
			for(int x = x0 - radius; x < x0 + radius; x++){
				double distance = Math.sqrt(Math.pow(x0 - x, 2D) + Math.pow(y0 - y, 2D));
				if(distance <= radius){
					try {
						if(gradients[x][y] != null)
							gradientList.add(gradients[x][y]);
					} catch (Exception ignore) {
						//e.printStackTrace();
						//System.err.println("getGradientsInCircularOverlappingZone() : Impossible de recuperer le gradient pour (x,y) = " + x + "," + y + ")" );
					}
				}
			}
		}
		return gradientList;
	}
	
	
	/**
	 * Return nodes in a squarred zone
	 * @param x0 x center point
	 * @param y0 y center point
	 * @param radius
	 * @return List<Gradient>
	 * @throws Exception
	 */
	public List<Gradient> getGradientsInSquarredOverlappingZone(int x0, int y0, int width, Gradient[][] gradients) {
		
		List<Gradient> gradientList = new ArrayList<Gradient>();
		
		// width + overlapping
		for(int y = -1; y < width + 1; y++){
			for(int x = -1; x < width + 1; x++){
					try {
						if(gradients[x0 + x][y0 + y] != null)
							gradientList.add(gradients[x0 + x][y0 + y]);
					} catch (Exception ignore) {
						//e.printStackTrace();
						//System.err.println("getGradientsInCircularOverlappingZone() : Impossible de recuperer le gradient pour (x,y) = " + x + "," + y + ")" );
					}
			}
		}
		return gradientList;
	}


	private Gradient[][] computeRotatedGridGradients(KeyPoint kp, int matrixOrder) {
		
			PixelNode neighbor = null;
			Gradient[][] gradients = new Gradient[matrixOrder][matrixOrder];
			int halfWidth = matrixOrder / 2;
			Gradient gradient = null;
			for(int y = -halfWidth; y <= halfWidth; y++){
				for(int x = -halfWidth; x <= halfWidth; x++){
					
					neighbor = (PixelNode) kp.getKeyPointNode().getAreaSquare().getNodeXY(x + kp.getX().intValue(), y + kp.getY().intValue(), kp.getX().intValue(), kp.getY().intValue(), kp.getTheta());
					
					if(neighbor == null)
						continue;
					
					gradient = kp.getGradient(neighbor.getX() - kp.getX().intValue() + halfWidth, neighbor.getY() - kp.getY().intValue() + halfWidth); 
					
					if(gradient == null)
						continue;
					
					gradient.setTheta(gradient.getTheta() - kp.getTheta());
					while(gradient.getTheta() < 0D){
						gradient.setTheta(gradient.getTheta() + (2D * Math.PI));
					}
					
					gradient.produceGradient(5D, null);
					gradients[x + halfWidth][y + halfWidth] = gradient;
					
				}
			}
			
			return gradients;
	}

	// TODO
	// 1.6D / Math.sqrt(D) with D is the descriptor dimensionality 
	private void gradientThreshold(Gradient[][] gradients, double threshold) {
		for(int idy = 0; idy < gradients.length; idy++){
			for(int idx = 0; idx < gradients[idy].length; idx++){
				gradients[idx][idy].thresholdAt(threshold);
			}
		}
	}
	
	private void gradientThreshold(Gradient[][] gradients) {
		for(int idy = 0; idy < gradients.length; idy++){
			for(int idx = 0; idx < gradients[idy].length; idx++){
				if(gradients[idx][idy] != null){
					gradients[idx][idy].thresholdAtMax(0.1D);
				}
			}
		}
	}
	
	
	
	
	private Gradient[][] computeGradients(IPixelNode interestPtNode, IAreaSquare gradientArea) {
		
		// Gradients on G * I
		Gradient gradient = null;
		GaussianLinkage dogLinkage = (GaussianLinkage) gradientArea.getLinkage();
		IPixelNode centerKpNode = gradientArea.getNodeXY(interestPtNode.getX(), interestPtNode.getY());
		
		// Sigma is 3 times that of the current smoothing scale.
		// More over, we use the calcul of the FWHM to evaluate the radius at 1/1000 from 0 on y.
		// y= σ * sqrt{2ln(1000)} + x_{center}
		// radius = 3 * σ * sqrt{2ln(1000)} + x_{center}
		Long radius = Math.round(dogLinkage.getK() * dogLinkage.getSigmaX() * 11.1501D);
		
		
		int gradientWidth = 2*radius.intValue();
		Gradient[][] gradients = new Gradient[gradientWidth][gradientWidth];

		List<IPixelNode> neighborhood = gradientArea.getNodesInCirclarZone(centerKpNode.getX(), centerKpNode.getY(), radius.intValue());
		//gradientArea.pixelsToString(neighborhood);
		
		IPixelNode pix = null;
		int idx;
		int idy;
		for (IPixelNode neighbor : neighborhood) {
				
				pix = (IPixelNode) neighbor;
				gradient = computeGradient(centerKpNode, neighbor);
				
				if(gradient != null){
					
					idx = pix.getX() - centerKpNode.getX() + radius.intValue();
					idy = pix.getY() - centerKpNode.getY() + radius.intValue();
					
					if(idx >= 0 && idx < gradientWidth && idy >= 0 && idy < gradientWidth)
						gradients[idx][idy] = gradient;
				}
				
		}
		
		// Magnitude Threshold at 0.1 times the max for illumination stability
		gradientThreshold(gradients);
		
		return gradients;
}


	private List<KeyPoint> computeSegmentedOrientationsAtKeyPoint(EKeyPointType kpType, IPixelNode interestPointNode, IAreaSquare gaussianArea) {
		
		List<KeyPoint> localKeyPoints = new ArrayList<KeyPoint>();
		Histogram histogram = new Histogram();
		double f = 1.5D;
		Double magnitude = null;
		Double segmentedIdx = null;
		
		// Calcul d'un histogramme sur une zone circulaire gaussienne
		Gradient[][] gradients = computeGradients(interestPointNode, gaussianArea);
		
		for(Gradient[] gradientRow : gradients){
			for(Gradient gradient : gradientRow){
				
				if(gradient == null)
					continue;
				
				magnitude = gradient.getMagnitude();// * gradient.getDistanceToKeyPoint() ; 
				
				segmentedIdx = getSegmentedAngle(gradient.getTheta(), (2D * Math.PI) / 36D);
				
				histogram.putIfAbsent(segmentedIdx, 0D);
				histogram.put(segmentedIdx, histogram.get(segmentedIdx) + magnitude); 
			}
		}
		
		Comparator<Double> comp = (p1, p2) -> Double.compare( p1.doubleValue(), p2.doubleValue());
		Optional<Double> magnitudeMax = histogram.values().stream().max(comp);
		
		if(magnitudeMax.isPresent()){
			
			// Suppression des orientations < 80% du max et création des points d'interets ainsi que les supplémentaires.
			GaussianLinkage dogLinkage = (GaussianLinkage) gaussianArea.getLinkage();
			
			Iterator<Entry<Double, Double>> it = histogram.entrySet().iterator();
			KeyPoint kp = null;
			Double normalizedMagnitude = null;
			while (it.hasNext())
			{
			   Entry<Double, Double> entry = it.next();
			   normalizedMagnitude = entry.getValue() / magnitudeMax.get();
				if(normalizedMagnitude < 0.8D){
					it.remove();
				}else{
					kp = new KeyPoint(kpType, interestPointNode, (double) interestPointNode.getX(), (double) interestPointNode.getY(), dogLinkage.getK() * dogLinkage.getSigmaX() * f, entry.getKey(), interestPointNode.getComputedOutput());
					kp.setGradients(gradients);
					localKeyPoints.add(kp);
				}
			}
		
		}
		
		return localKeyPoints;
		
	}
	
	private Double distance(IPixelNode n1, IPixelNode n2){
		
		return Math.sqrt(Math.pow(n1.getX() - n2.getX(), 2D) + Math.pow(n1.getY() - n2.getY(), 2D));
		
	}
	
	private Double getSegmentedAngle(double theta, double deltaTheta){
		
		return Math.floor(theta / deltaTheta) * deltaTheta;
	}
	

	private Gradient computeGradient(IPixelNode kp, IPixelNode neighboor) {
		
		Gradient gradient = null;
		
		try{
			double magnitude = Math.sqrt(
					Math.pow(neighboor.getLeft().getComputedOutput() - neighboor.getRight().getComputedOutput() , 2D) +
					Math.pow(neighboor.getDown().getComputedOutput() - neighboor.getUp().getComputedOutput() , 2D)
					);
			
			double theta = Math.atan2(
					(neighboor.getUp().getComputedOutput() - neighboor.getDown().getComputedOutput()),
					(neighboor.getLeft().getComputedOutput() - neighboor.getRight().getComputedOutput())
					);
			
			while(theta < 0D){
				theta += (2D * Math.PI);
			}
			
			double distanceToKeyPoint = distance(kp, neighboor);
			
			gradient = new Gradient(neighboor, theta, magnitude, distanceToKeyPoint);
			
			//gradient.produceGradient();
			
			return gradient;
			
		}catch(Throwable ignore){
			//ignore.printStackTrace();
		}
		
		return null;
		
	}


	private boolean maxLocalOnArea(IPixelNode refNode, IPixelNode localNode) {

		boolean isMax = true;

		if (localNode.getLeft() != null) {
			isMax &= refNode.compareOutputTo(localNode.getLeft()) > C;
			if (!isMax)
				return isMax;
		}

		if (localNode.getRight() != null) {
			isMax &= refNode.compareOutputTo(localNode.getRight()) > C;
			if (!isMax)
				return isMax;
		}

		if (localNode.getUp() != null) {
			isMax &= refNode.compareOutputTo(localNode.getUp()) > C;
			if (!isMax)
				return isMax;
		}

		if (localNode.getUpLeft() != null) {
			isMax &= refNode.compareOutputTo(localNode.getUpLeft()) > C;
			if (!isMax)
				return isMax;
		}

		if (localNode.getUpRight() != null) {
			isMax &= refNode.compareOutputTo(localNode.getUpRight()) > C;
			if (!isMax)
				return isMax;
		}
		if (localNode.getDown() != null) {
			isMax &= refNode.compareOutputTo(localNode.getDown()) > C;
			if (!isMax)
				return isMax;
		}

		if (localNode.getDownLeft() != null) {
			isMax &= refNode.compareOutputTo(localNode.getDownLeft()) > C;
			if (!isMax)
				return isMax;
		}

		if (localNode.getDownRight() != null) {
			isMax &= refNode.compareOutputTo(localNode.getDownRight()) > C;
			if (!isMax)
				return isMax;
		}

		if (refNode.getAreaSquare() != localNode.getAreaSquare()) {
			isMax &= refNode.compareOutputTo(localNode) > C;
			if (!isMax)
				return isMax;
		}

		return isMax;
	}
	
	private boolean minLocalOnSameArea(IPixelNode refNode, IPixelNode localNode) {

		boolean isMin = true;

		if (localNode.getLeft() != null) {
			isMin &= refNode.compareOutputTo(localNode.getLeft()) < C;
			if (!isMin)
				return isMin;
		}

		if (localNode.getRight() != null) {
			isMin &= refNode.compareOutputTo(localNode.getRight()) < C;
			if (!isMin)
				return isMin;
		}

		if (localNode.getUp() != null) {
			isMin &= refNode.compareOutputTo(localNode.getUp()) < C;
			if (!isMin)
				return isMin;
		}

		if (localNode.getUpLeft() != null) {
			isMin &= refNode.compareOutputTo(localNode.getUpLeft()) < C;
			if (!isMin)
				return isMin;
		}

		if (localNode.getUpRight() != null) {
			isMin &= refNode.compareOutputTo(localNode.getUpRight()) < C;
			if (!isMin)
				return isMin;
		}

		if (localNode.getDown() != null) {
			isMin &= refNode.compareOutputTo(localNode.getDown()) < C;
			if (!isMin)
				return isMin;
		}

		if (localNode.getDownLeft() != null) {
			isMin &= refNode.compareOutputTo(localNode.getDownLeft()) < C;
			if (!isMin)
				return isMin;
		}

		if (localNode.getDownRight() != null) {
			isMin &= refNode.compareOutputTo(localNode.getDownRight()) < C;
			if (!isMin)
				return isMin;
		}

		if (refNode.getAreaSquare() != localNode.getAreaSquare()) {
			isMin &= refNode.compareOutputTo(localNode) < C;
			if (!isMin)
				return isMin;
		}

		return isMin;
	}
	
	
	private boolean hessianCriterion(IPixelNode thisNode, IPixelNode interestPointNode) {
		
		double criterion = 0D;
		double divisor = 1D;
		double gxx = 0D;
		double gyy = 0D;
		double gxy = 0D;
		IAreaSquare area = interestPointNode.getAreaSquare();
		
		int x = ((PixelNode) interestPointNode).getX();
		int y = ((PixelNode) interestPointNode).getY();

		if(x > 0 && y > 0 && x < area.getWidthPx() - 1 && y < area.getHeightPx() - 1){
			
			gxx = area.getNodeXY(x + 1, y).getComputedOutput() - 2D * area.getNodeXY(x, y).getComputedOutput() + area.getNodeXY(x - 1, y).getComputedOutput();
			gyy = area.getNodeXY(x, y + 1).getComputedOutput() - 2D * area.getNodeXY(x, y).getComputedOutput() + area.getNodeXY(x, y - 1).getComputedOutput();
			gxy = (area.getNodeXY(x + 1, y + 1).getComputedOutput() 
					- area.getNodeXY(x + 1, y - 1).getComputedOutput() 
					- area.getNodeXY(x - 1, y + 1).getComputedOutput() 
					+ area.getNodeXY(x - 1, y - 1).getComputedOutput()) / 4D;
			
			
			divisor = Math.pow(gxx + gyy, 2D);
			
			if(divisor != 0D){
				criterion =  (gxx * gyy - Math.pow(gxy, 2D)) / divisor ;
			}
			
			double r = 10D;
			double R =  r / Math.pow(r + 1, 2D);
			//System.out.println("criterion = " + (criterion * interestPointNode.getComputedOutput()) + " >= " + R);
			return criterion  >= R;
		}
		
		return true;
	}
	

	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		IAreaSquare subArea = sublayerNode.getAreaSquare();
		
		// Calcul du filtre gaussien
		return mu + alpha * InputSample.getInstance().compute(
				filterFunction, 
				(double) subArea.getWidthPx(),
				(double) subArea.getHeightPx(), 
				(double) sublayerNode.getX(),
				(double) sublayerNode.getY(), 
				(double) subArea.getNodeCenterXY().getX(), 
				(double) subArea.getNodeCenterXY().getY(), 
				ox, 
				oy);
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}
	
	public void addGraphicInterface(Pane pane) {
		
		for(KeyPoint point : keyPoints){
			//System.out.println(point);
			point.produceCircle();
		}
		
	}


	public Double getMu() {
		return mu;
	}


	public void setMu(Double mu) {
		this.mu = mu;
	}


	public Double getX1() {
		return x1;
	}


	public void setX1(Double x1) {
		this.x1 = x1;
	}


	public Double getY1() {
		return y1;
	}


	public void setY1(Double y1) {
		this.y1 = y1;
	}


	public Double getAlpha() {
		return alpha;
	}


	public void setAlpha(Double alpha) {
		this.alpha = alpha;
	}


	public Double getOx() {
		return ox;
	}


	public void setOx(Double ox) {
		this.ox = ox;
	}


	public Double getOy() {
		return oy;
	}


	public void setOy(Double oy) {
		this.oy = oy;
	}


	public List<KeyPoint> getKeyPoints() {
		return keyPoints;
	}


	public void setKeyPoints(List<KeyPoint> keyPoints) {
		this.keyPoints = keyPoints;
	}




}
package RN.linkage;

import RN.ILayer;
import RN.nodes.INode;

public class RecurrentLinkage extends Linkage {

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		// TODO Auto-generated method stub

	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub

	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub

	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub

	}

	@Override
	public void initParameters() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode) {
		// TODO Auto-generated method stub
		return 0;
	}


}
package RN.linkage;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.links.ELinkType;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import javafx.scene.layout.Pane;

public class RotateAndCollapseLinkage extends FilterLinkage {
	

	
	protected Double theta = null;
	


	public RotateAndCollapseLinkage() {
	}
	

	
	public void initParameters() {
		
//		if(params.length != 2 && params.length != 3)
//			throw new RuntimeException("Missing RotateAndCollapse parameters'");
//		
//		
//		setTheta(params[0]);		

	}

	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		// somme des entrees pondérées
		SigmaWi sigmaWI = new SigmaWi();
		
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		IPixelNode pix = (IPixelNode) thisNode;
		
		
		double distance = Math.sqrt(Math.pow(pix.getX(), 2) + Math.pow(pix.getY(), 2));
		
		boolean isShortestPath = false;
		Double minDistance = null;
		double dist = 0D;
		IPixelNode nearestMinMaxNode = null;
		for(IPixelNode maxMinPix : MaxLinkage.getMaxMinNodes()){
			dist = pix.distance(maxMinPix);
			if(minDistance == null || dist < minDistance){
				minDistance = dist;
				nearestMinMaxNode = maxMinPix;
			}
		}
		
		
		
		IPixelNode subPix = subArea.getNodeXY(pix.getX(), pix.getY());
		if(subPix != null){
			sigmaWI.sum(subPix.getComputedOutput());
		}
		
		
		return sigmaWI.value();
	}
	

	




	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		
		// somme des entrees pondérées
		SigmaWi sigmaWI = new SigmaWi();
		
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		IPixelNode pix = (IPixelNode) thisNode;
		
		
		double distance = Math.sqrt(Math.pow(pix.getX(), 2) + Math.pow(pix.getY(), 2));
		
		boolean isShortestPath = false;
		Double minDistance = null;
		double dist = 0D;
		IPixelNode nearestMinMaxNode = null;
		for(IPixelNode maxMinPix : MaxLinkage.getMaxMinNodes()){
			dist = pix.distance(maxMinPix);
			if(minDistance == null || dist < minDistance){
				minDistance = dist;
				nearestMinMaxNode = maxMinPix;
			}
		}
		
		IPixelNode subPix = subArea.getNodeXY(pix.getX(), pix.getY());
		if(subPix != null){
			subPix.link(thisNode, ELinkType.REGULAR, isWeightModifiable());
		}
		
	}
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		// Calcul du filtre Log-Gabor
		return  InputSample.getInstance().compute(
				filterFunction, 
				(double) subArea.getWidthPx(),
	
				(double) (sublayerNode.getX() - subArea.getWidthPx() / 2D) * 4D,
				(double) (sublayerNode.getY() - subArea.getHeightPx() / 2D) * 4D
				);
		
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}
	
	public void addGraphicInterface(Pane pane) {
		
	}



	public Double getTheta() {
		return theta;
	}



	public void setTheta(Double theta) {
		this.theta = theta;
	}






}
package RN.linkage;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.nodes.INode;
import RN.nodes.IPixelNode;

/**
 * @author Eric Marchand
 *
 */
public class SamplingLinkage extends FilterLinkage {

	
	public SamplingLinkage() {
	}
	
	public SamplingLinkage(Integer sampling) {
		this.sampling = sampling;
	}
	
	public void initParameters() {
	}
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		SigmaWi sigmaWI = new SigmaWi();
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
			
		if(sampling != null && sampling != 1){
			initFilter(this, ID_FILTER_SAMPLING_2, ESamples.SAMPLING, (IPixelNode) thisNode, subArea);
			subArea.applyFilter(this, ID_FILTER_SAMPLING_2, (IPixelNode) thisNode, sigmaWI);
		}
			
		
		
		return sigmaWI.value();
	}
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		if(sampling != null && sampling != 1){
			initFilter(this, ID_FILTER_SAMPLING_2, ESamples.SAMPLING, (IPixelNode) thisNode, subArea);
			subArea.applyFilter(this, ID_FILTER_SAMPLING_2, (IPixelNode) thisNode, 0f);
		}
		
		
	}
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		// Calcul du filtre gaussien
		return  InputSample.getInstance().compute(
				filterFunction, 
				(double) sublayerNode.getX(),
				(double) sublayerNode.getY(), 
				(double) sampling
				);
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}


}
package RN.linkage;

/**
 * @author Eric Marchand
 *
 */
public class SigmaWi {
	
	Double sigmaWi = null;

	public SigmaWi() {
		this.sigmaWi = 0D;
	}

	public Double value() {
		return sigmaWi;
	}
	
	public Double sum(Double value) {
		
		this.sigmaWi += value;
		
		return sigmaWi;
	}
	
	public Double multiply(Double value){
		
		this.sigmaWi *= value;
		
		return sigmaWi;
	}

	public void setSigmaWi(Double sigmaWi) {
		this.sigmaWi = sigmaWi;
	}

}
package RN.linkage;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

import RN.IArea;
import RN.IAreaSquare;
import RN.ILayer;
import RN.Identification;
import RN.dataset.inputsamples.ESamples;
import RN.links.Link;
import RN.links.Weight;
import RN.nodes.INode;
import RN.nodes.IPixelNode;

/**
 * @author ericmarchand
 * 
 */
public class SubsamplingLinkage extends FilterLinkage {

	
	private Integer stride = null;
	private Integer filterWidth = null;
	private Integer toCenter = null;
	private static Map<Identification,Weight> trainableCoefs = null;
	private static Map<Identification,Weight> sharedBiasWeight = null;

	public SubsamplingLinkage() {
	}
	
	public SubsamplingLinkage(Integer sampling) {
		this.sampling = sampling;
	}
	
	/* (non-Javadoc)
	 * @see RN.linkage.ILinkage#initParameters()
	 */
	public void initParameters() {
		
		if(params[0] != null)
			filterWidth = params[0].intValue();
		
		if(params[1] != null)
			stride = params[1].intValue();
		
		toCenter = ((filterWidth - 1) / 2);
		
		trainableCoefs = null;
		sharedBiasWeight = null;
	}
	
	private void initTrainableCoefs(){
		
		if (trainableCoefs == null || trainableCoefs.get(getArea().getIdentification()) == null) {
			trainableCoefs = new HashMap<Identification, Weight>();
			sharedBiasWeight = new HashMap<Identification, Weight>();
			
			Weight biasWeight = null;
			for (IArea area : getArea().getLayer().getAreas()) {
				biasWeight = new Weight();
				trainableCoefs.put(area.getIdentification(), new Weight());
				sharedBiasWeight.put(area.getIdentification(), biasWeight);
				for(INode node : area.getNodes()){
					node.setBiasWeight(biasWeight);
				}
			}
		}
	}
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		// somme des entrees pondérées
		SigmaWi sigmaWI = new SigmaWi();
		IPixelNode pix = (IPixelNode) thisNode;
		
		IAreaSquare subArea = null;
		IPixelNode centerPix = null;

		List<IPixelNode> nodesInSquare = null;
		
		initTrainableCoefs();
		
		for(IArea area : getLinkedAreas()){
			
			 subArea = (IAreaSquare) area;
			 centerPix = subArea.getNodeXY(pix.getX() * stride , pix.getY() * stride);
			 
			nodesInSquare = subArea.getNodesInSquareZone(centerPix.getX() - toCenter, centerPix.getY() - toCenter, filterWidth, filterWidth);
			for(IPixelNode innerPix : nodesInSquare){
				sigmaWI.sum(innerPix.getComputedOutput());
			}
			
			sigmaWI.multiply(getLinkAndPutIfAbsent(thisNode, (INode) centerPix, isWeightModifiable(), trainableCoefs.get(getArea())).getWeight());
			sigmaWI.sum(-thisNode.getBiasWeightValue());
			
		}
			
		return sigmaWI.value();
	}
	

	
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		IPixelNode pix = (IPixelNode) thisNode;
		
		IAreaSquare subArea = null;
		IPixelNode centerPix = null;

		List<IPixelNode> nodesInSquare = null;
		
		initTrainableCoefs();
		
		for(IArea area : getLinkedAreas()){
			
			 subArea = (IAreaSquare) area;
			 centerPix = subArea.getNodeXY(pix.getX() * stride , pix.getY() * stride);
			 
			nodesInSquare = subArea.getNodesInSquareZone(centerPix.getX() - toCenter, centerPix.getY() - toCenter, filterWidth, filterWidth);
			for(IPixelNode innerPix : nodesInSquare){
				innerPix.link(thisNode, isWeightModifiable(), trainableCoefs.get(getArea()));
			}
			
		}
			
	}
	
	public double getLinkedSigmaPotentials(INode thisNode){
		
		Double sigmaWI = 0D;
		
		// somme des entrees pondérées
		for (Link input : thisNode.getInputs()) {
			
			if(getContext().getClock() == -1 || input.getFireTimeT() == getContext().getClock()){
				
				sigmaWI += input.getValue();
				
				input.synchFutureFire();
			}
			
		}
		
		
		// ajout du biais
		if (thisNode.getBiasInput() != null){
			if(getContext().getClock() == -1 || thisNode.getBiasInput().getFireTimeT() == getContext().getClock()){
				
				sigmaWI -= thisNode.getBiasInput().getValue() * thisNode.getBiasInput().getWeight();
				
				thisNode.getBiasInput().synchFutureFire();
			}
		}
		
		return sigmaWI;
	}
	
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		return 0D;
	}




	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	
}
package RN.linkage;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.links.ELinkType;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.scene.control.Slider;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public class SumOfNegativeAndGaussianLinkage extends FilterLinkage {
	
	// GAUSSIENNE ELLIPTIQUE
	private Double mu = null;

	// centre
	private Double x1 = null;
	private Double y1 = null;

	// amplitude, hauteur de la forme pixelisée
	private Double alpha = null;

	// ecartement selon x et y
	private Double ox = null;
	private Double oy = null;
	
	// k un paramètre liant les variances des deux fonctions gaussiennes.
	private Double k0 = null;

	// Interface graphique pour ImageNode
	private  Slider kSlider = null;
	


	public SumOfNegativeAndGaussianLinkage() {
	}
	
	public void initParameters() {
		
//		Le traitement repose sur cinq paramètres :
//		
//			N représente la taille du masque (matrice carrée) implantant le filtre LOG. N est impair.
//			σ permet d'ajuster la taille du chapeau mexicain.
//			∆x et ∆y sont les pas d'échantillonnage utilisés pour discrétiser h''(x,y). Généralement ∆x = ∆ y
//			S est le seuil qui permet de sélectionner les contours les plus marqués.
//		
//			Il est à noter que le choix des paramètres N, σ et ∆x ne doit pas se faire de façon indépendante. 
//  		En effet, le masque, même de taille réduite, doit ressembler à un chapeau mexicain. Le problème ici est le même que celui que l'on rencontre lors de l'échantillonnage d'une fonction gaussienne. 
//          Le nombre de points N à considérer doit être tel que l'étendue occupe l'intervalle [-3σ , 3σ].
//			En fonction du pas d'échantillonnage, l'étendue spatiale vaut : (N-1) ∆x  .
//			Cette étendue peut aussi s'écrire en fonction de σ : (N-1) ∆x = kσ  avec k entier.
//			En prenant par exemple  ∆x = 1 , il s'agit de choisir N et σ de sorte que l'étendue du chapeau mexicain soit pertinente. 
//  		Pour le chapeau mexicain, la valeur de k doit être au moins de 4.
		
		double N = 3;
		double deltaX = 1;
		double k = 4D;
		
		k0 = params[0];
		mu = 0D;
		
		initParametersGaussian1(k0);
		
	}

	private void initParametersGaussian1(Double k1) {
		
		ox = 0.5D;
		oy = ox;
		alpha = 1D;
		
	}
	
	
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		SigmaWi sigmaWI = new SigmaWi();
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
			
		initFilter(this, ID_FILTER_SONAG, ESamples.GAUSSIAN_DE_MARR, (IPixelNode) thisNode, subArea, getMu(), getAlpha1(), getOx1(), getOy1(), getK0());
			
		subArea.applyConvolutionFilter(this, ID_FILTER_SONAG,(IPixelNode) thisNode, sigmaWI);
		
		sigmaWI.sum(-subArea.getNode(thisNode.getNodeId()).getComputedOutput()) ;
		
		sigmaWI.sum(-thisNode.getBiasWeightValue());
			
		
		return sigmaWI.value();
	}
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();

		initFilter(this, ID_FILTER_SONAG, ESamples.GAUSSIAN_DE_MARR, (IPixelNode) thisNode, subArea, getMu(), getAlpha1(), getOx1(), getOy1(), getK0());
		
		subArea.applyConvolutionFilter(this, ID_FILTER_SONAG, (IPixelNode) thisNode, 0.001f);
		
		subArea.getNode(thisNode.getNodeId()).link(thisNode, ELinkType.REGULAR, isWeightModifiable(), -1);
		
	}
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		IAreaSquare subArea = sublayerNode.getAreaSquare();
		
		// Calcul du filtre gaussien
		return params[0] + params[1] * InputSample.getInstance().compute(
				filterFunction, 
				(double) subArea.getWidthPx(),
				(double) subArea.getHeightPx(), 
				(double) sublayerNode.getX(),
				(double) sublayerNode.getY(), 
				(double) subArea.getNodeCenterXY().getX(), 
				(double) subArea.getNodeCenterXY().getY(), 
				params[2], 
				params[3],
				params.length == 5 ? params[4] : null);
	}
	
	

	
	public void addGraphicInterface(Pane pane) {
		
		kSlider = new Slider(-2D, 2D, getK0());
		TextField label0 = new TextField("k=" + getK0());
		//TextField label1 = new TextField("k1=" + getK1());
		TextField sigma1 = new TextField("sigma1=" + getOx1());
		
		HBox hbox = new HBox();
		hbox.getChildren().addAll(kSlider);
		
		HBox hbox1 = new HBox(label0);
		HBox hbox2 = new HBox(sigma1);

		pane.getChildren().addAll(hbox, hbox1, hbox2);

		kSlider.setBlockIncrement(0.1);
		kSlider.valueProperty().addListener(new ChangeListener<Number>() {
			public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
//				if(new_val != old_val){
//					try {
//						setK0(new_val.doubleValue());
//						initParametersGaussian1(getK0());
//						sigma1.setText("sigma1=" + getOx1());
//						label0.setText(new_val.toString());
//						FilterLinkage.removeFilter(new FilterIndex(ID_FILTER_DOG_0));
//						getArea().setFilter(ID_FILTER_DOG_1, null);
//						for (INode node : getArea().getNodes()) {
//							node.computeOutput(false);
//						}
//						getArea().showImageArea();
//						System.out.println("k: " +getK0());
//					} catch (Exception e) {
//						e.printStackTrace();
//					}
//				}
			}
		});
	}


	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	public Double getK0() {
		return k0;
	}

	public void setK0(Double k) {
		this.k0 = k;
	}
	

	public Double getMu() {
		return mu;
	}

	public void setMu(Double mu) {
		this.mu = mu;
	}

	public Double getAlpha1() {
		return alpha;
	}

	public void setAlpha1(Double alpha1) {
		this.alpha = alpha1;
	}

	public Double getOx1() {
		return ox;
	}

	public void setOx1(Double ox1) {
		this.ox = ox1;
	}

	public Double getOy1() {
		return oy;
	}

	public void setOy1(Double oy1) {
		this.oy = oy1;
	}

	public Slider getkSlider() {
		return kSlider;
	}

	public void setkSlider(Slider kSlider) {
		this.kSlider = kSlider;
	}


}
package RN.linkage;

import RN.ILayer;
import RN.nodes.INode;

/**
 * @author Eric Marchand
 *
 */
public class TimeSerieLinkage extends Linkage {

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		// TODO Auto-generated method stub

	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub

	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub

	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub

	}

	@Override
	public void initParameters() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode) {
		// TODO Auto-generated method stub
		return 0;
	}


}
package RN.linkage.vision;

import RN.IAreaSquare;
import RN.ILayer;
import RN.linkage.Linkage;
import RN.links.ELinkType;
import RN.nodes.ENodeType;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import RN.nodes.PixelNode;

/**
 * @author Eric Marchand
 *
 */
public class BiPolarCellLinkage extends Linkage{

	
	public BiPolarCellLinkage() {
		super();
	}
	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode) {

		Double sigmaWI = 0D;
		
		Double sign = -1D;

		// somme des entrees pondérées
		ILayer sublayer = thisNode.getArea().getPreviousLayer();
		if (sublayer != null) {
			
			PixelNode bipolarNode = (PixelNode) thisNode;
			
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_S)
				sign = 1D;

				sigmaWI += getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX(), bipolarNode.getY()).getComputedOutput() * 8D * -sign;
			
			
			if (bipolarNode.getX() >= 0){
				
					sigmaWI += getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() - 1, bipolarNode.getY()).getComputedOutput() * sign;
			}

			if (bipolarNode.getX() <= bipolarNode.getAreaSquare().getWidthPx() - 1){
					sigmaWI += getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() + 1, bipolarNode.getY()).getComputedOutput() * sign;
			}
			
			if (bipolarNode.getY() >= 0){
					sigmaWI += getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX(), bipolarNode.getY() - 1).getComputedOutput() * sign;
			}
			
			if (bipolarNode.getY() <= bipolarNode.getAreaSquare().getHeightPx() - 1){
					sigmaWI += getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX(), bipolarNode.getY() + 1).getComputedOutput() * sign;
			}
			
			// diagonales

			// en haut à gauche
			if (bipolarNode.getX() >= 0 && bipolarNode.getY() >= 0){
					sigmaWI += getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() - 1, bipolarNode.getY() - 1 ).getComputedOutput() * sign;
			}
			
			// en haut à droite
			if (bipolarNode.getX() <= bipolarNode.getAreaSquare().getWidthPx() - 1 && bipolarNode.getY() >= 0){
					sigmaWI += getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() + 1, bipolarNode.getY() - 1 ).getComputedOutput() * sign;
			}
			
			// en bas à gauche
			if (bipolarNode.getY() <= bipolarNode.getAreaSquare().getHeightPx() - 1 && bipolarNode.getX() >= 0){
					sigmaWI += getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() - 1, bipolarNode.getY() + 1 ).getComputedOutput() * sign;
			}
			
			// en bas à droite
			if (bipolarNode.getY() <= bipolarNode.getAreaSquare().getHeightPx() - 1 && bipolarNode.getX() <= bipolarNode.getAreaSquare().getWidthPx() - 1){
					sigmaWI += getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() + 1, bipolarNode.getY() + 1 ).getComputedOutput() * sign;
			}
			
			sigmaWI -= thisNode.getBiasWeightValue();
			
		}

		return sigmaWI;
	}
	
	/* (non-Javadoc)
	 * @see RN.linkage.FullFanOutLinkage#sublayerFanOutLinkage(RN.Layer)
	 */
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {

		/**
		 * Filtre délimiteur de contours Implémentation de l'opérateur Laplacien
		 * avec diagonales
		 * 
		 * Voie ON
		 * -1  -1  -1 
		 * -1   8  -1 
		 * -1  -1  -1
		 * 
		 * Voie OFF
		 *  1   1   1 
		 *  1  -8   1 
		 *  1   1   1
		 */
		
		PixelNode bipolarNode = (PixelNode) thisNode;

		if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_L)
			getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX(), bipolarNode.getY()).link(bipolarNode, ELinkType.ON, isWeightModifiable(), 8D);
		
		if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_S)
			getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX(), bipolarNode.getY()).link(bipolarNode, ELinkType.OFF, isWeightModifiable(), -8D);

		if (bipolarNode.getX() >= 0){
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_L)
				getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() - 1, bipolarNode.getY()).link(bipolarNode, ELinkType.ON, isWeightModifiable(), -1D);
			
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_S)
				getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() - 1, bipolarNode.getY()).link(bipolarNode, ELinkType.OFF, isWeightModifiable(), 1D);
		}

		if (bipolarNode.getX() <= bipolarNode.getAreaSquare().getWidthPx() - 1){
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_L)
				getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() + 1, bipolarNode.getY()).link(bipolarNode, ELinkType.ON, isWeightModifiable(), -1D);
			
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_S)
				getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() + 1, bipolarNode.getY()).link(bipolarNode, ELinkType.OFF, isWeightModifiable(), 1D);
		}

		if (bipolarNode.getY() >= 0){
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_L)
				getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX(), bipolarNode.getY() - 1).link(bipolarNode, ELinkType.ON, isWeightModifiable(), -1D);
			
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_S)
				getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX(), bipolarNode.getY() - 1).link(bipolarNode, ELinkType.OFF, isWeightModifiable(), 1D);
		}

		if (bipolarNode.getY() <= bipolarNode.getAreaSquare().getHeightPx() - 1){
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_L)
				getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX(), bipolarNode.getY() + 1).link(bipolarNode, ELinkType.ON, isWeightModifiable(), -1D);
			
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_S)
				getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX(), bipolarNode.getY() + 1).link(bipolarNode, ELinkType.OFF, isWeightModifiable(), 1D);
		}

		// diagonales

		// en haut à gauche
		if (bipolarNode.getX() >= 0 && bipolarNode.getY() >= 0){
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_L)
				getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() - 1, bipolarNode.getY() - 1).link(bipolarNode, ELinkType.ON, isWeightModifiable(), -1D);
			
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_S)
				getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() - 1, bipolarNode.getY() - 1).link(bipolarNode, ELinkType.OFF, isWeightModifiable(), 1D);
		}

		// en haut à droite
		if (bipolarNode.getX() <= bipolarNode.getAreaSquare().getWidthPx() - 1 && bipolarNode.getY() >= 0){
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_L)
				getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() + 1, bipolarNode.getY() - 1).link(bipolarNode, ELinkType.ON, isWeightModifiable(), -1D);
			
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_S)
				getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() + 1, bipolarNode.getY() - 1).link(bipolarNode, ELinkType.OFF, isWeightModifiable(), 1D);
		}

		// en bas à gauche
		if (bipolarNode.getY() <= bipolarNode.getAreaSquare().getHeightPx() - 1 && bipolarNode.getX() >= 0){
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_L)
				getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() - 1, bipolarNode.getY() + 1).link(bipolarNode, ELinkType.ON, isWeightModifiable(), -1D);
			
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_S)
				getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() - 1, bipolarNode.getY() + 1).link(bipolarNode, ELinkType.OFF, isWeightModifiable(), 1D);
		}

		// en bas à droite
		if (bipolarNode.getY() <= bipolarNode.getAreaSquare().getHeightPx() - 1 && bipolarNode.getX() <= bipolarNode.getAreaSquare().getWidthPx() - 1){
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_L)
				getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() + 1, bipolarNode.getY() + 1).link(bipolarNode, ELinkType.ON, isWeightModifiable(), -1D);
			
			if(bipolarNode.getNodeType() == ENodeType.BIPOLAR_S)
				getCheckedPixelNodeXY(bipolarNode, sublayer, bipolarNode.getX() + 1, bipolarNode.getY() + 1).link(bipolarNode, ELinkType.OFF, isWeightModifiable(), 1D);
		}

	}

	private IPixelNode getCheckedPixelNodeXY(INode thisNode, ILayer sublayer, int x, int y) {

		IPixelNode node = null;
		IPixelNode pxNode = (IPixelNode) thisNode;
		
		IAreaSquare subArea = (IAreaSquare) sublayer.getAreas().get(0);

		try {
			node = subArea.getNodeXY(x, y);
		} catch (Exception e) {

			// on se trouve à proximité d'un bord, on recopie le pixel du bord
			try {
				
				if(x < 0)
					x += 1;
				if(y < 0)
					y += 1;
				if(x > pxNode.getAreaSquare().getWidthPx() - 1)
					x -= 1;
				if(y > pxNode.getAreaSquare().getHeightPx() - 1)
					y -= 1;
					
				node = subArea.getNodeXY(x, y);
				
			} catch (Exception e1) {
				e1.printStackTrace();
			}

		}

		return node;

	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void initParameters() {
		// TODO Auto-generated method stub
		
	}
	
}
package RN.linkage.vision;

/**
 * @author Eric Marchand
 *
 */
public enum EKeyPointType {
	
	MAX, MIN;

}
package RN.linkage.vision;

import RN.IAreaSquare;
import RN.ILayer;
import RN.linkage.OneToOneLinkage;
import RN.links.ELinkType;
import RN.nodes.ENodeType;
import RN.nodes.INode;

/**
 * @author Eric Marchand
 *
 */
public class GanglionaryCellLinkage extends OneToOneLinkage{

	
	public GanglionaryCellLinkage() {
		super();
	}
	
	/* (non-Javadoc)
	 * @see RN.linkage.GanglionaryLinkage#sublayerFanOutLinkage(RN.Layer)
	 */
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {

		/**
		 * 
		 * 
		 * 
		 *  
		 *  
		 * 
		 */
		
		IAreaSquare subArea = (IAreaSquare) sublayer.getAreas().get(thisNode.getArea().getAreaId());
		INode sourceNode = subArea.getNode(thisNode.getNodeId());
		
			if(thisNode.getNodeType() == ENodeType.GANGLIONARY_OFF && sourceNode.getNodeType() == ENodeType.BIPOLAR_S){
				
				sourceNode.link(thisNode, ELinkType.OFF, false, 1D);
				
			}else if(thisNode.getNodeType() == ENodeType.GANGLIONARY_ON && sourceNode.getNodeType() == ENodeType.BIPOLAR_L){
				
				sourceNode.link(thisNode, ELinkType.ON, false, 1D);
				
			}


	}


	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}
	
}
package RN.linkage.vision;

import RN.nodes.IPixelNode;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.paint.Color;

/**
 * @author Eric Marchand
 *
 */
public class Gradient {
	
	private IPixelNode pixNode = null; 
	
	private Double theta = null;
	
	private Double magnitude = null;
	
	private Double distanceToKeyPoint = null;
	
	private static Double maxMagnitude = 0D;

	public Gradient(IPixelNode pixNode, Double theta, Double value, Double distanceToKeyPoint) {
		this.pixNode = pixNode;
		this.theta = theta;
		this.magnitude = value;
		this.distanceToKeyPoint = distanceToKeyPoint;
		maxMagnitude = magnitude > maxMagnitude ? magnitude : maxMagnitude;
	}

	public Double getTheta() {
		return theta;
	}

	public void setTheta(Double theta) {
		this.theta = theta;
	}

	public Double getMagnitude() {
		return magnitude;
	}

	public Double getDistanceToKeyPoint() {
		return distanceToKeyPoint;
	}

	public void thresholdAtMax(double r) {
		magnitude = Math.min(magnitude, r * maxMagnitude);
	}

	public void thresholdAt(double threshold) {
		magnitude = Math.min(magnitude, threshold);
	}
	
	public void produceGradient(double magnitudeFactor, Color color){
		
		if(pixNode.getAreaSquare().getImageArea() != null){
			GraphicsContext gc = pixNode.getAreaSquare().getImageArea().gc;
	        gc.setLineWidth(1);
	        if(color == null)
	        	gc.setStroke(Color.AQUA);
	        else
	        	gc.setStroke(color);
	        
	        //gc.strokeOval(pixNode.getX(), pixNode.getY(), 0.1, 0.1);
	        gc.strokeLine(pixNode.getX(), pixNode.getY(), (Math.cos(theta) * magnitude * magnitudeFactor) + pixNode.getX(), (Math.sin(theta) * magnitude * magnitudeFactor) + pixNode.getY());
		}
		
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((magnitude == null) ? 0 : magnitude.hashCode());
		result = prime * result + ((theta == null) ? 0 : theta.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Gradient other = (Gradient) obj;
		if (magnitude == null) {
			if (other.magnitude != null)
				return false;
		} else if (!magnitude.equals(other.magnitude))
			return false;
		if (theta == null) {
			if (other.theta != null)
				return false;
		} else if (!theta.equals(other.theta))
			return false;
		return true;
	}

	@Override
	public String toString() {
		return String.format("Gradient [pixNode=%s, theta=%s, magnitude=%s, distanceToKeyPoint=%s]", pixNode, theta, magnitude, distanceToKeyPoint);
	}




}
package RN.linkage.vision;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

/**
 * @author Eric Marchand
 *
 */
public class Histogram {
	
	
	private Map<Double, Double> histogram = new HashMap<Double,Double>();
	
	private Double maxOrientationValue = null;
	private Double maxOrientationKey = null;

	public int size() {
		return histogram.size();
	}

	public boolean isEmpty() {
		return histogram.isEmpty();
	}

	public boolean containsKey(Object key) {
		return histogram.containsKey(key);
	}

	public boolean containsValue(Object value) {
		return histogram.containsValue(value);
	}

	public Double get(Object key) {
		return histogram.get(key);
	}

	public Double put(Double key, Double value) {
		
		if(maxOrientationValue == null || value > maxOrientationValue){
			maxOrientationKey = key;
			maxOrientationValue = value;
		}
		
		return histogram.put(key, value);
	}

	public Double remove(Object key) {
		
		if(key == maxOrientationKey){
			maxOrientationKey = null;
			maxOrientationValue = null;
		}
		
		return histogram.remove(key);
	}

	private void putAll(Map<? extends Double, ? extends Double> m) {
		histogram.putAll(m);
	}

	public void clear() {
		histogram.clear();
	}

	public Set<Double> keySet() {
		return histogram.keySet();
	}

	public Collection<Double> values() {
		return histogram.values();
	}

	public Set<Entry<Double, Double>> entrySet() {
		return histogram.entrySet();
	}

	public boolean equals(Object o) {
		return histogram.equals(o);
	}

	public int hashCode() {
		return histogram.hashCode();
	}

	public Double putIfAbsent(Double key, Double value) {
		
		if(maxOrientationValue == null || value > maxOrientationValue){
			maxOrientationKey = key;
			maxOrientationValue = value;
		}
		
		return histogram.putIfAbsent(key, value);
	}
	
	public Double getMaxOrientationKey(){
		
		return maxOrientationKey;
	}
	
	public Double getMaxOrientationValue(){
		
		if(maxOrientationKey == null)
			return null;
		
		return histogram.get(maxOrientationKey);
	}

	@Override
	public String toString() {
		return String.format("Histogram [histogram=%s]", histogram);
	}



}
package RN.linkage.vision;

import java.util.Map.Entry;

import RN.nodes.IPixelNode;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.paint.Color;

/**
 * @author Eric Marchand
 *
 */
public class KeyPoint {
	
	private IPixelNode keyPointNode = null;
	
	private EKeyPointType kpType = null;
	
	private Double x = null;
	
	private Double y = null;
	
	private Double sigma = null;
	
	private Double theta = null;
	
	private Double value = null;
	
	private Gradient[][] gradients = null;
	
	private KeyPointDescriptor descriptor = new KeyPointDescriptor();
	
	public KeyPoint(){
	}
	
	
	public KeyPoint(EKeyPointType kpType, IPixelNode keyPointNode, Double x, Double y, Double sigma, Double theta, Double value) {
		this.kpType = kpType;
		this.keyPointNode = keyPointNode;
		this.x = x;
		this.y = y;
		this.sigma = sigma;
		this.theta = theta;
		this.value = value;
	}
	
	public Double getMagnitudeSumByThetaRange(Double thetaMin, Double delta){
		Double sum = 0D;
		
//		for(Gradient[] gradientRow : getGradients()){
//			for(Gradient gradient : gradientRow){
//				if(gradient != null && gradient.getTheta() > thetaMin && gradient.getTheta() <= thetaMin + delta){
//					sum += gradient.getMagnitude();
//				}
//			}
//		}
		
		for(Histogram histogram : getDescriptor().getHistograms()){
			for(Entry<Double, Double> entry : histogram.entrySet()){
				if(entry.getKey() > thetaMin && entry.getKey() <= thetaMin + delta)	
					sum += entry.getValue();
			}
		}
		
		return normalizeValue(sum);
	}
	
	public Double normalizeValue(Double value){
		// Normalize value with small constant
		return value / Math.sqrt(Math.pow(value, 2D) + Math.pow(0.8, 2D));
	}

	public Double getX() {
		return x;
	}

	public void setX(Double x) {
		this.x = x;
	}

	public Double getY() {
		return y;
	}

	public void setY(Double y) {
		this.y = y;
	}

	public Double getSigma() {
		return sigma;
	}

	public void setSigma(Double sigma) {
		this.sigma = sigma;
	}

	public Double getTheta() {
		return theta;
	}

	public void setTheta(Double theta) {
		this.theta = theta;
	}

	public Double getValue() {
		return value;
	}

	public void setValue(Double value) {
		this.value = value;
	}


	public IPixelNode getKeyPointNode() {
		return (IPixelNode) keyPointNode;
	}


	public void setKeyPointNode(IPixelNode keyPointNode) {
		this.keyPointNode = keyPointNode;
	}
	
	public void produceCircle(){
		
		if(keyPointNode.getAreaSquare().getImageArea() != null){
			
			Long radius = null;
			GraphicsContext gc = keyPointNode.getAreaSquare().getImageArea().gc;
	        gc.setStroke(Color.RED);
	        gc.setLineWidth(1);
	        
	        // Cercle de rayon sigma autour du point d'interet
	        
			// We use the calcul of the FWHM to evaluate the radius at 1/1000 from 0 on y.
			// y= σ * sqrt{2ln(1000)} + x_{center}
			// radius = σ * sqrt{2ln(1000)} + x_{center}
			// radius = σ * 3,716922188849838 + x_{center}
			radius = Math.round(sigma * 3.7167D);
	        
	        gc.strokeOval(x - radius, y - radius, radius * 2D, radius * 2D);
	        
	        gc.setStroke(Color.AQUA);
	        gc.strokeLine(x, y, (Math.cos(theta) * radius) + x, (Math.sin(theta) * radius) + y);
		}
		
	}


	public KeyPointDescriptor getDescriptor() {
		return descriptor;
	}


	public void setDescriptor(KeyPointDescriptor descriptor) {
		this.descriptor = descriptor;
	}


	public void setGradients(Gradient[][] gradients) {
		this.gradients = gradients;
	}


	public Gradient[][] getGradients() {
		return gradients;
	}


	public Gradient getGradient(int x, int y) {
		Gradient gradient = null;
		try{
			gradient = gradients[x][y];
		}catch(ArrayIndexOutOfBoundsException aioob){
			//System.err.println("Impossible de recuperer le gradient pour (x,y) = (" + x + "," + y + ")");
		}
		
		return gradient;
	}


	@Override
	public String toString() {
		return String.format("KeyPoint [kpType=%s, x=%s, y=%s, sigma=%s, theta=%s, value=%s, descriptor=%s]", kpType, x, y, sigma, theta, value, descriptor);
	}


}
package RN.linkage.vision;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Eric Marchand
 *
 */
public class KeyPointDescriptor {
	
	List<Histogram> histograms = null;

	public KeyPointDescriptor() {
		this.histograms = new ArrayList<Histogram>();
	}

	public void concatenateHistogram(Histogram histogram) {
		histograms.add(histogram);
	}

	@Override
	public String toString() {
		return "KeyPointDescriptor [descriptor=" + histograms + "]";
	}

	public List<Histogram> getHistograms() {
		return histograms;
	}

	public void setHistograms(List<Histogram> histograms) {
		this.histograms = histograms;
	}



}
package RN.linkage.vision;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.linkage.FilterLinkage;
import RN.linkage.SigmaWi;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.control.Button;
import javafx.scene.control.Slider;
import javafx.scene.control.Tooltip;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public class V1OrientationsCellLinkage  extends FilterLinkage{

	private  Slider sigmaSlider = null;
	private  Slider thetaSlider = null;
	
	
	// GAUSSIENNE ELLIPTIQUE
	private Double mu = null;

	// centre
	private Double x1 = null;
	private Double y1 = null;

	// amplitude, hauteur de la forme pixelisée
	private Double alpha = null;
	

	// ecartement selon x et y
	private Double sigmaX = null;
	private Double sigmaY = null;
	
	// Angle de détection des contours pour les nodes appartenant à cette zone. (cf. Vision aire V1)
	protected Double theta = null;
	
	protected Double k = null;
	
	

	public V1OrientationsCellLinkage() {
	}
	
	public void initParameters() {
		
//		Le traitement repose sur cinq paramètres :
//		
//			N représente la taille du masque (matrice carrée) implantant le filtre LOG. N est impair.
//			σ permet d'ajuster la taille du chapeau mexicain.
//			∆x et ∆y sont les pas d'échantillonnage utilisés pour discrétiser h''(x,y). Généralement ∆x = ∆y
//			S est le seuil qui permet de sélectionner les contours les plus marqués.
//		
//			Il est à noter que le choix des paramètres N, σ et ∆x ne doit pas se faire de façon indépendante. 
//  		En effet, le masque, même de taille réduite, doit ressembler à un chapeau mexicain. Le problème ici est le même que celui que l'on rencontre lors de l'échantillonnage d'une fonction gaussienne. 
//          Le nombre de points N à considérer doit être tel que l'étendue occupe l'intervalle [-3σ , 3σ].
//			En fonction du pas d'échantillonnage, l'étendue spatiale vaut : (N-1) ∆x  .
//			Cette étendue peut aussi s'écrire en fonction de σ : (N-1) ∆x = kσ  avec k entier.
//			En prenant par exemple  ∆x = 1 , il s'agit de choisir N et σ de sorte que l'étendue du chapeau mexicain soit pertinente. 
//  		Pour le chapeau mexicain, la valeur de k doit être au moins de 4.
		
		double N = 13;
		double deltaX = 1;
		double k = 14D;
		
		sigmaX = (N-1) * deltaX / k;
		
		setTheta(params[0]);
		
		if(params.length == 2){
			setSigmaX(params[1]);
		}
		
		if(params.length == 3){
			setK(params[2]);
		}
		
		sigmaY = sigmaX;
		alpha = 1D;
		mu = 0D;
		
		
		
	}

	
	@Override
	public double getUnLinkedSigmaPotentials(INode thisNode){
		
		// somme des entrees pondérées
		SigmaWi sigmaWI = new SigmaWi();
		
			
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		
		if(getTheta() == null)
			throw new RuntimeException("Theta is not set on area");
		
		initFilter(this, ID_FILTER_V1Orientation, ESamples.G_D2xyTheta_DE_MARR, (IPixelNode) thisNode, subArea, getTheta(), getSigmaX());
		subArea.applyConvolutionFilter(this, ID_FILTER_V1Orientation, (IPixelNode) thisNode, sigmaWI);
			
		
		return sigmaWI.value();
	}
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		if(getTheta() == null)
			throw new RuntimeException("Theta is not set on area");
		
		initFilter(this, ID_FILTER_V1Orientation, ESamples.G_D2xyTheta_DE_MARR, (IPixelNode) thisNode, subArea, getTheta(), getSigmaX());
		subArea.applyConvolutionFilter(this, ID_FILTER_V1Orientation, (IPixelNode) thisNode, 0.00000001f);		

		
	}
	
	@Override
	public Double processFilter(ESamples filterFunction, IPixelNode sublayerNode, Double... params) {
		
		// Calcul du filtre gaussien
		// + Theta (angle du filtre en degré)
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		return  InputSample.getInstance().compute(
				filterFunction, 
				(double) subArea.getWidthPx(),
				(double) subArea.getHeightPx(), 
				(double) sublayerNode.getX(),
				(double) sublayerNode.getY(), 
				(double) subArea.getNodeCenterX(), 
				(double) subArea.getNodeCenterY(),
				sigmaX,
				sigmaY,
				params[0]);
	}
	
	public void addGraphicInterface(Pane pane) {
		
		sigmaSlider = new Slider(0D, 5D, sigmaX);
		sigmaSlider.setBlockIncrement(0.1D);
		sigmaSlider.setTooltip(new Tooltip("Sigma"));
		
		thetaSlider = new Slider(0D, 360, theta);
		thetaSlider.setBlockIncrement(1D);
		thetaSlider.setTooltip(new Tooltip("Theta (degrees)"));
		
		HBox hbox = new HBox();
		hbox.getChildren().addAll(sigmaSlider, thetaSlider);
		
		
		sigmaSlider.valueProperty().addListener(new ChangeListener<Number>() {
			public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
				setSigmaX(new_val.doubleValue());
				setSigmaY(new_val.doubleValue());
				System.out.println(String.format("Sigma : %.2f", new_val));
				try {
					FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_V1Orientation);
					FilterLinkage.removeFilter(idx);
					Double[] outputs = null;
					thisArea.propagation(false, outputs);
					((IAreaSquare) thisArea).showImageArea();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
		
		thetaSlider.valueProperty().addListener(new ChangeListener<Number>() {
			public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
				setTheta(new_val.doubleValue());
				System.out.println(String.format("Theta : %.2f", new_val));
				try {
					FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_V1Orientation);
					FilterLinkage.removeFilter(idx);
					Double[] outputs = null;
					thisArea.propagation(false, outputs);
					((IAreaSquare) thisArea).showImageArea();
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
		
		Button showFilterBtn = new Button("show filter");
		
		showFilterBtn.setTooltip(new Tooltip("show filter"));
		
		
		HBox hbox2 = new HBox();
		hbox2.getChildren().addAll(showFilterBtn);
		
		showFilterBtn.setOnAction(new EventHandler<ActionEvent>(){

			@Override
			public void handle(ActionEvent event) {
				try {
					//FilterIndex idx = new FilterIndex(thisArea.getIdentification(), ID_FILTER_CONVOLUTION);
					((IAreaSquare)thisArea).getFilter(ID_FILTER_V1Orientation).filterToImage(8);
					//thisArea.showImageArea();
				} catch (Exception e) {
					e.printStackTrace();
				}
				
			}
			
		});
		

		pane.getChildren().addAll(hbox, hbox2);
		
	}

	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void nextLayerFanOutLinkage(INode thisNode, ILayer nextlayer, long initFireTimeT) {
		// TODO Auto-generated method stub
		
	}

	public Double getMu() {
		return mu;
	}

	public void setMu(Double mu) {
		this.mu = mu;
	}

	public Double getX1() {
		return x1;
	}

	public void setX1(Double x1) {
		this.x1 = x1;
	}

	public Double getY1() {
		return y1;
	}

	public void setY1(Double y1) {
		this.y1 = y1;
	}

	public Double getAlpha() {
		return alpha;
	}

	public void setAlpha(Double alpha) {
		this.alpha = alpha;
	}

	public Double getTheta() {
		return theta;
	}

	public void setTheta(Double theta) {
		this.theta = theta;
	}

	public Double getK() {
		return k;
	}

	public void setK(Double k) {
		this.k = k;
	}

	public Double getSigmaX() {
		return sigmaX;
	}

	public void setSigmaX(Double sigmaX) {
		this.sigmaX = sigmaX;
	}

	public Double getSigmaY() {
		return sigmaY;
	}

	public void setSigmaY(Double sigmaY) {
		this.sigmaY = sigmaY;
	}

}
package RN.linkage.vision;

import RN.IAreaSquare;
import RN.ILayer;
import RN.dataset.inputsamples.ESamples;
import RN.nodes.INode;
import RN.nodes.IPixelNode;

/**
 * @author Eric Marchand
 *
 */
public class V1OrientationsStaticCellLinkage extends V1OrientationsCellLinkage {


	public V1OrientationsStaticCellLinkage() {
	}
	
	
	// Matrice carrée d'ordre N
	private static int N = 3;
	
	private static Double[][] staticFilter = new Double[][]{
																{0D,  0D,  1D,  1D,  1D,  0D,  0D},
																{0D,  1D,  1D,  1D,  1D,  1D,  0D},
																{1D,  1D, -1D, -4D, -1D,  1D,  1D},
																{1D,  1D, -4D, -8D, -4D,  1D,  1D},
																{1D,  1D, -1D, -4D, -1D,  1D,  1D},
																{0D,  1D,  1D,  1D,  1D,  1D,  0D},
																{0D,  0D,  1D,  1D,  1D,  0D,  0D},
	};
	
	public void initParameters() {
		
		setTheta(params[0]);
		
	}
	
	@Override
	public void sublayerFanOutLinkage(INode thisNode, ILayer sublayer) {
		
		
		IAreaSquare subArea = (IAreaSquare) getLinkedArea();
		
		if(getTheta() == null)
			throw new RuntimeException("Theta is not set on area");
		
		initFilter(this, ID_FILTER_V1Orientation, ESamples.G_D2xyTheta_DE_MARR, (IPixelNode) thisNode, subArea, getTheta());
		
		subArea.applyConvolutionFilter(this, ID_FILTER_V1Orientation, (IPixelNode) thisNode, 0.000001f);
		
	}
}
package RN.links;

/**
 * REGULAR, SHARED links : weights updated during backpropagation.
 * OTHERS : no update.
 * 
 * @author Eric
 *
 */
public enum ELinkType {

	REGULAR, SHARED, SELF_NODE_LINK, RECURRENT_LINK, RECURRENT_LATERAL_LINK, LAGGED_LINK, 
	
	// Vision 
	ON, OFF;
	
}
package RN.links;

import java.util.Random;

import RN.Graphics3D;
import RN.NetworkContext;
import RN.NetworkElement;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.nodes.INode;

/**
 * @author Eric Marchand
 *
 */
public class Link extends NetworkElement {

	public static final long SIMPLE_DELAY = 1;
	public static final long REGULAR_DELAY = 0;
	private static Random random = new Random();

	private int inputLinkId = 0;
	private int outputLinkId = 0;
	private Weight weight = new Weight(1.0D);
	private double unlinkedValue;
	private INode targetNode;
	private INode sourceNode;
	private double previousDeltaWeight;
	private boolean filterActive = false;
	private ESamples filter;
	private boolean modifiable = true;
	private ELinkType type = ELinkType.REGULAR;
	private long fireTimeT = -1;
	
	public static Link getInstance(ELinkType type, boolean modifiable) {
		return new Link(type, null, modifiable);
	}
	
	public static Link getInstance(Weight weight, boolean modifiable) {
		return new Link(ELinkType.SHARED, weight, modifiable);
	}

	private Link() {
		this.setWeight(1.0D);
		initFireTimes();
	}

	private Link(double weight) {
		this.setWeight(weight);
		initFireTimes();
	}

	private Link(double weight, boolean isBias) {
		this.setWeight(weight);
		if (isBias)
			this.inputLinkId = -1;
		initFireTimes();
	}

	private Link(ELinkType type, Weight weight, boolean modifiable) {
		
		if(type == ELinkType.SHARED){
			this.weight = weight;
		}else{
			this.setWeight(1.0D);
		}
		this.setType(type);
		this.setWeightModifiable(modifiable);
		initFireTimes();
	}

	private Link(ELinkType type, boolean modifiable, boolean filterActive, ESamples filter) {
		this(type, null, modifiable);
		this.setFilterActive(filterActive);
		this.setFilter(filter);
	}

	public void initWeight(double min, double max) {
		this.setWeight(random.nextDouble() * (max - min) + min);
		this.setPreviousDeltaWeight(0.0);
	}

	public void initWeight(double value) {
		this.setWeight(value);
		this.setPreviousDeltaWeight(0.0);
	}

	public double getValue() {

		if (filterActive) {
			
			if (sourceNode != null) {
				return InputSample.getInstance().compute(filter, this.sourceNode.getComputedOutput());
			} else
				return InputSample.getInstance().compute(filter, this.unlinkedValue);
			
		} else {
			
			if (sourceNode != null)
				return this.sourceNode.getComputedOutput();
			else
				return this.unlinkedValue;
			
		}
	}

	public double getWeight(Double... params) {

		if (filterActive) {
			return InputSample.getInstance().compute(filter, params);
		} else {
			return weight.getWeight();
		}

	}

	public double getWeight() {
		return weight.getWeight();
	}

	public void setWeight(double weight) {
		if(this.weight == null) {
			this.weight = new Weight(weight);
		} else {
			this.weight.setWeight(weight);
		}
		Graphics3D.setWeightOnLink(this);
	}

	public String toString() {
		return (inputLinkId != -1 ? "Link" + inputLinkId : "Bias ") + " w: " + weight;
	}

	public String getString() {
		String sourceS = "";
		String targetS = "";
		if (sourceNode != null) {
			sourceS = "source:" + sourceNode.getIdentification();
		}
		if (targetNode != null) {
			targetS = " target:" + targetNode.getIdentification();
		}
		return "Fire at: " + fireTimeT + "  Link " + sourceS + targetS + "  [v : " + getValue() + "  w : " + this.weight
				+ "  previousDw : " + previousDeltaWeight + "   modifiable :" + this.modifiable + "]";
	}

	public void setInputLinkId(int linkId) {
		this.inputLinkId = linkId;
	}

	public double getPreviousDeltaWeight() {
		return previousDeltaWeight;
	}

	public void setPreviousDeltaWeight(double previousDeltaWeight) {
		this.previousDeltaWeight = previousDeltaWeight;
	}

	public void setTargetNode(INode iNode) {
		this.targetNode = iNode;

	}

	public INode getTargetNode() {
		return targetNode;
	}

	public boolean isFilterActive() {
		return filterActive;
	}

	public void setFilterActive(boolean filterActive) {
		this.filterActive = filterActive;
	}

	public ESamples getFilter() {
		return filter;
	}

	public void setFilter(ESamples filter) {
		this.filter = filter;
	}

	public boolean isWeightModifiable() {
		return modifiable;
	}

	public void setWeightModifiable(boolean modifiable) {
		this.modifiable = modifiable;
	}

	public INode getSourceNode() {
		return sourceNode;
	}

	public void setSourceNode(INode iNode) {
		this.sourceNode = iNode;
	}

	public int getOutputLinkId() {
		return outputLinkId;
	}

	public void setOutputLinkId(int outputLinkId) {
		this.outputLinkId = outputLinkId;
	}

	public ELinkType getType() {
		return type;
	}

	public void setType(ELinkType type) {
		this.type = type;
	}

	public Link deepCopy() {

		Link copy_link = new Link(weight.getWeight());
		copy_link.setFilter(filter);
		copy_link.setFilterActive(filterActive);
		copy_link.setInputLinkId(inputLinkId);
		copy_link.setOutputLinkId(outputLinkId);
		copy_link.setPreviousDeltaWeight(previousDeltaWeight);
		copy_link.setWeightModifiable(modifiable);
		copy_link.setType(type);
		copy_link.setUnlinkedValue(unlinkedValue);
		copy_link.setFireTimeT(fireTimeT);

		if (sourceNode != null)
			copy_link.setSourceNode(
					sourceNode.getArea().getLayer().getNetwork().getNode(sourceNode.getArea().getLayer().getLayerId(),
							sourceNode.getArea().getAreaId(), sourceNode.getNodeId()));

		if (targetNode != null)
			copy_link.setTargetNode(
					targetNode.getArea().getLayer().getNetwork().getNode(targetNode.getArea().getLayer().getLayerId(),
							targetNode.getArea().getAreaId(), targetNode.getNodeId()));

		return copy_link;
	}

	public double getUnlinkedValue() {
		return unlinkedValue;
	}

	public void setUnlinkedValue(double unlinkedValue) {
		this.unlinkedValue = unlinkedValue;
	}

	public void synchFutureFire() {
		fireTimeT = fireTimeT + NetworkContext.INCREMENTUM + getActionPotentialDelay(type);
	}

	private long getActionPotentialDelay(ELinkType linkType) {

		// if(linkType == ELinkType.REGULAR)
		// return REGULAR_DELAY;
		// else if(linkType == ELinkType.RECURRENT_LATERAL_LINK)
		// return REGULAR_DELAY;
		// else if(linkType == ELinkType.RECURRENT_LINK)
		// return REGULAR_DELAY;
		// else if(linkType == ELinkType.SELF_NODE_LINK)
		// return REGULAR_DELAY;
		// else

		if (linkType == ELinkType.LAGGED_LINK)
			return SIMPLE_DELAY;
		else
			return REGULAR_DELAY;

	}

	public long getFireTimeT() {
		return fireTimeT;
	}

	public void setFireTimeT(long fireTimeT) {
		this.fireTimeT = fireTimeT;
	}

	public void initFireTimes() {

		if (this.getType() == ELinkType.LAGGED_LINK)
			this.setFireTimeT(Link.SIMPLE_DELAY);
		else
			this.setFireTimeT(Link.REGULAR_DELAY);

	}
	
	public boolean isBias(){
		return this.inputLinkId == -1;
	}

	public void initGraphics() {
		if(Graphics3D.graphics3DActive)
			Graphics3D.createLink(this);
	}



}
package RN.links;

import java.io.Serializable;

/**
 * @author Eric Marchand
 *
 */
public class Weight implements Serializable{
	
	private double weight = 1.0D;

	
	public Weight(double weight){
		this.weight = weight;
	}
	
	public Weight(){
	}
	
	
	public double getWeight() {
		return weight;
	}

	public void setWeight(double weight) {
		this.weight = weight;
	}
	
	
	public void add(double value){
		weight += value;
	}
	
	public String toString(){
		return Double.valueOf(weight).toString();
	}
	

}
package RN;

import java.util.List;
import java.util.ListIterator;

import RN.dataset.InputData;
import RN.dataset.OutputData;
import RN.nodes.INode;
import dmonner.xlbp.Component;
import dmonner.xlbp.Network;
import dmonner.xlbp.NetworkCopier;
import dmonner.xlbp.NetworkStringBuilder;
import dmonner.xlbp.UpstreamComponent;
import dmonner.xlbp.WeightInitializer;
import dmonner.xlbp.WeightUpdaterType;
import dmonner.xlbp.layer.InputLayer;
import dmonner.xlbp.layer.TargetLayer;

/**
 * @author Eric Marchand
 * 
 */
public class NetLSTMNetwork extends Network implements INetwork {

	public NetLSTMNetwork(String name) {
		super(name);
	}

	@Override
	public void activateTest() {
		// TODO Auto-generated method stub
		super.activateTest();
	}

	@Override
	public void activateTrain() {
		// TODO Auto-generated method stub
		super.activateTrain();
	}

	@Override
	public void add(Component component) {
		// TODO Auto-generated method stub
		super.add(component);
	}

	@Override
	public void add(Component component, boolean activate, boolean train, boolean entry, boolean exit) {
		// TODO Auto-generated method stub
		super.add(component, activate, train, entry, exit);
	}

	@Override
	public void addActivateOnly(Component component) {
		// TODO Auto-generated method stub
		super.addActivateOnly(component);
	}

	@Override
	public void addTrainOnly(Component component) {
		// TODO Auto-generated method stub
		super.addTrainOnly(component);
	}

	@Override
	public void addUpstream(UpstreamComponent upstream) {
		// TODO Auto-generated method stub
		super.addUpstream(upstream);
	}

	@Override
	public void addUpstream(UpstreamComponent upstream, boolean weighted) {
		// TODO Auto-generated method stub
		super.addUpstream(upstream, weighted);
	}

	@Override
	public void addUpstreamWeights(UpstreamComponent upstream) {
		// TODO Auto-generated method stub
		super.addUpstreamWeights(upstream);
	}

	@Override
	public void build() {
		// TODO Auto-generated method stub
		super.build();
	}

	@Override
	public void clear() {
		// TODO Auto-generated method stub
		super.clear();
	}

	@Override
	public void clearActivations() {
		// TODO Auto-generated method stub
		super.clearActivations();
	}

	@Override
	public void clearEligibilities() {
		// TODO Auto-generated method stub
		super.clearEligibilities();
	}

	@Override
	public void clearInputs() {
		// TODO Auto-generated method stub
		super.clearInputs();
	}

	@Override
	public void clearResponsibilities() {
		// TODO Auto-generated method stub
		super.clearResponsibilities();
	}

	@Override
	public int compareTo(Component that) {
		// TODO Auto-generated method stub
		return super.compareTo(that);
	}

	@Override
	public Network copy(NetworkCopier copier) {
		// TODO Auto-generated method stub
		return super.copy(copier);
	}

	@Override
	public Network copy(String suffix) {
		// TODO Auto-generated method stub
		return super.copy(suffix);
	}

	@Override
	public Network copy(String suffix, boolean copyState, boolean copyWeights) {
		// TODO Auto-generated method stub
		return super.copy(suffix, copyState, copyWeights);
	}

	@Override
	public Network copy(String prefix, String suffix, boolean copyState, boolean copyWeights) {
		// TODO Auto-generated method stub
		return super.copy(prefix, suffix, copyState, copyWeights);
	}

	@Override
	public void copyConnectivityFrom(Component comp, NetworkCopier copier) {
		// TODO Auto-generated method stub
		super.copyConnectivityFrom(comp, copier);
	}

	@Override
	public void ensureActivateCapacity(int cActivate) {
		// TODO Auto-generated method stub
		super.ensureActivateCapacity(cActivate);
	}

	@Override
	public void ensureAllCapacity(int cAll) {
		// TODO Auto-generated method stub
		super.ensureAllCapacity(cAll);
	}

	@Override
	public void ensureDirectEntryCapacity(int cEntry) {
		// TODO Auto-generated method stub
		super.ensureDirectEntryCapacity(cEntry);
	}

	@Override
	public void ensureDirectExitCapacity(int cExit) {
		// TODO Auto-generated method stub
		super.ensureDirectExitCapacity(cExit);
	}

	@Override
	public void ensureInputCapacity(int cInputs) {
		// TODO Auto-generated method stub
		super.ensureInputCapacity(cInputs);
	}

	@Override
	public void ensureSubnetCapacity(int cSubnets) {
		// TODO Auto-generated method stub
		super.ensureSubnetCapacity(cSubnets);
	}

	@Override
	public void ensureTargetCapacity(int cTargets) {
		// TODO Auto-generated method stub
		super.ensureTargetCapacity(cTargets);
	}

	@Override
	public void ensureTrainCapacity(int cTrain) {
		// TODO Auto-generated method stub
		super.ensureTrainCapacity(cTrain);
	}

	@Override
	public void ensureWeightedEntryCapacity(int cEntry) {
		// TODO Auto-generated method stub
		super.ensureWeightedEntryCapacity(cEntry);
	}

	@Override
	public Component getActivate(int index) {
		// TODO Auto-generated method stub
		return super.getActivate(index);
	}

	@Override
	public int getActivateSize() {
		// TODO Auto-generated method stub
		return super.getActivateSize();
	}

	@Override
	public Component getComponent(int index) {
		// TODO Auto-generated method stub
		return super.getComponent(index);
	}

	@Override
	public Component getComponentByName(String name) {
		// TODO Auto-generated method stub
		return super.getComponentByName(name);
	}

	@Override
	public Component[] getComponents() {
		// TODO Auto-generated method stub
		return super.getComponents();
	}

	@Override
	public UpstreamComponent getExitPoint() {
		// TODO Auto-generated method stub
		return super.getExitPoint();
	}

	@Override
	public UpstreamComponent getExitPoint(int i) {
		// TODO Auto-generated method stub
		return super.getExitPoint(i);
	}

	@Override
	public InputLayer getInputLayer() {
		// TODO Auto-generated method stub
		return super.getInputLayer();
	}

	@Override
	public InputLayer getInputLayer(int index) {
		// TODO Auto-generated method stub
		return super.getInputLayer(index);
	}

	@Override
	public InputLayer[] getInputLayers() {
		// TODO Auto-generated method stub
		return super.getInputLayers();
	}

	@Override
	public String getName() {
		// TODO Auto-generated method stub
		return super.getName();
	}

	@Override
	public int getNExitPoints() {
		// TODO Auto-generated method stub
		return super.getNExitPoints();
	}

	@Override
	public TargetLayer getTargetLayer() {
		// TODO Auto-generated method stub
		return super.getTargetLayer();
	}

	@Override
	public TargetLayer getTargetLayer(int index) {
		// TODO Auto-generated method stub
		return super.getTargetLayer(index);
	}

	@Override
	public TargetLayer[] getTargetLayers() {
		// TODO Auto-generated method stub
		return super.getTargetLayers();
	}

	@Override
	public Component getTrain(int index) {
		// TODO Auto-generated method stub
		return super.getTrain(index);
	}

	@Override
	public int getTrainSize() {
		// TODO Auto-generated method stub
		return super.getTrainSize();
	}

	@Override
	public boolean isBuilt() {
		// TODO Auto-generated method stub
		return super.isBuilt();
	}

	@Override
	public int nInput() {
		// TODO Auto-generated method stub
		return super.nInput();
	}

	@Override
	public int nTarget() {
		// TODO Auto-generated method stub
		return super.nTarget();
	}

	@Override
	public int nWeights() {
		// TODO Auto-generated method stub
		return super.nWeights();
	}

	@Override
	public int nWeightsDeep() {
		// TODO Auto-generated method stub
		return super.nWeightsDeep();
	}

	@Override
	public boolean optimize() {
		// TODO Auto-generated method stub
		return super.optimize();
	}

	@Override
	public void processBatch() {
		// TODO Auto-generated method stub
		super.processBatch();
	}

	@Override
	public void rebuild() {
		// TODO Auto-generated method stub
		super.rebuild();
	}

	@Override
	public void setActivateSize(int nActivate) {
		// TODO Auto-generated method stub
		super.setActivateSize(nActivate);
	}

	@Override
	public void setAllSize(int nAll) {
		// TODO Auto-generated method stub
		super.setAllSize(nAll);
	}

	@Override
	public void setInput(float[] input) {
		// TODO Auto-generated method stub
		super.setInput(input);
	}

	@Override
	public void setInput(int index, float[] activations) {
		// TODO Auto-generated method stub
		super.setInput(index, activations);
	}

	@Override
	public void setInputSize(int nInputs) {
		// TODO Auto-generated method stub
		super.setInputSize(nInputs);
	}

	@Override
	public void setTarget(float[] target) {
		// TODO Auto-generated method stub
		super.setTarget(target);
	}

	@Override
	public void setTarget(int index, float[] activations) {
		// TODO Auto-generated method stub
		super.setTarget(index, activations);
	}

	@Override
	public void setTargetSize(int nTargets) {
		// TODO Auto-generated method stub
		super.setTargetSize(nTargets);
	}

	@Override
	public void setTrainSize(int nTrain) {
		// TODO Auto-generated method stub
		super.setTrainSize(nTrain);
	}

	@Override
	public void setWeightInitializer(WeightInitializer win) {
		// TODO Auto-generated method stub
		super.setWeightInitializer(win);
	}

	@Override
	public void setWeightUpdaterType(WeightUpdaterType wut) {
		// TODO Auto-generated method stub
		super.setWeightUpdaterType(wut);
	}

	@Override
	public int size() {
		// TODO Auto-generated method stub
		return super.size();
	}

	@Override
	public String toString() {
		// TODO Auto-generated method stub
		return super.toString();
	}

	@Override
	public void toString(NetworkStringBuilder sb) {
		// TODO Auto-generated method stub
		super.toString(sb);
	}

	@Override
	public String toString(String show) {
		// TODO Auto-generated method stub
		return super.toString(show);
	}

	@Override
	public void unbuild() {
		// TODO Auto-generated method stub
		super.unbuild();
	}

	@Override
	public void updateEligibilities() {
		// TODO Auto-generated method stub
		super.updateEligibilities();
	}

	@Override
	public void updateResponsibilities() {
		// TODO Auto-generated method stub
		super.updateResponsibilities();
	}

	@Override
	public void updateWeights() {
		// TODO Auto-generated method stub
		super.updateWeights();
	}

	@Override
	public int hashCode() {
		// TODO Auto-generated method stub
		return super.hashCode();
	}

	@Override
	public boolean equals(Object obj) {
		// TODO Auto-generated method stub
		return super.equals(obj);
	}

	@Override
	protected Object clone() throws CloneNotSupportedException {
		// TODO Auto-generated method stub
		return super.clone();
	}

	@Override
	protected void finalize() throws Throwable {
		// TODO Auto-generated method stub
		super.finalize();
	}

	@Override
	public OutputData compute(ListIterator<InputData> itr) throws Exception {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ILayer getFirstLayer() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ILayer getLastLayer() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void show() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public ILayer getLayer(int i) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<ILayer> getLayers() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public OutputData propagation(boolean trainingActive) throws Exception {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<INode> getAllNodes() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void addLayer(ILayer layer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void finalizeConnections() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void init(double d, double e) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public String getString() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setTimeSeriesOffset(Integer timeSeriesOffset) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Integer getTimeSeriesOffset() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setRecurrentNodesLinked(Boolean lateralLinkRecurrentNodes) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Boolean isRecurrentNodesLinked() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setAbsoluteError(double absoluteError) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public double getAbsoluteError() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public INetwork deepCopy(int generationCount) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void disconnectAll() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void setName(String name) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void appendName(String name) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public String geneticCodec() {
		// TODO Auto-generated method stub
		return null;
	}



	@Override
	public void newLearningCycle(int trainCycleAbsolute) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void initBiasWeights(double value) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public ENetworkImplementation getImpl() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public INode getNode(Identification id) {
		// TODO Auto-generated method stub
		return null;
	}

}
package RN;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;

import RN.dataset.InputData;
import RN.dataset.OutputData;
import RN.dataset.OutputDataList;
import RN.fxml.controllers.NN;
import RN.genetic.Genetic;
import RN.linkage.Linkage;
import RN.links.Link;
import RN.nodes.ENodeType;
import RN.nodes.INode;
import RN.nodes.IPixelNode;
import RN.utils.StatUtils;

/**
 * @author Eric Marchand
 * 
 */
public class Network extends NetworkElement implements Serializable, INetwork{

	private List<ILayer> layers = null;

	private OutputDataList outputDataList = new OutputDataList();

	private Integer recurrentLayerId = null;

	private String name = null;

	private Integer timeSeriesOffset = null;

	private Boolean recurrentNodesLinked = Boolean.FALSE;
	
	private double absoluteError = 0.0D;

	private ENetworkImplementation impl = ENetworkImplementation.LINKED;
	
	
	private Network() {
		layers = new ArrayList<ILayer>();
	}
	
	private Network(ENetworkImplementation impl) {
		layers = new ArrayList<ILayer>();
		
		if(impl != null)
			this.impl  = impl;
	}
	
	public static Network getInstance(){
		return getInstance(null);
	}
	
	public static Network getInstance(ENetworkImplementation impl){
		if(network == null){
			network = new Network(impl);
		}
		return network;
	}
	
	public static Network newInstance(ENetworkImplementation impl){
		network = new Network(impl);
		return network;
	}

	

	public void addLayer(ILayer layer) {
		layer.setLayerId(layers.size());
		layers.add(layer);
		layer.setNetwork(this);
		layer.initGraphics();
	}
	
	public void addLayer(ILayer... layers) {
		for(ILayer lay: layers)
			addLayer(lay);
	}

	public ILayer getLayer(int idLayer) {
		return layers.get(idLayer);
	}

	public List<ILayer> getLayers() {
		return layers;
	}

	public void setLayers(List<ILayer> layers) {
		this.layers = layers;
	}

	/**
	 * 
	 */
	public void finalizeConnections() {

		if (network.getImpl() == ENetworkImplementation.LINKED) {

			System.out.println("Begin finalize network connections...");
			
			for (ILayer layer : layers) {

				// Create recurrent nodes in input layer if needed
				layer.finalizeConnections();
				
				// finalize connections between areas themselves
				finalizeAreasConnections(layer);
				
			}
			
			System.out.println("End finalize network connections.");

		} else {

			System.out.println(
					"Network created without any link object, method finalizeConnections() is useless in this case.");
		}


		// Every nodes are linked, let's init links for future firings
		// Set<Link> uniqLinks = new LinkedHashSet<Link>();
		// for(INode node : getAllNodes()){
		// uniqLinks.addAll(node.getInputs());
		// uniqLinks.addAll(node.getOutputs());
		// if(node.getBiasInput() != null)
		// uniqLinks.add(node.getBiasInput());
		// }
		// for(Link link : uniqLinks){
		// link.initFireTimes();
		// }

	}

	private void finalizeAreasConnections(ILayer layer) {
		List<IArea> areas = layer.getAreas();

		for (IArea area : areas) {

			// Linkage is done following ELinkage type.
			// recurrent nodes linked themselves and finalize
			// connections between LSTM nodes (timeseries).
			area.finalizeConnections();

		}
	}

	/**
	 * 
	 */
	public void init(double min, double max) {
		
		System.out.println("Randomisation des poids modifiables.");
		Double biasWeight = null;
		for (ILayer layer : layers) {
			
			if (layer.isFirstLayer())
				continue;
			
//			if(impl == ENetworkImplementation.LINKED){
//				
//				List<INode> layersNodes = layer.getLayerNodes();
//				for (INode node : layersNodes) {
//					
//					for (Link link : node.getInputs()){
//						if(link.isWeightModifiable())
//							link.initWeight(min, max);
//					}
//					
//					// initialisation du biais
//					biasWeight = getContext().getNodeBiasWeights()[layer.getLayerId()];
//					if(node.getBiasInput() != null && biasWeight != null){
//						
//						if(biasWeight != 1D){
//							node.getBiasInput().setWeight(getContext().getNodeBiasWeights()[layer.getLayerId()]);
//							node.getBiasInput().setPreviousDeltaWeight(0.0);
//						}else{
//							node.getBiasInput().initWeight(min, max);
//						}
//						
//					}
//					
//					
//				}
//				
//				
//			}else{
//				
//				for(IArea area : layer.getAreas()){
//					if(area.getLinkage().isWeightModifiable()){
//						for(INode node : area.getNodes()){
//							node.setBiasWeightValue(StatUtils.initValue(min, max));
//							node.setBiasPreviousDeltaWeight(0.0);
//						}
//					}
//					
//				}
//				
//			}
			
			for(IArea area : layer.getAreas()){
				if(area.getLinkage().isWeightModifiable()){
					for(INode node : area.getNodes()){
						node.setBiasWeightValue(StatUtils.initValue(min, max));
						node.setBiasPreviousDeltaWeight(0.0);
					}
				}
				
			}

		}
		
		if(impl == ENetworkImplementation.UNLINKED){
			
			for(Map<Identification, Link> entry : Linkage.getLinks().values()){
				for(Link link : entry.values()){
					if(link.isWeightModifiable()){
						link.initWeight(min, max);
					}
				}
			}
		}
		

	}
	
	public void init(double value) {

		
		for (ILayer layer : layers) {
			if (layer.isFirstLayer())
				continue;

			List<INode> layersNodes = layer.getLayerNodes();
			for (INode node : layersNodes) {
				
				for (Link link : node.getInputs())
					if(link.isWeightModifiable())
						link.initWeight(value);
				
				node.getBiasInput().initWeight(value);
			}

		}

	}
	
	public void initBiasWeights(double value) {

		
		for (ILayer layer : layers) {
			
//			if (layer.isFirstLayer())
//				continue;

			List<INode> layersNodes = layer.getLayerNodes();
			for (INode node : layersNodes) {
				
//				for (Link link : node.getInputs())
//					if(link.isWeightModifiable())
//						link.initWeight(value);
				if(getImpl() == null || getImpl() == ENetworkImplementation.LINKED)
					node.getBiasInput().initWeight(value);
				else
					node.setBiasWeightValue(value);
			}

		}

	}

	public void show() {

		Double arg0 = layers.get(0).getLayerNodes().get(0).getInputs().get(0).getValue();
		NN.valinp0.setText(arg0.toString());
		arg0 = layers.get(0).getLayerNodes().get(1).getInputs().get(0).getValue();
		NN.valinp1.setText(arg0.toString());
		arg0 = layers.get(0).getLayerNodes().get(0).getComputedOutput();
		NN.valinp0out.setText(arg0.toString());
		arg0 = layers.get(0).getLayerNodes().get(1).getComputedOutput();
		NN.valinp1out.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(0).getInputs().get(0).getValue() + layers.get(1).getLayerNodes().get(0).getInputs().get(1).getValue();
		NN.valhid0inp.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(1).getInputs().get(0).getValue() + layers.get(1).getLayerNodes().get(0).getInputs().get(1).getValue();
		NN.valhid1inp.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(2).getInputs().get(0).getValue() + layers.get(1).getLayerNodes().get(0).getInputs().get(1).getValue();
		NN.valhid2inp.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(0).getComputedOutput();
		NN.valhid0out.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(1).getComputedOutput();
		NN.valhid1out.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(2).getComputedOutput();
		NN.valhid2out.setText(arg0.toString());
		arg0 = layers.get(2).getLayerNodes().get(0).getInputs().get(0).getValue() + layers.get(2).getLayerNodes().get(0).getInputs().get(1).getValue()
				+ layers.get(2).getLayerNodes().get(0).getInputs().get(2).getValue();
		NN.valout0inp.setText(arg0.toString());
		arg0 = layers.get(2).getLayerNodes().get(0).getComputedOutput();
		NN.valout0out.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(0).getError();
		NN.errhid0.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(1).getError();
		NN.errhid1.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(2).getError();
		NN.errhid2.setText(arg0.toString());
		arg0 = layers.get(2).getLayerNodes().get(0).getError();
		NN.errout0.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(0).getInputs().get(0).getWeight();
		NN.whid0inp0.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(0).getInputs().get(1).getWeight();
		NN.whid0inp1.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(1).getInputs().get(0).getWeight();
		NN.whid1inp0.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(1).getInputs().get(1).getWeight();
		NN.whid1inp1.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(2).getInputs().get(0).getWeight();
		NN.whid2inp0.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(2).getInputs().get(1).getWeight();
		NN.whid2inp1.setText(arg0.toString());

		if (layers.get(1).getLayerNodes().get(0).getBiasInput() != null) {
			arg0 = layers.get(1).getLayerNodes().get(0).getBiasInput().getWeight();
			NN.wbiashid0.setText(arg0.toString());
		}
		if (layers.get(1).getLayerNodes().get(1).getBiasInput() != null) {
			arg0 = layers.get(1).getLayerNodes().get(1).getBiasInput().getWeight();
			NN.wbiashid1.setText(arg0.toString());
		}
		if (layers.get(1).getLayerNodes().get(2).getBiasInput() != null) {
			arg0 = layers.get(1).getLayerNodes().get(2).getBiasInput().getWeight();
			NN.wbiashid2.setText(arg0.toString());
		}
		if (layers.get(2).getLayerNodes().get(0).getBiasInput() != null) {
			arg0 = layers.get(2).getLayerNodes().get(0).getBiasInput().getWeight();
			NN.wbiasout0.setText(arg0.toString());
		}
		arg0 = layers.get(2).getLayerNodes().get(0).getInputs().get(0).getWeight();
		NN.wout0hid0.setText(arg0.toString());
		arg0 = layers.get(2).getLayerNodes().get(0).getInputs().get(1).getWeight();
		NN.wout0hid1.setText(arg0.toString());
		arg0 = layers.get(2).getLayerNodes().get(0).getInputs().get(2).getWeight();
		NN.wout0hid2.setText(arg0.toString());
		arg0 = layers.get(2).getLayerNodes().get(0).getIdealOutput();
		NN.validealout0.setText(arg0.toString());
		arg0 = layers.get(2).getLayerNodes().get(0).getDerivativeValue();
		NN.valaggout0.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(0).getDerivativeValue();
		NN.valagghid0.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(1).getDerivativeValue();
		NN.valagghid1.setText(arg0.toString());
		arg0 = layers.get(1).getLayerNodes().get(2).getDerivativeValue();
		NN.valagghid2.setText(arg0.toString());

	}

	/**
	 * @return
	 */
	public List<INode> getAllNodes() {
		List<INode> allNodes = new ArrayList<INode>();
		for (ILayer layer : layers) {
			allNodes.addAll(layer.getLayerNodes());
		}
		return allNodes;
	}
	
	public List<IArea> getAllAreas() {
		List<IArea> allAreas = new ArrayList<IArea>();
		for (ILayer layer : layers) {
			allAreas.addAll(layer.getAreas());
		}
		return allAreas;
	}
	
	public List<INode> getNodesByType(ENodeType type) {
		List<INode> nodes = new ArrayList<INode>();
		for (ILayer layer : layers) {
			nodes.addAll(layer.getLayerNodes(type));
		}
		return nodes;
	}
	
	/**
	 * 
	 */
	public void disconnectAll(){
		for (ILayer layer : layers) {
			List<INode> layersNodes = layer.getLayerNodes();
			for (INode node : layersNodes) {
				node.disconnect();
			}

		}
	}

	/**
	 * @param entry
	 * @return
	 * @throws Exception
	 */
	public OutputData compute(ListIterator<InputData> dataIter) throws Exception {
		
		int nextIndex = dataIter.nextIndex();
		InputData entries = dataIter.next();
		Iterator<Double> inputIter = entries.getInput().iterator();
		Integer offset = getTimeSeriesOffset();
		Double inputValue = null;

		int dataSetSize = DataSeries.getInstance().getInputDataSet().size();
		int n = 1;

		ListIterator<InputData> tmpItr = null;
		// set input data on input time serie nodes
		List<INode> firstLayerNodes = getFirstLayer().getLayerNodes();
		for (INode node : firstLayerNodes) {

			if (node.getNodeType() == ENodeType.TIMESERIE) {

				if (tmpItr != null && tmpItr.hasNext()) {
					InputData indata = (InputData) tmpItr.next();
					inputIter = indata.getInput().listIterator();
				}

				if (inputIter.hasNext()) {
					inputValue = inputIter.next();
					node.setEntry(inputValue);

					entries.getInput().set(n - 1, inputValue);

					if ((nextIndex + (n * offset)) < dataSetSize - 1)
						tmpItr = DataSeries.getInstance().getInputDataSet().listIterator(nextIndex + (n * offset));
					else {
						nextIndex = nextIndex - dataSetSize + 1;
						tmpItr = DataSeries.getInstance().getInputDataSet().listIterator(nextIndex + (n * offset));
					}

				} else {
					node.setEntry(0.0D);
				}

			}else{
				inputValue = entries.getInput().get(node.getNodeId());
				node.setEntry(inputValue);
			}
			
			n++;

		}



		return propagation(false);
	}

	/**
	 * @throws Exception
	 */
	public OutputData propagation(boolean playAgain) throws Exception {

		OutputData outputData = null;
		// outputDataList.clear();

		// start of propagation
		getContext().incrementClock();
		
		// one pass forward
		List<ILayer> layers = getLayers();
		Double[] outputValues = null;
		for (ILayer layer : layers) {

			 outputValues = layer.propagate(playAgain);

			// on conserve les sorties pour un eventuel traitement par batch
			if (outputValues != null && layer.isLastLayer()) {
//				outputDataList.addData(outputValues);
				outputData = new OutputData(outputValues);
			}
			
		}
		
		return outputData;

	}
	
	/* (non-Javadoc)
	 * @see RN.INetwork#newLearningCycle()
	 */
	@Override
	public void newLearningCycle(int cycleCount) {
		
		// Initialisation des parametres des noeuds
		for(INode node : getAllNodes())
			node.newLearningCycle(cycleCount);
		
	}

	public String getString() {
		String result = "";
		result += ITester.NEWLINE + "Clock : " + getContext().getClock();
		for (ILayer layer : layers) {
			
			result = layerToString(result, layer);
			
		}
		return result;
	}

	private String layerToString(String result, ILayer layer) {
		
		List<IArea> areas = layer.getAreas();
		int jump = 0;
		
		result += ITester.NEWLINE + layer.toString();
		
		for (IArea area : areas) {
			
			result += ITester.NEWLINE + area.toString();
			
			List<INode> nodes = area.getNodes();
			
			INode node = null;
			if(nodes.size() > 50){
				result += ITester.NEWLINE + ITester.NEWLINE + "        ----------------> Too much nodes to print ("+ nodes.size() + "), we will print the first and last 10th nodes..." + ITester.NEWLINE + ITester.NEWLINE;
				jump = 10;
			}
			for (int id=0; id < nodes.size(); id++) {
				
				if(jump > 0 && id > jump && id < nodes.size() - jump)
					continue;
				else if(jump > 0 && id == jump)
					result += ITester.NEWLINE + "\n\n\n---------------- Jumping to the last 10th nodes... ----------------\n\n\n";
				
				node = nodes.get(id);
				result += ITester.NEWLINE + node.getString();
			}
		}
		return result;
	}
	
	public INode getNode(Identification id){
		return layers.get(id.getLayerId()).getArea(id.getAreaId()).getNode(id.getNodeId());
	}
	
	public INode getNode(int layerId, int areaId, int nodeId){
		
		INode node = layers.get(layerId).getArea(areaId).getNode(nodeId);

		return node;
	}
	
	public IPixelNode getNode(int layerId, int areaId, int x, int y) throws Exception{
		IAreaSquare area = (IAreaSquare) layers.get(layerId).getArea(areaId);
		IPixelNode node = area.getNodeXY(x, y);

		return node;
	}

	public String toString() {

		return this.name;
	}

	public ILayer getFirstLayer() {
		return layers.get(0);
	}

	public ILayer getLastLayer() {
		return layers.get(layers.size() - 1);
	}

	public void setReccurent(Integer layerRecurrentId) {
		this.recurrentLayerId = layerRecurrentId;
	}

	public Integer getRecurrentLayerId() {
		return recurrentLayerId;
	}

	public boolean isRecurrent() {
		return recurrentLayerId != null;
	}

	public Integer getTimeSeriesOffset() {
		return timeSeriesOffset;
	}

	public void setTimeSeriesOffset(Integer timeSeriesOffset) {
		this.timeSeriesOffset = timeSeriesOffset;
	}

	@Override
	public void setRecurrentNodesLinked(Boolean lateralLinkRecurrentNodes) {
		this.recurrentNodesLinked = lateralLinkRecurrentNodes;
	}

	@Override
	public Boolean isRecurrentNodesLinked() {
		return recurrentNodesLinked;
	}
	
	@Override
	public double getAbsoluteError() {
		return absoluteError;
	}

	@Override
	public void setAbsoluteError(double absoluteError) {
		this.absoluteError = absoluteError;
	}

	@Override
	public INetwork deepCopy(int generationCount) {
		String name = "";
		if(getName().startsWith("G")){
			name = "G" + generationCount + getName().substring(getName().indexOf(Genetic.GENE_SEPARATOR)) ;
		}else{
			name = "G" + generationCount + Genetic.GENE_SEPARATOR + getName();
		}
		Network copy_network = Network.getInstance();
		copy_network.setName(name);
		List<ILayer> copy_layers = new ArrayList<ILayer>(layers);
		Collections.copy(copy_layers, layers);
		
		OutputDataList copy_outputDataList = new OutputDataList();
		copy_network.setLayers(copy_layers);
		copy_network.setOutputDataList(copy_outputDataList);
		copy_network.setRecurrentNodesLinked(new Boolean(recurrentNodesLinked));
		copy_network.setTimeSeriesOffset(new Integer(timeSeriesOffset));
		
		int idx = 0;
		for(ILayer layer : layers){
			layer.setNetwork(copy_network);
			copy_layers.set(idx++, layer.deepCopy());
		}
		
		return copy_network;
	}
	
	public String geneticCodec() {

		String geneticCode = "";
		
		geneticCode += "I(" + this.getFirstLayer().getNodeCountMinusRecurrentOnes() + ")";
		geneticCode += Genetic.CODE_SEPARATOR;

		if (this.getLayer(1).getNodeCount() > 0)
			geneticCode += "H0(" + this.getLayer(1).getNodeCount() + ")";
		geneticCode += Genetic.CODE_SEPARATOR;
		if (this.getLayers().size() - 2 > 1)
			geneticCode += "H1(" + this.getLayer(2).getNodeCount() + ")";
		geneticCode += Genetic.CODE_SEPARATOR;
		if (this.getLayers().size() - 2 > 2)
			geneticCode += "H1(" + this.getLayer(3).getNodeCount() + ")";
		geneticCode += Genetic.CODE_SEPARATOR;		
		geneticCode += "O(" + this.getLastLayer().getNodeCount() + ")";
		geneticCode += Genetic.CODE_SEPARATOR;
		if (this.getLastLayer().isLayerReccurent())
			geneticCode += "Ro" ;
		geneticCode += Genetic.CODE_SEPARATOR;
		if (this.getLayer(1).isLayerReccurent())
			geneticCode +=  "Rh1" ;
		geneticCode += Genetic.CODE_SEPARATOR;
		if (this.getLayers().size() - 2 > 1 && this.getLayer(2).isLayerReccurent())
			geneticCode += "Rh2" ;
		geneticCode += Genetic.CODE_SEPARATOR;
		if (this.getLayers().size() - 2 > 2 && this.getLayer(3).isLayerReccurent())
			geneticCode +=  "Rh3" ;
		geneticCode += Genetic.CODE_SEPARATOR;
		if (this.isRecurrentNodesLinked())
			geneticCode += "-R-" ;
		geneticCode += Genetic.CODE_SEPARATOR;
		if (this.getLayer(1).getFunction() != null)
			geneticCode +=  "Xh0" + this.getLayer(1).getFunction().name().charAt(0);
		geneticCode += Genetic.CODE_SEPARATOR;
		if (this.getLayers().size() - 2 > 1)
			geneticCode += "Xh1" + this.getLayer(2).getFunction().name().charAt(0);
		geneticCode += Genetic.CODE_SEPARATOR;
		if (this.getLayers().size() - 2 > 2)
			geneticCode += "Xh2" + this.getLayer(3).getFunction().name().charAt(0);
		geneticCode += Genetic.CODE_SEPARATOR;
		
		geneticCode +=  "Xo" + this.getLastLayer().getFunction().name().charAt(0);
		geneticCode += Genetic.GENE_SEPARATOR;
		
		return geneticCode;
	}

	public OutputDataList getOutputDataList() {
		return outputDataList;
	}

	public void setOutputDataList(OutputDataList outputDataList) {
		this.outputDataList = outputDataList;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public void setRecurrentLayerId(Integer recurrentLayerId) {
		this.recurrentLayerId = recurrentLayerId;
	}
	
	public void appendName(String appended){
		this.name += appended;
	}

	public ENetworkImplementation getImpl() {
		return impl;
	}

	public void setImpl(ENetworkImplementation impl) {
		this.impl = impl;
	}






}
package RN;

import java.util.ArrayList;
import java.util.List;

import RN.algoactivations.EActivation;
import RN.dataset.inputsamples.ESamples;
import RN.linkage.ELinkage;
import RN.linkage.ELinkageBetweenAreas;
import RN.nodes.ENodeType;
import RN.nodes.INode;
import RN.utils.ReflexionUtils;

/**
 * @author Eric Marchand
 * 
 */
public class NetworkContext {
	
	private static NetworkContext context = null;
	
	private long clock = -1L;
	
	public static long INCREMENTUM = 1L;
	
	private String networkType;
	
	private String[] kinds;

	private Integer[] layers;

	private Integer[] areas;
	
	private String[] areasType;
	
	private EBoolean[] areasImage;

	private Integer[] nodes;
	
	private Double[] nodeBiasWeights;

	private String[] nodeTypes;

	private EActivation[] nodeActivations;

	private Boolean[] nodeRecurrents;

	private Integer[] linkSourceTarget;

	private List<Integer[]> links;

	private ESamples[] filters;
	
	private String[] labels;
	
	private Integer[] samplings;
	
	private Integer[] scalings;

	private ELinkage[] linkages;
	
	private ELinkageBetweenAreas[] linkageBetweenAreas;
	
	private Integer[][] linkageTargetedAreas;
	
	private Double[][] linkageOptParams;

	private EBoolean[] linkageWeightModifiables;
	

	public void setClock(long clock) {
		this.clock = clock;
	}

	public NetworkContext() {
	}

	public ESamples getFilter(int columnIndex) {
		return filters[columnIndex];
	}

	public String getKind(int columnIndex) {
		return kinds[columnIndex];
	}
	
	public void addNetworkType(String value) {
		this.networkType = value;
	}

	public void addKind(String value, int idx) {
		this.kinds[idx] = value;
	}

	public void addLayer(Integer value, int idx) {
		this.layers[idx] = value;
	}

	public void addLabel(String value, int idx) {
		this.labels[idx] = value;
	}
	
	public void addSample(Integer value, int idx) {
		this.samplings[idx] = value;
	}
	
	public void addScale(Integer value, int idx) {
		this.scalings[idx] = value;
	}
	
	public void addArea(Integer value, int idx) {
		this.areas[idx] = value;
	}
	
	public void addAreaType(String value, int idx) {
		this.areasType[idx] = value;
	}
	
	public void addAreaImage(EBoolean value, int idx) {
		this.areasImage[idx] = value;
	}
	

	public void addNode(Integer value, int idx) {
		this.nodes[idx] = value;
	}

	public void addNodeType(String value, int idx) {
		this.nodeTypes[idx] = value;
	}
	
	public void addNodeBiasWeight(Double value, int idx){
		this.nodeBiasWeights[idx] = value;
	}

	public void addNodeActivation(String value, int idx) {
		this.nodeActivations[idx] = EActivation.valueOf(value);
	}
	
	public void addLinkage(String value, int idx) {
		this.linkages[idx] = ELinkage.valueOf(value);
	}
	
	public void addLinkageBetweenAreas(String value, int idx) {
		this.linkageBetweenAreas[idx] = ELinkageBetweenAreas.valueOf(value);
	}
	
	public void addLinkageTargetedArea(Integer[] value, int idx) {
		this.linkageTargetedAreas[idx] = value;
	}
	
	
	public void addLinkageOptParams(Double[] value, int idx) {
		this.linkageOptParams[idx] = value;
	}
	
	public void addLinkageWeightModifiable(EBoolean value, int idx) {
		this.linkageWeightModifiables[idx] = value;
	}

	public void addNodeRecurrent(Boolean value, int idx) {
		this.nodeRecurrents[idx] = value;
	}

	public void addLink(int sourceValue, int targetValue) {
		linkSourceTarget = new Integer[2];
		linkSourceTarget[0] = sourceValue;
		linkSourceTarget[1] = targetValue;
		this.links.add(linkSourceTarget);
	}

	public void addFilter(String value, int idx) {
		this.filters[idx] = ESamples.valueOf(value);
	}

	public void initLinks(int size) {
		links = new ArrayList<Integer[]>(size);
	}

	public void initLayers(int size) {
		layers = new Integer[size];
	}

	public void initAreas(int size) {
		areas = new Integer[size];
	}
	
	public void initAreasType(int size) {
		areasType = new String[size];
	}
	
	public void initAreasImage(int size) {
		areasImage = new EBoolean[size];
	}
	
	public void initNodes(int size) {
		nodes = new Integer[size];
	}

	public void initNodeTypes(int size) {
		nodeTypes = new String[size];
	}
	
	public void initNodeBiasWeight(int size){
		nodeBiasWeights = new Double[size];
	}

	public void initNodeActivations(int size) {
		nodeActivations = new EActivation[size];
	}

	public void initNodeRecurrents(int size) {
		nodeRecurrents = new Boolean[size];
	}

	public void initKinds(int size) {
		kinds = new String[size];
	}

	public void initFilters(int size) {
		filters = new ESamples[size];
	}

	public String[] getKinds() {
		return kinds;
	}

	public void setKinds(String[] kinds) {
		this.kinds = kinds;
	}

	public Integer[] getLayers() {
		return layers;
	}

	public void setLayers(Integer[] layers) {
		this.layers = layers;
	}

	public Integer[] getAreas() {
		return areas;
	}

	public void setAreas(Integer[] areas) {
		this.areas = areas;
	}

	public Integer[] getNodes() {
		return nodes;
	}

	public void setNodes(Integer[] nodes) {
		this.nodes = nodes;
	}

	public String[] getNodeTypes() {
		return nodeTypes;
	}

	public void setNodeTypes(String[] nodeTypes) {
		this.nodeTypes = nodeTypes;
	}

	public EActivation[] getNodeActivations() {
		return nodeActivations;
	}

	public void setNodeActivations(EActivation[] nodeActivations) {
		this.nodeActivations = nodeActivations;
	}

	public Boolean[] getNodeRecurrents() {
		return nodeRecurrents;
	}

	public void setNodeRecurrents(Boolean[] nodeRecurrents) {
		this.nodeRecurrents = nodeRecurrents;
	}

	public Integer[] getLinkSourceTarget() {
		return linkSourceTarget;
	}

	public void setLinkSourceTarget(Integer[] linkSourceTarget) {
		this.linkSourceTarget = linkSourceTarget;
	}

	public List<Integer[]> getLinks() {
		return links;
	}

	public void setLinks(List<Integer[]> links) {
		this.links = links;
	}

	public ESamples[] getFilters() {
		return filters;
	}

	public void setFilters(ESamples[] filters) {
		this.filters = filters;
	}

	public int getColumnCountByLayer(Integer layerIdCounted) {
		int count = 0;
		for (int idx = 0; idx < layers.length; idx++) {
			Integer layerId = layers[idx];
			if(layerIdCounted.equals(layerId))
				count++;
		}

		return count;
	}
	
	public int getColumnCountByLayerAndArea(Integer layerIdCounted, Integer idxArea) {
		int count = 0;
		Integer layerId = null;
		Integer areaId = null; 
		for (int idx = 0; idx < layers.length; idx++) {
			layerId = layers[idx];
			areaId = areas[idx];
			if(layerIdCounted.equals(layerId) && idxArea.equals(areaId))
				count++;
		}

		return count;
	}
	
	
	public int getNodeSumByLayerAreaAndKind(Integer layerIdCounted, Integer areaIdCounted, String kindCounted) {
		int sum = 0;
		for (int idx = 0; idx < kinds.length; idx++) {
			if(kinds[idx] == null)
				break;
			Integer layerId = layers[idx];
			Integer areaId = areas[idx];
			String kind = kinds[idx];
			int nodeCount = nodes[idx];
			if (layerIdCounted != null && areaIdCounted != null && kindCounted.equals(kind) && layerIdCounted.equals(layerId) && areaIdCounted.equals(areaId)) {
				sum += nodeCount;
			}
		}

		return sum;
	}
	
	public int getNodeSumByLayerAndKind(Integer layerIdCounted, String kindCounted) {
		int sum = 0;
		for (int idx = 0; idx < kinds.length; idx++) {
			if(kinds[idx] == null)
				break;
			int layerId = layers[idx];
			String kind = kinds[idx];
			int nodeCount = nodes[idx];
			if (layerIdCounted != null && kindCounted.equals(kind) && layerIdCounted.equals(layerId)) {
				sum += nodeCount;
			}
		}

		return sum;
	}
	
	public int getNodeSumByKind(String kindCounted) {
		int sum = 0;
		for (int idx = 0; idx < kinds.length; idx++) {
			if(kinds[idx] == null)
				break;
			String kind = kinds[idx];
			int nodeCount = nodes[idx];
			if (kindCounted.equals(kind)) {
				sum += nodeCount;
			}
		}

		return sum;
	}
	
	public int getLayerCount(){
		int max = 0;
		for(Integer layerId : layers)
			if(layerId != null && layerId > max)
				max = layerId;
		
		return max + 1;
	}
	
	public int getAreaCount(int layerId){
		
		int max = 0;
		int idx = 0;
		for(Integer areaId : areas){
			
			if(layers.length <= idx && layers[idx] == layerId && areaId != null && areaId > max)
				max = areaId;
			
			idx++;
		}
		
		return max + 1;
	}
	
	
	public INetwork newNetwork(String networkName) {
		
		INetwork network = null;
		if(ENetworkImplementation.UNLINKED.name().equalsIgnoreCase(networkType)){
			network = Network.newInstance(ENetworkImplementation.UNLINKED);
		}else{
			network = Network.newInstance(ENetworkImplementation.LINKED);
		}
		
		network.setName(networkName);

		// Neuralware (2001) approach
//		optimizedNumHiddens = getTrainingVectorNumber() / (5 * (getInputSize() + getOutputSize()));
//		optimizedNumHiddens = Math.max(5, optimizedNumHiddens);
		Layer layer = null;
		IArea area = null;
		int nodeNb = 0;
		int colOffset = 0;
		EAreaType areaType = null;
		EBoolean areaImage = null;
		Class[] areaParamClasses = null;
		Object[] areaParamValues = null;
		int idxCol = 0;
		List<INode> nodeList = null;

		for(int idx = 0; idx < getLayerCount(); idx++){
			
			layer = new Layer(EActivation.IDENTITY);
			network.addLayer(layer);
			
			for(int idxArea = 0; idxArea < getAreaCount(idx); idxArea++){
				
				idxCol = colOffset + idxArea;
				
				nodeNb = getNodeSumByLayerAreaAndKind(idx, idxArea, kinds[idxCol]);
				
				areaType = EAreaType.valueOf(areasType[idxCol].trim());
				areaImage = areasImage[idxCol];
				areaParamClasses = new Class[1];
				areaParamValues = new Object[1];
				if(areaImage != null){
					areaParamClasses = new Class[2];
					areaParamValues = new Object[2];
					areaParamClasses[1] = boolean.class;
					areaParamValues[1] = areaImage.getValue();
				}
				areaParamClasses[0] = int.class;
				areaParamValues[0] = nodeNb;
				area = ReflexionUtils.newClass(areaType.getClassPath(), areaParamClasses, areaParamValues);
				
				layer.addArea(area);
				
				area.configureLinkage(linkages[idxCol], linkageBetweenAreas[idxCol], linkageTargetedAreas[idxCol], null, (samplings[idxCol] == null ? 1 : samplings[idxCol]), linkageWeightModifiables[idxCol].getValue(), linkageOptParams[idxCol]);
				
				for(int idxByArea = 0; idxByArea < getColumnCountByLayerAndArea(idx, idxArea); idxByArea++){
					
					area.configureNode(nodeBiasWeights[idxCol] != null, nodeActivations[idxCol], ENodeType.valueOf(nodeTypes[idxCol]));
					
					nodeList = area.createNodes(nodes[idxCol]);
					
					if(areaType == EAreaType.SQUARE && scalings[idxCol] != null){
						((IAreaSquare) area).getImageArea().scaleImage(scalings[idxCol]);
					}
					
					ENodeType nodeType = ENodeType.valueOf(nodeTypes[idxCol].trim());
					Boolean nodeRecurrent = nodeRecurrents[idxCol] == null ? Boolean.FALSE : Boolean.TRUE;
					layer.setDropOut(false);
					// TODO a changer par node.setReccurent()
					layer.setReccurent(nodeRecurrent);
					
					for(INode node : nodeList){
						
						node.setActivationFxPerNode(true);
						node.setNodeType(nodeType);
						
						if(nodeBiasWeights[idxCol] != null){
							if(ENetworkImplementation.UNLINKED.name().equalsIgnoreCase(networkType))
								node.setBiasWeightValue(nodeBiasWeights[idxCol]);
							else
								node.getBiasInput().setWeight(nodeBiasWeights[idxCol]);
						}
						

					}
					idxCol++;
				}
				
			}
			
			colOffset += getColumnCountByLayer(idx);
			
			
		}
		
		network.setTimeSeriesOffset(1);
		network.setRecurrentNodesLinked(false);
//		network.setName(network.getName() + network.geneticCodec());
		network.setName(network.getName() + " network: " + network.getLayers().size() + " layers");
		
		return network;
	}

	public void initData(int size) {
		DataSeries.getInstance().clearSeries();
	}
	
	public long incrementClock(){
		return clock = clock + INCREMENTUM;
	}

	public long getClock() {
		return clock;
	}

	public String[] getLabels() {
		return labels;
	}
	
	public String getLabel(int idx){
		return labels[idx];
	}

	public void setLabels(String[] labels) {
		this.labels = labels;
	}

	public void initLabels(int size) {
		this.labels = new String[size];
	}
	
	public void initSampling(int size) {
		this.samplings = new Integer[size];
	}
	
	public void initScale(int size) {
		this.scalings = new Integer[size];
	}
	
	public void initLinkages(int size) {
		this.linkages = new ELinkage[size];
	}
	
	public void initLinkageBetweenAreas(int size) {
		this.linkageBetweenAreas = new ELinkageBetweenAreas[size];
	}
	
	public void initLinkageTargetedArea(int size) {
		this.linkageTargetedAreas = new Integer[size][];
	}
	
	
	public void initLinkageOptParams(int size) {
		this.linkageOptParams = new Double[size][];
	}
	
	
	public void initLinkageWeightModifiables(int size) {
		this.linkageWeightModifiables = new EBoolean[size];
	}
	
	public static NetworkContext getContext() {
		
		if(context == null){
			context = new NetworkContext();
		}
		
		return context;
	}

	public static void setContext(NetworkContext context) {
		NetworkContext.context = context;
	}

	public Integer[] getSamplings() {
		return samplings;
	}
	
	public Integer getSamplings(int idx) {
		
		if(samplings == null || samplings[idx] == null)
			return 1;
		
		return samplings[idx];
	}

	public void setSamplings(Integer[] samplings) {
		this.samplings = samplings;
	}

	public Double[] getNodeBiasWeights() {
		return nodeBiasWeights;
	}

	public void setNodeBiasWeights(Double[] nodeBiasWeights) {
		this.nodeBiasWeights = nodeBiasWeights;
	}

	public String getNetworkType() {
		return networkType;
	}

	public void setNetworkType(String networkType) {
		this.networkType = networkType;
	}

	public ELinkageBetweenAreas[] getNodeLinkageBetweenAreas() {
		return linkageBetweenAreas;
	}

	public void setNodeLinkageBetweenAreas(ELinkageBetweenAreas[] nodeLinkageBetweenAreas) {
		this.linkageBetweenAreas = nodeLinkageBetweenAreas;
	}

	public Integer[][] getNodeLinkageTargetedAreas() {
		return linkageTargetedAreas;
	}

	public void setNodeLinkageTargetedAreas(Integer[][] nodeLinkageTargetedAreas) {
		this.linkageTargetedAreas = nodeLinkageTargetedAreas;
	}


	
}
package RN;

import java.io.Serializable;

/**
 * @author Eric Marchand
 * 
 */
public class NetworkElement implements Serializable{

	protected static NetworkContext context = NetworkContext.getContext();
	
	protected static Network network = null;
	

	public static NetworkContext getContext() {
		return context;
	}


	public static void initContext() {
		context = new NetworkContext();
		NetworkContext.setContext(context);
	}


}
package RN;
import java.util.List;
import java.util.ListIterator;

import RN.dataset.InputData;
import RN.dataset.OutputData;
import RN.nodes.INode;


/**
 * @author Eric Marchand
 * 
 */
public class NetworkLSTM implements INetwork{


	@Override
	public ILayer getFirstLayer() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public ILayer getLastLayer() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void show() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public ILayer getLayer(int i) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<ILayer> getLayers() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public OutputData propagation(boolean trainingActive) throws Exception {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public List<INode> getAllNodes() {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public void addLayer(ILayer layer) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void finalizeConnections() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void init(double d, double e) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public String getString() {
		// TODO Auto-generated method stub
		return null;
	}


	@Override
	public OutputData compute(ListIterator<InputData> itr) throws Exception {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setTimeSeriesOffset(Integer timeSeriesOffset) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Integer getTimeSeriesOffset() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setRecurrentNodesLinked(Boolean lateralLinkRecurrentNodes) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Boolean isRecurrentNodesLinked() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setAbsoluteError(double absoluteError) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public double getAbsoluteError() {
		// TODO Auto-generated method stub
		return 0;
	}


	@Override
	public void disconnectAll() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public String getName() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setName(String name) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void appendName(String name) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public INetwork deepCopy(int generationCount) {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public String geneticCodec() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void newLearningCycle(int cycleCount) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void initBiasWeights(double value) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public ENetworkImplementation getImpl() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public INode getNode(Identification id) {
		// TODO Auto-generated method stub
		return null;
	}

}
package RN;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.Set;

import org.apache.log4j.Logger;

/**
 * @author Eric Marchand
 * 
 */
public class NetworkService {

	private static Logger logger = Logger.getLogger(NetworkService.class);

    public static void saveNetwork(Object reseauNeurone, String filename) throws Exception {
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filename))) {
            oos.writeObject(reseauNeurone);
        } catch (FileNotFoundException e) {
            throw new Exception("File not found", e);
        } catch (IOException e) {
            throw new Exception("Error initializing stream", e);
        }
    }


	
    public static Network loadNetwork(String filename) throws Exception {
        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filename))) {
            return (Network) ois.readObject();
        } catch (FileNotFoundException e) {
            throw new Exception("File not found", e);
        } catch (IOException e) {
            throw new Exception("Error initializing stream", e);
        } catch (ClassNotFoundException e) {
            throw new Exception("Class not found", e);
        }
    }
    
    public static String printObjectDetails(Object object, int level, Set<Integer> seenObjects) throws IllegalAccessException {
        StringBuilder sb = new StringBuilder();
        
        if (object == null) {
            return "null";
        }
        
        int objectId = System.identityHashCode(object);
        if (seenObjects.contains(objectId)) {
            return "\"obj[" + objectId + "]\"";
        }

        Class<?> objClass = object.getClass();
        seenObjects.add(objectId);
        String indent = repeat(" ", level * 2);

        if (objClass.isArray()) {
            sb.append("[\n");
            int length = Array.getLength(object);
            for (int i = 0; i < length; i++) {
                sb.append(indent).append(printObjectDetails(Array.get(object, i), level + 1, seenObjects));
                if (i < length - 1) sb.append(",\n");
            }
            sb.append("\n").append(indent).append("]");
        } else if (objClass.isPrimitive() || isWrapperType(objClass)) {
            sb.append(object.toString());
        } else if (objClass.equals(String.class)) {
            sb.append("\"").append(object).append("\"");
        } else {
            boolean isFirstField = true;
            sb.append("{\n");
            Field[] fields = objClass.getDeclaredFields();
            for (Field field : fields) {
                if (!Modifier.isStatic(field.getModifiers()) && !field.isSynthetic() && !estUnAttributFonctionnel(field) && estVisible(objClass, field)) {
                    if (!isFirstField) {
                        sb.append(",\n");
                    } else {
                        isFirstField = false;
                    }
                    field.setAccessible(true);
                    sb.append(indent).append("  \"").append(field.getName()).append("\": ")
                      .append(printObjectDetails(field.get(object), level + 1, seenObjects));
                }
            }
            if (!isFirstField) {
                sb.append("\n");
            }
            sb.append(indent).append("}");
        }
        if (level == 0) {
            sb.append("\n"); // Ajouter une nouvelle ligne à la fin pour le niveau racine
        }
        
        return sb.toString();
    }



    private static boolean estVisible(Class<?> objClass, Field field) {
    	
    	
		if("RN.nodes.Node".equals(objClass.getName()) && "area".equals(field.getName()))
			return false;
		
		if("RN.links.Link".equals(objClass.getName()) && ("targetNode".equals(field.getName()) || "sourceNode".equals(field.getName())))
			return false;

			
		
		return true;
	}



	private static boolean estUnAttributFonctionnel(Field field) {
    	
    	if(field.getName().equals("function")) {
    		return true;
    	}
        // Exemple simple : vérifier si le type du champ est une interface fonctionnelle du package java.util.function
        return java.util.function.Function.class.isAssignableFrom(field.getType());
        // Ajoutez d'autres conditions selon les types spécifiques que vous souhaitez ignorer
    }

    private static boolean isWrapperType(Class<?> clazz) {
        return clazz.equals(Boolean.class) || clazz.equals(Integer.class) ||
               clazz.equals(Character.class) || clazz.equals(Byte.class) ||
               clazz.equals(Short.class) || clazz.equals(Double.class) ||
               clazz.equals(Long.class) || clazz.equals(Float.class);
    }
    
    public static String repeat(String str, int count) {
        StringBuilder sb = new StringBuilder();
        
        for (int i = 0; i < count; i++) {
            sb.append(str);
        }
        
        return sb.toString();
    }
	

//	private static void insertNodes(final DBConnection connection, Network network){
//		
//        try {
//
//            if (logger.isDebugEnabled()) {
//                logger.debug("INSERT Node : ");
//            }
//
//            for(Layer layer : network.getLayers()){
//            
//            	for(Area area : layer.getAreas()){
//            		
//            		for(Node node : area.getNodes()){
//            
//            			for(Link link : node.getInputs()){
//            			connection.executeUpdate(DBSqlCommand.PS_NN_INSERT_NODE, 
//            					network.getAdapterId(),
//            					network.getNetworkId(),
//            					layer.getLayerId(), 
//            					area.getAreaId(), 
//            					node.getNodeId(), 
//            					node.getFunction().name(), 
//            					link.getLinkId(), 
//            					link.getWeight());
//            			}
//            			
//            			if(node.getBiasInput() != null){
//                			connection.executeUpdate(DBSqlCommand.PS_NN_INSERT_NODE, 
//                					network.getAdapterId(),
//                					network.getNetworkId(),
//                					layer.getLayerId(), 
//                					area.getAreaId(), 
//                					node.getNodeId(), 
//                					node.getFunction().name(), 
//                					node.getBiasInput().getLinkId(), 
//                					node.getBiasInput().getWeight());
//            			}
//            
//            		}
//            	}
//            
//            }
//
////            recordSource.setId(connection.getGeneratedId());
//            connection.commit();
//            
////            if(connection.getGeneratedId()!=null)
////                recordSource.setId(connection.getGeneratedId());
//
//        } catch (final SQLException e) {
//            connection.rollback();
//            logger.error(e.getMessage());
//        }
//		
//	}

//	public static Network loadNetwork(Long idAdapter, Long idNetwork){
//		DBConnection con = TestNetwork.getNetconnection();
//		return fetchNetwork(idAdapter, idNetwork, con);
//	}

//	private static Network fetchNetwork(Long idAdapter, Long idNetwork, DBConnection con){
//		
//		Network network = TestNetwork.getNetwork(idAdapter, idNetwork);
//		DBResultSet rs = null;
//		
//		try{
//				rs = con.executeQuery(
//		                DBSqlCommand.PS_NN_LST_NODES, 
//		                idAdapter,
//		                idNetwork);
//				
//				Layer layer = null;
//				Area area = null;
//				Node node = null;
//				Link link = null;
//		        while(rs.next()){
//		        
//		        	network.setAdapterId(rs.getInt("id_adapter"));
//		        	network.setSourceId(rs.getInt("id_source"));
//		            layer = network.getLayer(rs.getInt("id_layer"));
//		            area = layer.getArea(rs.getInt("id_area"));
//		            node = area.getNode(rs.getInt("id_node"));
//		            node.setFunction(EActivation.getEnum(rs.getString("activation")));
//		            if(rs.getInt("id_link") == -1){
//		            	link = node.getBiasInput();
//		            	link.setWeight(rs.getDouble("weight"));
//		            }else{
//		            	link = node.getInput(rs.getInt("id_link"));
//		            	link.setWeight(rs.getDouble("weight"));
//		            }
//		        }
//		        
//		        rs.close();
//		        rs = null;
//
//        		
//    } catch (final SQLException sqle) {
//        logger.error(sqle);
//    } finally {
//        if (rs != null) {
//            rs.close();
//            rs = null;
//        }
//    }
//		
//		return network;
//        
//	}
//	

}
package RN;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import RN.algoactivations.EActivation;
import RN.nodes.ENodeType;
import RN.nodes.INode;
import RN.utils.ReflexionUtils;

/**
 * @author Eric Marchand
 * 
 */
public class NodeFactory implements Serializable {
	
	public NodeFactory(){
	}
	
	
	private boolean bias = false;
	
	private EActivation activation = null;
	
	private ENodeType[] types = null;

	
	
	
	public void configureNode(boolean bias, EActivation activation, ENodeType... types) {
		this.bias = bias;
		this.activation = activation;
		this.types = types;
	}
	
	public void configureNode(boolean bias, ENodeType... types){
		this.bias = bias;
		this.types = types;
	}
	
	
	public List<INode> createNodes(IArea area, int nodeCount){
		
		List<INode> nodes = new ArrayList<INode>(nodeCount);
		
		for (int ind = 1; ind <= nodeCount; ind++) {
			
			INode obj = null;
			
			for(ENodeType type : types){
				obj = instantiateNeuron(ind, activation, type, obj);
			}
			
			switch(types[types.length - 1]){
				case LSTM:
					addNode(obj, area, nodes);
				break;
					
				case PIXEL:
				case GANGLIONARY_OFF:
				case GANGLIONARY_ON:
				case BIPOLAR_L:
				case BIPOLAR_S:
					addNode(obj, area, nodes);
					((INode) obj).initParameters(nodeCount);
				break;
					
				case REGULAR:
				case IMAGE :
				case RECURRENT:
				case TIMESERIE:
				case ALL:
				default :
					addNode(obj, area, nodes);
			}

			if(area.getLinkage() == null)
				throw new RuntimeException("You must define linkage on area before creating nodes.");
			
			
			if(bias)
				((INode) obj).createBias();
			
		}
		
		return nodes;
	}
	
	private void addNode(INode node, IArea area, List<INode> nodes){
		
		node.setArea(area);
		node.setNodeId(area.getNodes() != null && !area.getNodes().isEmpty() ? area.getNodes().size() + nodes.size() : nodes.size());
		nodes.add(node);
		node.initGraphics();
	}
	
	

	
	private <T> T instantiateNeuron(int idxNode, EActivation activation, ENodeType type, T obj) {
		
		Class[] constructorParamClasses = new Class[]{};
		Object[] constructorParamObject = new Object[]{};

		
		// on affiche qu'un visualiseur
		if(idxNode > 1 && type.equals(ENodeType.IMAGE) )
			return null;
			
		if(obj == null){
			
			if(activation != null){
				constructorParamClasses = new Class[]{EActivation.class};
				constructorParamObject = new Object[]{activation};
			}
			
			obj = ReflexionUtils.newClass(type.getClassName(), constructorParamClasses, constructorParamObject);
		
		}else{
			
			if(activation != null){
				constructorParamClasses = new Class[]{EActivation.class, INode.class};
				constructorParamObject = new Object[]{activation, obj};
			}else{
				constructorParamClasses = new Class[]{INode.class};
				constructorParamObject = new Object[]{obj};
			}
			
			obj = ReflexionUtils.newClass(type.getClassName(), constructorParamClasses, constructorParamObject);
		}
		return obj;
	}

	

}
package RN.nodes;

/**
 * @author Eric Marchand
 *
 */
public enum ENodeType {

	//GAUSSIAN : used in vision to perform gaussian elliptic mask on a picture
	REGULAR("RN.nodes.Node"), 
	RECURRENT("RN.nodes.RecurrentNode"),
	TIMESERIE("RN.nodes.Node"), 
	ALL("RN.nodes.Node"), 
	LSTM("RN.nodes.LSTMNode"), 
	PIXEL("RN.nodes.PixelNode"),
	IMAGE("RN.nodes.ImageNode"),
	SIGMAPI("RN.nodes.SigmaPiNode"),
	PRODUCT("RN.nodes.ProductNode"),
	
	// Vision morphotypes
	BIPOLAR_L("RN.nodes.vision.BiPolarLNode"),
	BIPOLAR_S("RN.nodes.vision.BiPolarSNode"), 
	GANGLIONARY_OFF("RN.nodes.vision.GanglionaryOFFNode"),
	GANGLIONARY_ON("RN.nodes.vision.GanglionaryONNode");
	
	private String className;
	
	ENodeType(String className){
		this.setClassName(className);
	}

	public String getClassName() {
		return className;
	}

	public void setClassName(String className) {
		this.className = className;
	}

	public static ENodeType[] arrayOf(String[] split) {
		ENodeType[] result = new ENodeType[split.length];
		int idx = 0;
		for(String value : split){
			result[idx++] = ENodeType.valueOf(value);
		}
		return result;
	}
	
}
package RN.nodes;

import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.List;

import RN.algoactivations.EActivation;
import RN.linkage.Filter;
import RN.links.Link;
import RN.links.Weight;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.geometry.Insets;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.canvas.Canvas;
import javafx.scene.canvas.GraphicsContext;
import javafx.scene.control.Button;
import javafx.scene.control.CheckBox;
import javafx.scene.control.Slider;
import javafx.scene.control.Tooltip;
import javafx.scene.image.PixelFormat;
import javafx.scene.image.PixelWriter;
import javafx.scene.layout.HBox;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

/**
 * @author Eric Marchand
 *
 */
public class ImageNode extends PixelNode {
	
	public transient Stage stage = new Stage();
	public transient Scene scene2 = null;
	public transient Canvas canvas;
	public transient GraphicsContext gc;
	public transient PixelWriter pixelWriter;
	public transient PixelFormat<ByteBuffer> pixelFormat = PixelFormat.getByteRgbInstance();

	// Image Data
	private int IMAGE_WIDTH = 100;
	private int IMAGE_HEIGHT = 100;
	public byte imageData[] = null;
	
	private Boolean red = Boolean.TRUE;
	private Boolean green = Boolean.TRUE;
	private Boolean blue = Boolean.TRUE;
	
	private transient CheckBox redCB = null;
	private transient CheckBox greenCB = null;
	private transient CheckBox blueCB = null;
	private transient CheckBox negativeValuesCB = null;
	
	private Boolean negativeValuesActivated = Boolean.FALSE;
	
	private INode node = null;
		
	
	public ImageNode() {
		super();
		this.nodeType = ENodeType.IMAGE;
		imageData = new byte[IMAGE_WIDTH * IMAGE_HEIGHT * 3];
	}

	
	public ImageNode(EActivation activationFx) {
		super(activationFx);
		this.nodeType = ENodeType.IMAGE;
		imageData = new byte[IMAGE_WIDTH * IMAGE_HEIGHT * 3];
	}
	
	public ImageNode(EActivation activationFx, Integer widthPx, Integer heightPx) {
		super(activationFx);
		this.nodeType = ENodeType.IMAGE;
		IMAGE_WIDTH = widthPx;
		IMAGE_HEIGHT = heightPx;
		imageData = new byte[IMAGE_WIDTH * IMAGE_HEIGHT * 3];
	}

	public void initImageData(){
		imageData = new byte[IMAGE_WIDTH * IMAGE_HEIGHT * 3];
	}
	
	public void scaleImage(double multiplier) {

		if (gc == null) {
			initImageScene();
		}

		gc.getCanvas().setScaleX(multiplier);
		gc.getCanvas().setScaleY(multiplier);

		gc.getCanvas().setTranslateX(scene2.getWidth() / 2 - IMAGE_WIDTH / 2);
		gc.getCanvas().setTranslateY(scene2.getHeight() / 2 - IMAGE_HEIGHT / 2);
	}
	
	public void initImageData(int width, int height){
		imageData = new byte[ width * height * 3];
		IMAGE_WIDTH = width;
		IMAGE_HEIGHT = height;
	}

	public void initImageScene(INode node) {
		canvas = new Canvas(IMAGE_WIDTH, IMAGE_HEIGHT);
		gc = canvas.getGraphicsContext2D();
		pixelWriter = gc.getPixelWriter();
		try {
			showDataStage(node);
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public void initImageScene() {
		initImageScene(null);
	}
	
	public void showImage(PixelNode node) {

		this.node = node;
		
		insertData(node);

		drawImageData(node);
	}
	
	@Override
	public void showImage(INode node) {
		
		this.node = node;
		
		insertData(node);

		drawImageData(node);
	}
	
	
	public void insertData(INode node){
		
		
		Integer index = null;
		double filterIntensity = 0D;
		double imagePixelsIntensity = 0D;
		
		double filteredPixelLuminance = 0D;
		
		for (Link link : node.getInputs()) {

			
			filterIntensity = link.getWeight();
			imagePixelsIntensity = link.getValue();

			filteredPixelLuminance = filterIntensity * imagePixelsIntensity;
			
			filteredPixelLuminance *= 255D;
			filterIntensity *= 255D;
			imagePixelsIntensity *= 255D;
			
			index = (link.getSourceNode() != null ? link.getSourceNode().getNodeId() : node.getNodeId());

			if(negativeValuesActivated){
				
				if(red)
					imageData[index * 3 ] += Byte.valueOf((byte) imagePixelsIntensity);
				
				if(green)
					imageData[index * 3 + 1] +=  (byte) (filteredPixelLuminance < 0D ? -filteredPixelLuminance > 255D ? 255D : -filteredPixelLuminance : 0D);
				
				if(blue)
					imageData[index * 3 + 2] += (byte)  (filteredPixelLuminance <= 0D ? 0D : filteredPixelLuminance > 255D ? 255D : filteredPixelLuminance);
				

			}else{
			
				// rouge + vert = jaune
				// bleu + rouge = magenta
				// vert + bleu = cyan
					
				filterIntensity = Math.min(255D, Math.max(0D, filterIntensity));
				imagePixelsIntensity = Math.min(255D, Math.max(0D, imagePixelsIntensity));
				filteredPixelLuminance = Math.min(255D, Math.max(0D, filteredPixelLuminance));
				
				if(red)
					imageData[index * 3] += (byte)  imagePixelsIntensity;
				
				if(green)
					imageData[index * 3 + 1] += (byte) filteredPixelLuminance;
				
				if(blue)
					imageData[index * 3 + 2] += (byte) filterIntensity;
				
				}
			
		}
		
	}
	
	public void insertDataArea(){
		
		
		double imagePixelsIntensity = 0D;
		
		List<INode> nodeList = area.getNodes();
		INode node = null;
		for (int index = 0; index < nodeList.size(); index++) {
			
			node = area.getNode(index);
			
			imagePixelsIntensity = node.getComputedOutput();
			
			imagePixelsIntensity *= 255D;
			
			

			if(negativeValuesActivated){
				
				if(red)
					imageData[index * 3 ] += (byte) imagePixelsIntensity;
				
				if(green)
					imageData[index * 3 + 1] +=  (byte) (imagePixelsIntensity < 0D ? -imagePixelsIntensity > 255D ? 255D : -imagePixelsIntensity : 0D);
				
				if(blue)
					imageData[index * 3 + 2] += (byte)  (imagePixelsIntensity <= 0D ? 0D : imagePixelsIntensity > 255D ? 255D : imagePixelsIntensity);
				

			}else{
			
				// rouge + vert = jaune
				// bleu + rouge = magenta
				// vert + bleu = cyan
					
				imagePixelsIntensity = Math.min(255D, Math.max(0D, imagePixelsIntensity));
				
				if(red)
					imageData[index * 3] += (byte) 0D;
				
				if(green)
					imageData[index * 3 + 1] += (byte) imagePixelsIntensity;
				
				if(blue)
					imageData[index * 3 + 2] += (byte) 0D;
			
			}
			
		}
		
	}
	
	public void insertDataFilter(Filter filter) {

		double imagePixelsIntensity = 0D;

		int index = 0;
		Double value = null;

		for (int idy = 0; idy < filter.getHeight(); idy++) {
			for (int idx = 0; idx < filter.getWidth(); idx++) {

				value = filter.getValue(idx, idy);

				imagePixelsIntensity = value;

				imagePixelsIntensity *= 255D;

				if (negativeValuesActivated) {

					if (red)
						imageData[index * 3] += (byte) imagePixelsIntensity;

					if (green)
						imageData[index * 3 + 1] += (byte) (imagePixelsIntensity < 0D ? -imagePixelsIntensity > 255D ? 255D : -imagePixelsIntensity : 0D);

					if (blue)
						imageData[index * 3 + 2] += (byte) (imagePixelsIntensity <= 0D ? 0D : imagePixelsIntensity > 255D ? 255D : imagePixelsIntensity);

				} else {

					// rouge + vert = jaune
					// bleu + rouge = magenta
					// vert + bleu = cyan
//		              data[i*3]= (byte)(imageData[i]>>16&0xff);
//		              data[i*3+1]= (byte)(imageData[i]>>8&0xff);
//		              data[i*3+2]= (byte)(imageData[i]&0xff);

					imagePixelsIntensity = Math.min(255D, Math.max(0D, imagePixelsIntensity));

					if (red)
						imageData[index * 3] += (byte) 0D;

					if (green)
						imageData[index * 3 + 1] += (byte) imagePixelsIntensity;

					if (blue)
						imageData[index * 3 + 2] += (byte) 0D;

				}
				
				index++;
			}

		}

	}
	
	public void insertDataArray(Weight[][] weights) {

		double imagePixelsIntensity = 0D;

		int index = 0;
		Double value = null;

		for (int idy = 0; idy < weights.length; idy++) {
			for (int idx = 0; idx < weights[0].length; idx++) {

				try{
					value = weights[idx][idy].getWeight();
				}catch(Throwable t){
					value = 0D;
				}

				imagePixelsIntensity = value;

				imagePixelsIntensity *= 255D;

				if (negativeValuesActivated) {

					if (red)
						imageData[index * 3] += (byte) imagePixelsIntensity;

					if (green)
						imageData[index * 3 + 1] += (byte) (imagePixelsIntensity < 0D ? -imagePixelsIntensity > 255D ? 255D : -imagePixelsIntensity : 0D);

					if (blue)
						imageData[index * 3 + 2] += (byte) (imagePixelsIntensity <= 0D ? 0D : imagePixelsIntensity > 255D ? 255D : imagePixelsIntensity);

				} else {

					// rouge + vert = jaune
					// bleu + rouge = magenta
					// vert + bleu = cyan
//		              data[i*3]= (byte)(imageData[i]>>16&0xff);
//		              data[i*3+1]= (byte)(imageData[i]>>8&0xff);
//		              data[i*3+2]= (byte)(imageData[i]&0xff);

					imagePixelsIntensity = Math.min(255D, Math.max(0D, imagePixelsIntensity));

					if (red)
						imageData[index * 3] += (byte) 0D;

					if (green)
						imageData[index * 3 + 1] += (byte) imagePixelsIntensity;

					if (blue)
						imageData[index * 3 + 2] += (byte) 0D;

				}
				
				index++;
			}

		}

	}
	
	public void drawImageData(INode node) {

		if(gc == null){
			initImageScene(node);
		}
		
		pixelWriter.setPixels(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT, pixelFormat, imageData, 0, IMAGE_WIDTH * 3);

		// Add drop shadow effect
		// gc.applyEffect(new DropShadow(20, 20, 20, Color.GRAY));
	}
	
	public void setPixelAt(int x, int y, Color color){
		
		pixelWriter.setColor(x, y, color);
		
	}
	
	private void showDataStage(INode node) throws IOException {

		int sceneH = 500;
		int sceneW = 500;
		
//		stage.setFullScreen(true);
		
		if(node != null)
			stage.setTitle("Neuron :" + ((INode) node).getIdentification() + " - type : " + ((INode) node).getNodeType().name());

		
		Group group = new Group();
		group.setAutoSizeChildren(true);
		scene2 = new Scene(group, sceneH, sceneW, Color.WHITE);
		stage.setScene(scene2);
		group.getChildren().add(canvas);
		
		HBox hboxCanvas = new HBox();
		hboxCanvas.getChildren().add(gc.getCanvas());
		
		VBox vbox = new VBox();
		
		// Common interface
		// Lightning
		
		HBox hbox = new HBox();
		
		Slider intensitySlider = new Slider(-20D, 20D, 0D);
		intensitySlider.setBlockIncrement(0.1);
		intensitySlider.setTooltip(new Tooltip("Light +/-0.1"));
		
		intensitySlider.valueProperty().addListener(new ChangeListener<Number>() {
			public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
				if(!old_val.equals(new_val)){
					
					byte[] newImageData = new byte[imageData.length];
					System.arraycopy(imageData, 0, newImageData, 0, IMAGE_WIDTH * IMAGE_HEIGHT * 3);
					for(int idx = 0; idx < IMAGE_WIDTH * IMAGE_HEIGHT * 3; idx++){
						if(new_val.floatValue() >= 1)	
							newImageData[idx] = (byte)  Math.min(255, newImageData[idx] * new_val.floatValue()) ;
						
						if(new_val.floatValue() < 0)
							newImageData[idx] = (byte)  (newImageData[idx] / new_val.floatValue()) ;
					}
					pixelWriter.setPixels(0, 0, IMAGE_WIDTH, IMAGE_HEIGHT, pixelFormat, newImageData, 0, IMAGE_WIDTH * 3);
					System.out.println("Light : x"+ new_val.floatValue());
				}
			}
		});
		
		Slider scaleSlider = new Slider(1D, 10D, 1D);
		scaleSlider.setBlockIncrement(1);
		scaleSlider.setTooltip(new Tooltip("Scale"));
		
		
		scaleSlider.valueProperty().addListener(new ChangeListener<Number>() {
			public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
				if(!old_val.equals(new_val)){
					scaleImage(new_val.intValue());
				}
			}
		});
		
		hbox.getChildren().addAll(intensitySlider, scaleSlider);
		
		redCB = new CheckBox();
		redCB.setSelected(red);
		greenCB = new CheckBox();
		greenCB.setSelected(green);
		blueCB = new CheckBox();
		blueCB.setSelected(blue);
		
		negativeValuesCB = new CheckBox();
		negativeValuesCB.setSelected(negativeValuesActivated);
		negativeValuesCB.setText("red -> values,  green -> negatives value*weight,  blue ->positives value*weight");
		
		HBox negativeValuesHbox = new HBox(negativeValuesCB);
		negativeValuesHbox.setPadding(new Insets(5D));


		redCB.setText("Inputs value (Red)");
		greenCB.setText("Inputs value*weight (Green)");
		blueCB.setText("Inputs weight (Blue)");
		HBox rvbHbox = new HBox(redCB, greenCB, blueCB);
		rvbHbox.setPadding(new Insets(5D));

		redCB.selectedProperty().addListener(new ChangeListener<Boolean>() {

			@Override
			public void changed(ObservableValue<? extends Boolean> observable, Boolean oldValue, Boolean newValue) {
				red = newValue;
				initImageData();
				insertDataArea();
				drawImageData(null);

			}

		});

		greenCB.selectedProperty().addListener(new ChangeListener<Boolean>() {

			@Override
			public void changed(ObservableValue<? extends Boolean> observable, Boolean oldValue, Boolean newValue) {
				green = newValue;
				initImageData();
				insertDataArea();
				drawImageData(null);

			}

		});

		blueCB.selectedProperty().addListener(new ChangeListener<Boolean>() {

			@Override
			public void changed(ObservableValue<? extends Boolean> observable, Boolean oldValue, Boolean newValue) {
				blue = newValue;
				initImageData();
				insertDataArea();
				drawImageData(null);

			}

		});
		
		negativeValuesCB.selectedProperty().addListener(new ChangeListener<Boolean>() {

			@Override
			public void changed(ObservableValue<? extends Boolean> observable, Boolean oldValue, Boolean newValue) {
				negativeValuesActivated = newValue;
				initImageData();
				insertDataArea();
				drawImageData(null);

			}

		});
		
		
		
		vbox.getChildren().addAll(hbox, rvbHbox, negativeValuesHbox);
		
		
		
		if(this.getArea() != null){
			if(!this.getArea().getNodes().isEmpty())
				this.getArea().getNodes().get(0).addGraphicInterface(vbox);
			
			this.area.getLinkage().addGraphicInterface(vbox);
		}
		
		if (node != null) {
			
			node.addGraphicInterface(vbox);

			Slider nodeSlider = new Slider(0D, node.getArea().getNodeCount() - 1, node.getNodeId());
			nodeSlider.setBlockIncrement(1);
			nodeSlider.valueProperty().addListener(new ChangeListener<Number>() {
				public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
					try {
						INode newNode = node.getArea().getNode(new_val.intValue());
						stage.setTitle(
								"Neuron :" + newNode.getIdentification() + " - type : " + newNode.getNodeType().name());
						insertData(newNode);
						drawImageData(newNode);
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
			});

			Button scanAllNodes = new Button("scan all nodes");
			scanAllNodes.pressedProperty().addListener(new ChangeListener<Boolean>() {

				@Override
				public void changed(ObservableValue<? extends Boolean> observable, Boolean oldValue, Boolean newValue) {
					if(oldValue == false && newValue == true){
						List<INode> nodes = node.getArea().getNodes();
						INode currentnode = null;
						for (int idx = 0; idx < nodes.size(); idx++) {
							currentnode = nodes.get(idx);
							stage.setTitle("Neuron :" + currentnode.getIdentification() + " - type : "
									+ currentnode.getNodeType().name());
							insertData(currentnode);
						}

						drawImageData(currentnode);
					}

				}

			});



			vbox.getChildren().addAll(nodeSlider, scanAllNodes);

		}
		
		vbox.getChildren().addAll(hboxCanvas);
		vbox.setPadding(new Insets(5D));
		
		group.getChildren().addAll(vbox);
        
        stage.sizeToScene();
        
        stage.show();
        
	}

	public byte[] getImageData() {
		return imageData;
	}
	
	public byte getImageData(int idx) {
		return imageData[idx];
	}

	public void setImageData(byte[] imageData) {
		this.imageData = imageData;
	}
	
	public void setImageData(int idx, byte imageData) {
		this.imageData[idx] = imageData;
	}

	public Boolean getNegativeValuesActivated() {
		return negativeValuesActivated;
	}

	public void setNegativeValuesActivated(Boolean negativeValuesActivated) {
		this.negativeValuesActivated = negativeValuesActivated;
	}

	public INode getNode() {
		return node;
	}

	public void setNode(PixelNode node) {
		this.node = node;
	}

	public Stage getStage() {
		return stage;
	}

	public void setStage(Stage stage) {
		this.stage = stage;
	}



}
package RN.nodes;

import java.util.List;

import RN.IArea;
import RN.Identification;
import RN.algoactivations.EActivation;
import RN.dataset.inputsamples.ESamples;
import RN.links.ELinkType;
import RN.links.Link;
import RN.links.Weight;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public interface INode {


	double computeOutput(boolean playAgain) throws Exception;
	
	Link link(INode node, ELinkType type, boolean modifiable, boolean filterActive, ESamples filter );
	
	Link link(INode node, ELinkType type, boolean modifiable);
	
	Link link(INode node, ELinkType type, boolean modifiable, double weight);
	
	Link link(INode node, boolean modifiable, Weight weight);
	
	Link link(INode node, ELinkType type, Weight weight);
	
	Link link(INode node, ELinkType type);
	
	Link incomingLink(ELinkType type);

	String getString();

	ENodeType getNodeType();

	void doubleLink(INode node, ELinkType type);

	void setArea(IArea copy_area);

	Node deepCopy();

	void finalizeConnections();

	void setActivationFx(EActivation nodeActFx);

	void setActivationFxPerNode(boolean b);

	void setNodeType(ENodeType nodeType);

	Double getComputedOutput();
	
	void setComputedOutput(double computedOutput);

	Integer getNodeId();

	double getIdealOutput();

	void setError(double d);

	double getError();

	double getDerivativeValue();

	List<Link> getOutputs();

	void disconnect();

	EActivation getActivationFx();

	void addInput(Link newLink);

	void setDerivatedError(double derivatedError);

	void updateWeights(double learningRate, double alphaDeltaWeight);

	double getDerivatedError();

	void setIdealOutput(double ideal);

	Identification getIdentification();

	IArea getArea();
	
	IArea getNextArea();
	
	IArea getPreviousArea();

	Link getInput(int i);
	
	List<Link> getInputs();

	Link getBiasInput();
	
	void setNodeId(int size);

	void showImage(INode node);
	
	void newLearningCycle(int cycleCount);

	void randomizeWeights(double initWeightRange, double initWeightRange2);

	void setInnerNode(INode node);
	
	void initGraphics();

	void createBias();

	void addGraphicInterface(Pane pane);

	void initParameters(int nodeCount);

	void setEntry(Double inputValue);
	
	Double getEntry();
	
	void setBiasWeight(Weight biasWeight);
	
	Double getBiasWeightValue();

	void setBiasWeightValue(Double biasWeight);
	
	int compareOutputTo(INode comparedNode);
	
	void setDropOutActive(boolean dropOutActive);
	
	Double getDerivatedErrorSum();
	
	Double getInputValue();

	void setInputValue(Double inputValue);
	
	void setBiasPreviousDeltaWeight(Double biasPreviousDeltaWeight);
	
	int hashCode();

	boolean equals(Object obj);
	
	
}package RN.nodes;

import java.util.List;

import RN.IAreaSquare;
import RN.Identification;
import RN.dataset.Coordinate;
import RN.dataset.inputsamples.ESamples;
import RN.linkage.vision.Gradient;
import RN.links.ELinkType;
import RN.links.Link;
import RN.links.Weight;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public interface IPixelNode {
	
	Coordinate getCoordinate();
	
	Integer getNodeId();
	
	IAreaSquare getAreaSquare();
	
	void addGraphicInterface(Pane pane);
	
	List<Link> getInputs();
	
	Double getComputedOutput();
	
	void setComputedOutput(double computedOutput);
	
	void setEntry(Double inputValue);
	
	Double getInputValue();
	
	Link getInput(int i);
	
	Link link(INode node, ELinkType type, boolean modifiable, boolean filterActive, ESamples filter );
	
	Link link(INode node, ELinkType type, boolean modifiable);
	
	Link link(INode node, ELinkType type, boolean modifiable, double weight);
	
	Link link(INode node, boolean modifiable, Weight weight);
	
	Link link(INode node, ELinkType type, Weight weight);
	
	Link link(INode node, ELinkType type);
	
	Double getBiasWeightValue();
	
	Double compareOutputTo(IPixelNode comparedNode);
	
	int compareOutputTo(Double value);
	
	Identification getIdentification();
	
	IAreaSquare getNextAreaSquare();
	
	IAreaSquare getPreviousAreaSquare();
	
	int getX();

	int getY();
	
	double getR();
	
	double getP(double base);
	
	double getTheta();
	
	void setTheta(Double theta);

	void setP(Double p);
	
	void setR(Double r);
	
	IPixelNode getLeft();
	
	IPixelNode getRight();
	
	IPixelNode getUp();
	
	IPixelNode getUpLeft();
	
	IPixelNode getUpRight();
	
	IPixelNode getDown();
	
	IPixelNode getDownLeft();
	
	IPixelNode getDownRight();
	
	Gradient getGradient();
	
	Double distance(IPixelNode n1, IPixelNode n2);
	
	Double distance(IPixelNode n);

}
package RN.nodes;

import RN.ILayer;
import RN.ITester;
import RN.algoactivations.EActivation;
import RN.links.ELinkType;

/**
 * @author Eric Marchand
 *
 */
public class LSTMNode extends Node {

	public ProductNode getInputProductUnit() {
		return inputProductUnit;
	}

	public ProductNode getForgetProductUnit() {
		return forgetProductUnit;
	}

	public Node[] getMemories() {
		return memories;
	}

	private Node input = null;

	private Node inputGate = null;

	private Node forgetGate = null;

	private Node outputGate = null;

	private ProductNode inputProductUnit = null;

	private ProductNode forgetProductUnit = null;

	private Node[] memories = null;

	private ProductNode outputProductUnit = null;

	private boolean isBidirectional = false;

	public LSTMNode(int memoryCellCount) {
		super();
		nodeType = ENodeType.LSTM;

		// SYGMOID ou TANH pour input ???
		input = new Node(EActivation.TANH);
		inputGate = new Node(EActivation.SYGMOID_0_1);
		inputGate.createBias();
		forgetGate = new Node(EActivation.SYGMOID_0_1);
		forgetGate.createBias();
		outputGate = new Node(EActivation.SYGMOID_0_1);
		outputGate.createBias();

		// units have no weight
		inputProductUnit = new ProductNode();
		forgetProductUnit = new ProductNode();
		
		memories = new Node[memoryCellCount];
		for(int v=0; v < memoryCellCount; v++){
			memories[v] = new Node(EActivation.IDENTITY);
		}

		// units have no weight
		outputProductUnit = new ProductNode();

		// connect everythings

		// network input are faned out on these 4 nodes (1 input + 3 gates)
		input.link(inputProductUnit, ELinkType.REGULAR);
		inputGate.link(inputProductUnit, ELinkType.REGULAR);
		forgetGate.link(forgetProductUnit, ELinkType.REGULAR);
		outputGate.link(outputProductUnit, ELinkType.REGULAR);


		// The memory unit computes a linear function of its inputs (.)
		// The output of this unit is not squashed so that it can remember the
		// same value for many time-steps without the value decaying.
		// This value is fed back in so that the block can "remember" it (as
		// long as the forget gate allows).
		// Typically, this value is also fed into the 3 gating units to help
		// them make gating decisions.
		for (Node cellMemory : memories) {
			inputProductUnit.link(cellMemory, ELinkType.REGULAR);
			
			forgetProductUnit.link(cellMemory, ELinkType.REGULAR);
			cellMemory.link(forgetProductUnit, ELinkType.RECURRENT_LINK);

			cellMemory.link(outputProductUnit, ELinkType.REGULAR);
			// Peephole connections
//			if (isBidirectional) {
				cellMemory.link(forgetGate, ELinkType.RECURRENT_LINK);
				cellMemory.link(outputGate, ELinkType.RECURRENT_LINK);
				cellMemory.link(inputGate, ELinkType.RECURRENT_LINK);
//			}
		}

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see RN.Node#finalizeConnections()
	 */
	@Override
	public void finalizeConnections() {

		super.finalizeConnections();

	}

	public void sublayerFanOutLinkage(ILayer sublayer) {
		for (INode sublayerNode : sublayer.getLayerNodes()) {
			// sublayerNode.link(this, ELinkType.REGULAR);
			sublayerNode.link(input, ELinkType.REGULAR);
			sublayerNode.link(inputGate, ELinkType.REGULAR);
			sublayerNode.link(forgetGate, ELinkType.REGULAR);
			sublayerNode.link(outputGate, ELinkType.REGULAR);
		}
	}

	@Override
	public double computeOutput(boolean trainingActive) throws Exception {

		double inputResult = input.computeOutput(trainingActive);
		double inputGateResult = inputGate.computeOutput(trainingActive);
		double forgetGateResult = forgetGate.computeOutput(trainingActive);
		double outputGateResult = outputGate.computeOutput(trainingActive);
   
		double inputProductUnitResult = inputProductUnit.computeOutput(trainingActive);
		double forgetProductUnitResult = forgetProductUnit.computeOutput(trainingActive);
		
		double memoryResult = 0D;
		for (INode cellMemory : memories) {
			memoryResult += cellMemory.computeOutput(trainingActive);
		}

		double outputProductUnitResult = outputProductUnit.computeOutput(trainingActive);

		System.out.println("input " + inputResult + "  inputGate " + inputGateResult + "  forgetGate " + forgetGateResult + "  ouputGate  " + outputGateResult + "  inputProductUnit " + inputProductUnitResult + "  forgetProductUnitResult " + forgetProductUnitResult + "  outputProductUnitResult " + outputProductUnitResult);
		
		return outputProductUnitResult;
	}

	@Override
	public String getString() {

		String networkState = "";

		networkState += "input result : " + input + ITester.NEWLINE;

		networkState += "input inputGate : " + inputGate + ITester.NEWLINE;

		networkState += "input forgetGate : " + forgetGate + ITester.NEWLINE;

		networkState += "input outputGate : " + outputGate + ITester.NEWLINE;

		networkState += "input inputProductUnit : " + inputProductUnit
				+ ITester.NEWLINE;

		networkState += "input forgetProductUnit : " + forgetProductUnit
				+ ITester.NEWLINE;

		for(INode memory : memories){
			networkState += "input memory : " + memory + ITester.NEWLINE;
		}

		networkState += "input outputProductUnit : " + outputProductUnit
				+ ITester.NEWLINE;

		return super.getString();
	}

	public Node getInput() {
		return input;
	}

	public Node getInputGate() {
		return inputGate;
	}

	public Node getForgetGate() {
		return forgetGate;
	}

	public Node getOutputGate() {
		return outputGate;
	}

	public boolean isBidirectional() {
		return isBidirectional;
	}

	public void setBidirectional(boolean isBidirectional) {
		this.isBidirectional = isBidirectional;
	}

	public INode getMemory(int idx) {
		return memories[idx];
	}

	public ProductNode getOutputProductUnit() {
		return outputProductUnit;
	}

}
package RN.nodes;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import RN.ENetworkImplementation;
import RN.Graphics3D;
import RN.IArea;
import RN.ILayer;
import RN.ITester;
import RN.Identification;
import RN.Network;
import RN.NetworkElement;
import RN.TestNetwork;
import RN.algoactivations.EActivation;
import RN.algoactivations.IActivation;
import RN.dataset.inputsamples.ESamples;
import RN.linkage.Linkage;
import RN.links.ELinkType;
import RN.links.Link;
import RN.links.Weight;
import javafx.scene.layout.Pane;

/**
 * @author Eric Marchand
 *
 */
public class Node extends NetworkElement implements INode {

	protected Integer nodeId = null;

	protected ENodeType nodeType;
	
	protected INode innerNode = null;

	protected IArea area;

	protected double computedOutput;

	private double idealOutput;

	protected double error;

	protected List<Link> inputs;

	protected List<Link> outputs;

	protected Link biasInput;

	protected IActivation performer = null;

	private double derivatedError;

	private double aggregatedValue;

	protected boolean dropOutActive;
	
	protected EActivation activationFx;
	
	protected boolean activationFxPerNode = true;
	
	// When we have no link, input value is stored here
	protected Double inputValue;
	
	// When we have no link, bias weight is stored here
	protected Weight biasWeight;
	
	protected Double biasPreviousDeltaWeight = 0D;
	
	
	public Node() {
		this.inputs = new ArrayList<Link>();
		this.outputs = new ArrayList<Link>();
		this.nodeType = ENodeType.REGULAR;
		this.biasWeight = new Weight(0D);
	}
	
	public Node(EActivation activationFx, INode innerNode){
		this();
		this.activationFx = activationFx;
		this.activationFxPerNode = true;
		this.innerNode = innerNode;
	}
	
	public Node(EActivation activationFx) {
		this();
		this.activationFx = activationFx;
		this.activationFxPerNode = true;
	}
	
	
	public Node(INode innerNode) {
		this();
		this.innerNode = innerNode;
	}
	
	public void createBias(){
		if (network == null || network.getImpl() == null || network.getImpl() == ENetworkImplementation.LINKED) {
			this.biasInput = Link.getInstance(ELinkType.REGULAR, true);
			this.biasInput.setTargetNode(this);
			this.biasInput.setUnlinkedValue(1D);
			this.biasInput.setWeightModifiable(true);
			this.biasInput.initGraphics();
		}else{
			this.biasWeight = new Weight(1D);
		}
	}

	public void disconnect(){
		
		for(Link link : inputs){
			if(link.getSourceNode() != null){
				link.getSourceNode().getOutputs().remove(link);
				link.setSourceNode(null);
			}
			link.setTargetNode(null);
			link = null;
		}
		for(Link link : outputs){
			if(link.getTargetNode() != null){
				link.getTargetNode().getInputs().remove(link);
				link.setTargetNode(null);
			}
			link.setSourceNode(null);
			
			link = null;
		}
		
		inputs.clear();
		outputs.clear();
	}

	/**
	 * Link nodes in the entier network
	 */
	public void finalizeConnections() {

		if (network == null || network.getImpl() == null || network.getImpl() == ENetworkImplementation.LINKED) {
			
			ILayer layer = area.getLayer();
			Network network = layer.getNetwork();
			// Pour la couche de ce noeud (a partir de la deuxieme couche : hiddens)
			// on récupére la couche précédente (sens feedforward).
			ILayer underLayer = (layer.getLayerId() > 0 ? network.getLayers().get(layer.getLayerId() - 1) : null);
	
			if (layer.isFirstLayer()) {
	
				if (this.getNodeType() == ENodeType.RECURRENT) {
					INode sourceNode = ((RecurrentNode) this).getSourceNode();
					// weight set to 1.0
					sourceNode.link(this, ELinkType.RECURRENT_LINK, false);
				} else {
					area.getLinkage().sublayerFanOutLinkage(this, underLayer);
				}
	
			} else if (underLayer != null) {
				
				area.getLinkage().sublayerFanOutLinkage(this, underLayer);
	
			}
	
			if (layer.isDropOutLayer()) {
				this.dropOutActive = true;
			}
		
		}

	}
	
	public Link incomingLink(ELinkType type) {
		
		Link link = null;
		
		if(network == null || network.getImpl() == null || network.getImpl() == ENetworkImplementation.LINKED){		
			
			link = Link.getInstance(type, false);
			this.addInput(link);
		
		}
		
		return link;
	}
	
	public Link link(INode node, ELinkType type) {
		
		Link link = null;
		
		if(network == null || network.getImpl() == null || network.getImpl() == ENetworkImplementation.LINKED){		
			
			link = Link.getInstance(type, true);
			
			this.addOutput(link);
			
			if(node != null)
				node.addInput(link);
		
		}
		
		return link;
	}
	
	public Link link(INode node, ELinkType type, Weight weight) {
		
		Link link = null;
		
		if(network == null || network.getImpl() == null || network.getImpl() == ENetworkImplementation.LINKED){		
			
			if(type == ELinkType.SHARED)
				link = Link.getInstance(weight, true);
			else
				link = Link.getInstance(type, true);
			
			this.addOutput(link);
			
			if(node != null)
				node.addInput(link);
		
		}
		
		return link;
	}
	
	public Link link(INode node, ELinkType type, boolean modifiable) {
		
		Link link = null;
		
		if(network == null || network.getImpl() == null || network.getImpl() == ENetworkImplementation.LINKED){		
			
			link = link(node, type);
			link.setWeightModifiable(modifiable);
		
		}
		
		return link;
	}
	
	public Link link(INode node, ELinkType type, boolean modifiable, double weight) {
		
		Link link = null;
		
		if(network == null || network.getImpl() == null || network.getImpl() == ENetworkImplementation.LINKED){			
			link = link( node, type);
			link.setWeightModifiable(modifiable);
			link.setWeight(weight);
		}

		return link;
	}
	
	public Link link(INode node, boolean modifiable, Weight weight) {
		
		Link link = null;
		
		if(network == null || network.getImpl() == null || network.getImpl() == ENetworkImplementation.LINKED){			
			link = link( node, ELinkType.SHARED, weight);
			link.setWeightModifiable(modifiable);
		}

		return link;
	}
	

	public Link link(INode node, ELinkType type, boolean modifiable, boolean filterActive, ESamples filter ) {
		
		Link link = null;
		
		if (network == null || network.getImpl() == null || network.getImpl() == ENetworkImplementation.LINKED) {
			link = link(node, type, modifiable);
			link.setFilterActive(filterActive);
			link.setFilter(filter);
		}
		
		return link;
	}
	
	public void doubleLink(INode node, ELinkType type) {
		this.link(node, type);
		node.link(this, type);
	}
	
	public void randomizeWeights(double min, double max){
		for(Link link : inputs){
			link.initWeight(min, max);
		}
		if(biasInput != null)
			biasInput.initWeight(min, max);
	}

	public void selfLink() {
		link(this, ELinkType.SELF_NODE_LINK);
	}

	/* (non-Javadoc)
	 * @see RN.INode#computeOutput(boolean)
	 */
	@Override
	public double computeOutput(boolean playAgain) throws Exception {

		double sigmaWI = 0;
		double activationFxResult;
		
		EActivation fx = activationFxPerNode ? activationFx : area.getLayer().getFunction();


		// somme des entrees pondérées - biais
		sigmaWI = area.getLinkage().getSigmaPotentials(this);
		

		// permet la généralisation (sampling)
		if (dropOutActive && TestNetwork.getInstance().isDropOutActive())
			sigmaWI *= Math.random() >= 0.5d ? 0.0D : 1.0D;	

		performer = EActivation.getPerformer(fx);

		activationFxResult = performActivationFunction(performer, sigmaWI);

		// on garde le calcul pour l'utiliser lors de la backpropagation (calcul
		// du delta des poids)
		setDerivativeValue(performDerivativeFunction(performer, sigmaWI));

		setComputedOutput(activationFxResult);
		
		if(innerNode != null)
			innerNode.showImage(this);

		return activationFxResult;
	}

	/**
	 * @param performer
	 * @param value
	 * @return
	 * @throws Exception
	 */
	public double performActivationFunction(final IActivation performer, double... values) throws Exception {

		return performer.perform(values);

	}

	/**
	 * @param performer
	 * @param value
	 * @return
	 * @throws Exception
	 */
	public double performDerivativeFunction(final IActivation performer, double... values) throws Exception {

		return performer.performDerivative(values);
	}
	
	public Double getDerivatedErrorSum(){
		
		Double derivatedErrorSum = 0D;
		Identification searchedId = getIdentification();
		
		Map<Identification, Link> outputs = Linkage.getLinksBySourceNode().get(searchedId);
		if(outputs != null){
			for(Entry<Identification, Link> output : outputs.entrySet()){
					derivatedErrorSum += output.getValue().getWeight() * network.getNode(output.getKey()).getDerivatedError();
			}
		}
		
		return derivatedErrorSum;
	}

	public IArea getArea() {
		return  area;
	}
	
	public IArea getNextArea() {
		return area.getLayer().getArea(area.getAreaId() + 1);
	}
	
	public IArea getPreviousArea() {
		return area.getLayer().getArea(area.getAreaId() - 1);
	}

	public void setArea(IArea area) {
		this.area = area;
	}

	public List<Link> getInputs() {
		return inputs;
	}

	public List<Link> getOutputs() {
		return outputs;
	}

	public Link getInput(int index) {
		return inputs.get(index);
	}

	public void setInputs(List<Link> inputs) {
		this.inputs = inputs;
	}

	public Link getBiasInput() {
		return biasInput;
	}

	public void setBiasInput(Link biasInput) {
		this.biasInput = biasInput;
	}

	public void addInput(Link link) {
		link.setInputLinkId(inputs.size());
		link.setTargetNode(this);
		inputs.add(link);
		link.initGraphics();
	}

	public void addOutput(Link link) {
		link.setOutputLinkId(outputs.size());
		link.setSourceNode(this);
		outputs.add(link);
		link.initGraphics();
	}

	public IActivation getPerformer() {
		return performer;
	}

	public void setPerformer(IActivation performer) {
		this.performer = performer;
	}

	/* (non-Javadoc)
	 * @see RN.INode#getString()
	 */
	@Override
	public String getString() {
		int jump = 0;
		String result = "            NODE : " + nodeId + " type : " + this.nodeType + ITester.NEWLINE + "                  INPUTS : "	+ (inputs.isEmpty() ? " _" : "");
		
		if(inputs.size() > 2000){
			jump = 1000;
			result += ITester.NEWLINE + ITester.NEWLINE + "        ----------------> Too much input links to print ("+ inputs.size() + "), we will print the first and last "+jump+"th links..." + ITester.NEWLINE + ITester.NEWLINE;
		}
		
		Link link = null;
		for (int id=0; id< inputs.size(); id++) {
			
			if(jump > 0 && id > jump && id < inputs.size() - jump)
				continue;
			else if(jump > 0 && id == jump)
				result += ITester.NEWLINE + "\n\n\n---------------- Jumping to the last "+jump+"th input links... ----------------\n\n\n";
			
			link = inputs.get(id);
			result += ITester.NEWLINE + "                            " + link.getString();
		}
		
		if(biasInput != null) {
		result += ITester.NEWLINE + "                    BIAS : " + ITester.NEWLINE + "                            "
				+ (biasInput != null ? biasInput.getString() : "aucun");
		} else if(biasWeight != null) {
			result += ITester.NEWLINE + "                    BIAS : " + ITester.NEWLINE + "                            "
					+ (biasWeight != null && biasWeight.getWeight() != 0D ? biasWeight : "aucun");
		}
		
		// result += "\n                  ACTIVATION FX : " + this.function +
		// "\n                  OUTPUT :\n                      " + this.output;
		result += ITester.NEWLINE + "                   ERROR : " + ITester.NEWLINE + "                            " + this.error;
		result += ITester.NEWLINE + "                  OUTPUT : ";
		
		jump = 0;
		if(outputs.size() > 2000){
			jump = 1000;
			result += ITester.NEWLINE + ITester.NEWLINE + "        ----------------> Too much output links to print ("+ outputs.size() + "), we will print the first and last "+jump+"th links..." + ITester.NEWLINE + ITester.NEWLINE;
		}
		
		for (int id=0; id< outputs.size(); id++) {
			
			if(jump > 0 && id > jump && id < outputs.size() - jump)
				continue;
			else if(jump > 0 && id == jump)
				result += ITester.NEWLINE + "\n\n\n---------------- Jumping to the last "+jump+"th output links... ----------------\n\n\n";
			
			link = outputs.get(id);
			result += ITester.NEWLINE + "                            " + link.getString();
		}
		
		result += ITester.NEWLINE;
		return result;
	}

	public Identification getIdentification() {
		Integer layerId = null;
		Integer areaId = null;
		if(area != null){
			areaId = area.getAreaId();
			if(area.getLayer() != null)
				layerId = area.getLayer().getLayerId();
		}
		return new Identification(layerId, areaId, this.getNodeId());
	}

	public String toString() {
		return getIdentification().getIdentification();
	}

	public Integer getNodeId() {
		return nodeId;
	}

	public void setNodeId(int nodeId) {
		this.nodeId = nodeId;
	}


	public void setDerivatedError(double derivatedError) {
		this.derivatedError = derivatedError;
	}

	public double getError() {
		return error;
	}

	public double getIdealOutput() {
		return idealOutput;
	}

	public void setIdealOutput(double idealOutput) {
		this.idealOutput = idealOutput;
	}

	public double getDerivativeValue() {
		return aggregatedValue;
	}

	public void setDerivativeValue(double aggregatedValue) {
		this.aggregatedValue = aggregatedValue;
	}

	public ENodeType getNodeType() {
		return nodeType;
	}

	public void setNodeType(ENodeType nodeType) {
		this.nodeType = nodeType;
	}

	public void setError(double error) {
		this.error = error;
	}

	public void updateWeights(double learningRate, double alphaDeltaWeight) {

		Double deltaWeight = null;
		
		if(network.getImpl() == ENetworkImplementation.LINKED){
			
			for (Link input : getInputs()) {
				
				if (input.isWeightModifiable() && (input.getType() == ELinkType.REGULAR || input.getType() == ELinkType.SHARED) ) {
						deltaWeight = getDeltaWeight(false, input.getValue(), input.getPreviousDeltaWeight(), learningRate, alphaDeltaWeight);
						input.setPreviousDeltaWeight(deltaWeight);
						input.setWeight(input.getWeight() + deltaWeight);
				}
				
			}
	
			Link bias = getBiasInput();
			deltaWeight = null;
			
			if (bias != null) {
				if (bias.isWeightModifiable()) {
					deltaWeight = getDeltaWeight(true, bias.getValue(), bias.getPreviousDeltaWeight(), learningRate, alphaDeltaWeight);
					bias.setPreviousDeltaWeight(deltaWeight);
					bias.setWeight(bias.getWeight() + deltaWeight);
				}
			}
			
		}else{
			
			if(getArea().getLinkage().isWeightModifiable()){
				
				for(Entry<Identification, Link > entry : Linkage.getInputLinks(this.getIdentification()).entrySet()){
					deltaWeight = getDeltaWeight(false, entry.getValue().getValue(), entry.getValue().getPreviousDeltaWeight(), learningRate, alphaDeltaWeight);
					entry.getValue().setPreviousDeltaWeight(deltaWeight);
					entry.getValue().setWeight(entry.getValue().getWeight() + deltaWeight);
				}
				
				if(biasWeight != null && biasWeight.getWeight() != 0D){
					deltaWeight = getDeltaWeight(true, biasWeight.getWeight(), biasPreviousDeltaWeight, learningRate, alphaDeltaWeight);
					biasPreviousDeltaWeight = deltaWeight;
					biasWeight.add(deltaWeight);
				}
				
			}
			
			
		}

	}
	
	private Double getDeltaWeight(boolean bias, double value, double previousDeltaWeight, double learningRate, double alphaDeltaWeight){
		
			try {
				
				return (learningRate * derivatedError * (bias ? -1 : 1) * value) + (alphaDeltaWeight * previousDeltaWeight);
				
		} catch (Exception e) {
			System.out.println("Back-propagation erreur sur le neurone : " + this);
			throw e;
		}
	}

	public double getDerivatedError() {
		return derivatedError;
	}

	public boolean isDropOutActive() {
		return dropOutActive;
	}

	public void setDropOutActive(boolean dropOutActive) {
		this.dropOutActive = dropOutActive;
	}

	public Node deepCopy() {

		Node copy_node = new Node();
		
		 List<Link> copy_inputs  = new ArrayList<Link>(inputs);
		 List<Link> copy_outputs = new ArrayList<Link>(outputs);
		 Collections.copy(copy_inputs, inputs);
		 Collections.copy(copy_outputs, outputs);
		 
		 copy_node.setComputedOutput(computedOutput);
		 copy_node.setDerivatedError(derivatedError);
		 copy_node.setDropOutActive(dropOutActive);
		 copy_node.setError(error);
		 copy_node.setIdealOutput(idealOutput);
		 copy_node.setInputs(copy_inputs);
		 copy_node.setNodeId(nodeId);
		 copy_node.setNodeType(ENodeType.valueOf(nodeType.name()));
		 copy_node.setPerformer(performer);
		 copy_node.setOutputs(copy_outputs);
		 copy_node.setAggregatedValue(aggregatedValue);
		 copy_node.setActivationFx(activationFx);
		 if(biasInput != null){
			 copy_node.setBiasInput(biasInput.deepCopy());
		 }
		 copy_node.setArea(area);
		 
		 int idx = 0;
		for (Link link : inputs) {
			Link copy_link = link.deepCopy();
			copy_link.setTargetNode(copy_node);
			copy_inputs.set(idx++, copy_link);
			if (link.getSourceNode() != null) {
				link.getSourceNode().getOutputs().add(copy_link);
			}
		}
		 
		 idx = 0;
		for (Link link : outputs) {
			Link copy_link = link.deepCopy();
			copy_link.setSourceNode(copy_node);
			copy_outputs.set(idx++, copy_link);
			if (link.getTargetNode() != null) {
				link.getTargetNode().getInputs().add(copy_link);
			}
		}
		
		if(innerNode != null)
			copy_node.setInnerNode(innerNode.deepCopy());
		 
		 
		 return copy_node;

	}

	public Double getComputedOutput() {
		return computedOutput;
	}

	public void setComputedOutput(double computedOutput) {
		this.computedOutput = computedOutput;
		//Graphics3D.setOutputValueOnNode(this);
	}

	public double getAggregatedValue() {
		return aggregatedValue;
	}

	public void setAggregatedValue(double aggregatedValue) {
		this.aggregatedValue = aggregatedValue;
	}

	public void setOutputs(List<Link> outputs) {
		this.outputs = outputs;
	}

	public EActivation getActivationFx() {
		return activationFx;
	}

	public void setActivationFx(EActivation activationFx) {
		this.activationFx = activationFx;
	}

	public boolean isActivationFxPerNode() {
		return activationFxPerNode;
	}

	public void setActivationFxPerNode(boolean activationFxPerNode) {
		this.activationFxPerNode = activationFxPerNode;
	}

	@Override
	public void showImage(INode node) {
	}


	@Override
	public void newLearningCycle(int cycleCount) {
		// nothing to do
	}

	public INode getInnerNode() {
		return innerNode;
	}

	public void setInnerNode(INode innerNode) {
		this.innerNode = innerNode;
	}
	
	public void initGraphics() {
		if(Graphics3D.graphics3DActive)
			Graphics3D.createNode(this);
	}

	@Override
	public void addGraphicInterface(Pane pane) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public void initParameters(int nodeCount) {
		
	}


	@Override
	public void setEntry(Double inputValue) {
		
		if(network == null || network.getImpl() == ENetworkImplementation.LINKED){
			this.getInputs().get(0).setUnlinkedValue(inputValue);
		}else{
			this.setInputValue(inputValue);
		}
		
	}
	
	@Override
	public Double getEntry() {
		
		if(network == null || network.getImpl() == ENetworkImplementation.LINKED){
			return this.getInputs().get(0).getUnlinkedValue();
		}else{
			return this.getInputValue();
		}
		
	}


	public Double getBiasWeightValue() {
		return biasWeight.getWeight();
	}

	public void setBiasWeightValue(Double biasWeight) {
		this.biasWeight.setWeight(biasWeight);
	}
	
	public void setBiasWeight(Weight biasWeight) {
		this.biasWeight = biasWeight;
	}

	@Override
	public int compareOutputTo(INode comparedNode) {
		
		if(comparedNode == null || this.getComputedOutput() > comparedNode.getComputedOutput())
			return 1;
		else if(this.getComputedOutput() < comparedNode.getComputedOutput())
			return -1;
		
		return 0;
	}

	public Double getBiasPreviousDeltaWeight() {
		return biasPreviousDeltaWeight;
	}

	public void setBiasPreviousDeltaWeight(Double biasPreviousDeltaWeight) {
		this.biasPreviousDeltaWeight = biasPreviousDeltaWeight;
	}

	public Double getInputValue() {
		return inputValue;
	}

	public void setInputValue(Double inputValue) {
		this.inputValue = inputValue;
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((nodeId == null) ? 0 : nodeId.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Node other = (Node) obj;
		if (nodeId == null) {
			if (other.nodeId != null)
				return false;
		} else if (!nodeId.equals(other.nodeId))
			return false;
		return true;
	}



}
package RN.nodes;

import RN.IArea;
import RN.IAreaSquare;
import RN.ITester;
import RN.algoactivations.EActivation;
import RN.dataset.Coordinate;
import RN.linkage.vision.Gradient;
import RN.links.Link;

/**
 * @author Eric Marchand
 *
 */
public class PixelNode extends Node implements IPixelNode, INode{
	
	private Coordinate coordinate = new Coordinate();
	
	private Gradient gradient = null;

	public PixelNode() {
		super(EActivation.IDENTITY);
		this.nodeType = ENodeType.PIXEL;
	}

	public PixelNode(EActivation activationFx) {
		super(activationFx);
		this.nodeType = ENodeType.PIXEL;
	}
	
	public PixelNode(INode innerNode) {
		super(innerNode);
		this.nodeType = ENodeType.PIXEL;
		this.activationFx = EActivation.IDENTITY;
		this.activationFxPerNode = true;
	}
	

	public void initParameters(){
	}
	
	public IArea getArea() {
		return  super.getArea();
	}
	
	
	public int getX() {
		
		if(coordinate.getX() == null){
			coordinate.setX((double) getAreaSquare().getX(this));
			coordinate.setX0((double) getAreaSquare().getNodeCenterX());
		}
		
		if(coordinate.getY() == null){
			coordinate.setY((double) getAreaSquare().getY(this));
			coordinate.setY0((double) getAreaSquare().getNodeCenterY());
		}
		
		return coordinate.getX().intValue();
	}


	public int getY() {
		
		if(coordinate.getX() == null){
			coordinate.setX((double) getAreaSquare().getX(this));
			coordinate.setX0((double) getAreaSquare().getNodeCenterX());
		}
		
		if(coordinate.getY() == null){
			coordinate.setY((double) getAreaSquare().getY(this));
			coordinate.setY0((double) getAreaSquare().getNodeCenterY());
		}
		
		return coordinate.getY().intValue();
	}
	
	public double getR() {
		
		if(coordinate.getR() == null){
			if(coordinate.getX() == null || coordinate.getY() == null){
				getX();
				getY();
			}
			coordinate.linearToPolarSystem();
		}
		
		return coordinate.getR();
	}
	
	
	public double getP(double base) {
		
		if(coordinate.getP() == null){
			if(coordinate.getX() == null || coordinate.getY() == null){
				getX();
				getY();
			}
			coordinate.setBase(base);
			coordinate.linearToLogPolarSystem();
		}
		
		return coordinate.getP();
	}
	
	
	public double getTheta() {
		
		if(coordinate.getTheta() == null){
			if(coordinate.getX() == null || coordinate.getY() == null){
				getX();
				getY();
			}
				
			coordinate.linearToPolarSystem();
		}
		
		return coordinate.getTheta();
	}
	
	
	public void setTheta(Double theta){
		coordinate.setTheta(theta);
	}

	public void setP(Double p){
		coordinate.setP(p);
	}
	
	public void setR(Double r){
		coordinate.setR(r);
	}

	@Override
	public IPixelNode getLeft() {
		int x = getAreaSquare().getX(this);
		int y = getAreaSquare().getY(this);
		try {
			return getAreaSquare().getNodeXY(x - 1, y);
		} catch (Exception ignore) {
			System.err.println("getLeft(" + (x-1) +"," + y +") not accessible () "); 
		}
		
		return null;
	}
	

	@Override
	public IPixelNode getRight() {
		int x = getAreaSquare().getX(this);
		int y = getAreaSquare().getY(this);
		try {
			return getAreaSquare().getNodeXY(x + 1, y);
		} catch (Exception ignore) {
			System.err.println("getRight(" + (x+1) +"," + y +") not accessible () "); 
		}
		
		return null;
	}

	@Override
	public IPixelNode getUp() {
		int x = getAreaSquare().getX(this);
		int y = getAreaSquare().getY(this);
		try {
			return getAreaSquare().getNodeXY(x, y - 1);
		} catch (Exception ignore) {
			System.err.println("getUp(" + x +"," + (y-1) +") not accessible () "); 
		}
		
		return null;
		
	}
	
	@Override
	public IPixelNode getUpLeft() {
		int x = getAreaSquare().getX(this);
		int y = getAreaSquare().getY(this);
		try {
			return getAreaSquare().getNodeXY(x - 1, y - 1);
		} catch (Exception ignore) {
			System.err.println("getUpLeft(" + (x-1) +"," + (y-1) +") not accessible () "); 
		}
		
		return null;
	}
	
	@Override
	public IPixelNode getUpRight() {
		int x = getAreaSquare().getX(this);
		int y = getAreaSquare().getY(this);
		try {
			return getAreaSquare().getNodeXY(x + 1, y - 1);
		} catch (Exception ignore) {
			System.err.println("getUpRight(" + (x+1) +"," + (y-1) +") not accessible () "); 
		}
		
		return null;
	}

	@Override
	public IPixelNode getDown() {
		int x = getAreaSquare().getX(this);
		int y = getAreaSquare().getY(this);
		try {
			return getAreaSquare().getNodeXY(x, y + 1);
		} catch (Exception ignore) {
			System.err.println("getDown(" + x +"," + (y+1) +") not accessible () "); 
		}
		
		return null;
	}
	
	@Override
	public IPixelNode getDownLeft() {
		int x = getAreaSquare().getX(this);
		int y = getAreaSquare().getY(this);
		try {
			return getAreaSquare().getNodeXY(x - 1, y + 1);
		} catch (Exception ignore) {
			System.err.println("getDownLeft(" + (x-1) +"," + y +") not accessible () "); 
		}
		
		return null;
	}
	
	@Override
	public IPixelNode getDownRight() {
		int x = getAreaSquare().getX(this);
		int y = getAreaSquare().getY(this);
		try {
			return getAreaSquare().getNodeXY(x + 1, y + 1);
		} catch (Exception ignore) {
			System.err.println("getLeft(" + (x-1) +"," + y +") not accessible () "); 
		}
		
		return null;
	}
	


	@Override
	public String getString() {
		String result = "            NODE : " + nodeId + " type : " + this.nodeType;
		result += ITester.NEWLINE + "             x : " + getAreaSquare().getX(this) + "   y :" + getAreaSquare().getY(this) ;
		result += ITester.NEWLINE + "                  INPUTS : " + (inputs.isEmpty() ? " _" : "");
		for (Link link : inputs) {
			result += ITester.NEWLINE + "                            " + link.getString();
		}
		result += ITester.NEWLINE + "                    BIAS : " + ITester.NEWLINE + "                            "
				+ (biasInput != null ? biasInput.getString() : "aucun");
		// result += "\n                  ACTIVATION FX : " + this.function +
		// "\n                  OUTPUT :\n                      " + this.output;
		result += ITester.NEWLINE + "                   ERROR : " + ITester.NEWLINE + "                            " + this.error;
		result += ITester.NEWLINE + "                  OUTPUT : ";
		for (Link link : outputs) {
			result += ITester.NEWLINE + "                            " + link.getString();
		}
		result += ITester.NEWLINE;
		return result;
	}
	
	@Override
	public String toString() {
		return "PixelNode [id=" + nodeId +", layer=" + (area != null ? area.getLayer().getLayerId() : "") + ", area=" + (area != null ? area.getAreaId() : "") + ", x=" + getX() + ", y=" + getY() + ", output=" + computedOutput + "]";
	}

	@Override
	public IAreaSquare getAreaSquare() {
		return (IAreaSquare) area;
	}
	
	@Override
	public Double compareOutputTo(IPixelNode comparedNode) {
		return this.getComputedOutput() - comparedNode.getComputedOutput();
	}
	
	@Override
	public int compareOutputTo(Double value) {
		
		if(value == null || this.getComputedOutput() > value)
			return 1;
		else if(this.getComputedOutput() < value)
			return -1;
		
		return 0;
	}
	
	public IAreaSquare getNextAreaSquare() {
		
		try{
			return (IAreaSquare) area.getLayer().getArea(area.getAreaId() + 1);
		}catch(Throwable ignore){
		}
		
		return null;
	}
	
	public IAreaSquare getPreviousAreaSquare() {
		try{
			return (IAreaSquare) area.getLayer().getArea(area.getAreaId() - 1);
		}catch(Throwable ignore){
		}
		
		return null;
	}
	
	

	
	private Gradient computeGradient() {
		
		try{
			double magnitude = Math.sqrt(
					Math.pow(getLeft().getComputedOutput() - getRight().getComputedOutput() , 2D) +
					Math.pow(getDown().getComputedOutput() - getUp().getComputedOutput() , 2D)
					);
			
			double theta = Math.atan2(
					(getUp().getComputedOutput() - getDown().getComputedOutput()),
					(getLeft().getComputedOutput() - getRight().getComputedOutput())
					);
			
			if(theta < 0D)
				theta += (2D * Math.PI);
			
			
			return new Gradient(this, theta, magnitude, null);
			
			
		}catch(Throwable ignore){
			//ignore.printStackTrace();
		}
		
		return null;
		
	}
	
	public Double distance(IPixelNode n1, IPixelNode n2){
		
		return Math.sqrt(Math.pow(n1.getX() - n2.getX(), 2D) + Math.pow(n1.getY() - n2.getY(), 2D));
		
	}
	
	public Double distance(IPixelNode n){
		return distance(this, n);
	}

	public Gradient getGradient() {
		if(gradient == null){
			this.gradient = computeGradient();
		}
		return gradient;
	}

	public Coordinate getCoordinate() {
		return coordinate;
	}
	
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((nodeId == null) ? 0 : nodeId.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		Node other = (Node) obj;
		if (nodeId == null) {
			if (other.nodeId != null)
				return false;
		} else if (!nodeId.equals(other.nodeId))
			return false;
		return true;
	}





}
package RN.nodes;

import RN.algoactivations.EActivation;
import RN.links.Link;

/**
 *  Compute the product of their inputs . These units have no weights.
 *  
 * @author Eric
 *
 */
public class ProductNode extends Node {

	public ProductNode() {
		super();
		this.nodeType = ENodeType.PRODUCT;
	}
	
	public ProductNode(INode innerNode) {
		super(innerNode);
		this.nodeType = ENodeType.PRODUCT;
	}

	public ProductNode(EActivation activationFx) {
		super(activationFx);
		this.nodeType = ENodeType.PRODUCT;
	}

	@Override
	public double computeOutput(boolean trainingActive) throws Exception {
		double piI = 1D;

		// produit des entrees
		for (Link input : inputs) {
			piI *= input.getValue();
		}
		
		if(innerNode != null)
			innerNode.showImage(this);

		return piI;
	}

}
package RN.nodes;

/**
 * @author Eric Marchand
 *
 */
public class RecurrentNode extends Node {
	
	
	Integer sourceLayerId = null;
	INode sourceNode = null;
	
	
	public RecurrentNode(INode sourceNode) {
		super();
		this.sourceNode = sourceNode;
		this.nodeType = ENodeType.RECURRENT;
	}

	public Integer getSourceLayerId() {
		return sourceLayerId;
	}

	public void setSourceLayerId(Integer sourceLayerId) {
		this.sourceLayerId = sourceLayerId;
	}

	public INode getSourceNode() {
		return sourceNode;
	}

	public void setSourceNode(Node sourceNode) {
		this.sourceNode = sourceNode;
	}
	
	public String toString() {
		return "Recurrent" + super.toString();
	}



}
package RN.nodes;

import RN.algoactivations.EActivation;
import RN.links.Link;

/**
 *  Compute the product of their inputs .
 *  
 * @author Eric
 *
 */
public class SigmaPiNode extends Node {

	public SigmaPiNode() {
		super();
		this.nodeType = ENodeType.SIGMAPI;
	}
	
	public SigmaPiNode(INode innerNode) {
		super(innerNode);
		this.nodeType = ENodeType.SIGMAPI;
	}

	public SigmaPiNode(EActivation activationFx) {
		super(activationFx);
		this.nodeType = ENodeType.SIGMAPI;
	}

	@Override
	public double computeOutput(boolean trainingActive) throws Exception {
		double piI = 1D;

		// produit des entrees
		for (Link input : inputs) {
			piI *= input.getValue() * input.getWeight();
		}

		return piI;
	}

}
package RN.nodes.vision;

import RN.algoactivations.EActivation;
import RN.nodes.ENodeType;
import RN.nodes.INode;
import RN.nodes.PixelNode;
import javafx.scene.layout.Pane;

public class BiPolarLNode extends PixelNode {
	
	
	public BiPolarLNode(INode innerNode) {
		super(innerNode);
		this.nodeType = ENodeType.BIPOLAR_L;
		//this.activationFx = EActivation.SYGMOID_0_1_INVERSE;
		this.activationFxPerNode = true;
	}

	public BiPolarLNode() {
		super();
		this.nodeType = ENodeType.BIPOLAR_L;
		//this.activationFx = EActivation.SYGMOID_0_1_INVERSE;
		this.activationFxPerNode = true;
	}

	public BiPolarLNode(EActivation activationFx) {
		super(activationFx);
		this.nodeType = ENodeType.BIPOLAR_L;
	}
	

	
	public void initParameters(int pixelCount){
		super.initParameters(pixelCount);
	}



	@Override
	public void newLearningCycle(int cycleCount) {
		// Randomisation des parametres à chaque cycle d'apprentissage

		// if(cycleCount % 100 == 0)
		// initRandomParameters();
	}
	
	@Override
	public void addGraphicInterface(Pane pane) {
		//((SecondDerivatedGaussianLinkage) getLinkage()).addGraphicInterface(pane);
		
	}



}
package RN.nodes.vision;

import RN.algoactivations.EActivation;
import RN.nodes.ENodeType;
import RN.nodes.INode;
import RN.nodes.PixelNode;
import javafx.scene.layout.Pane;

public class BiPolarSNode extends PixelNode {
	
	
	public BiPolarSNode(INode innerNode) {
		super(innerNode);
		this.nodeType = ENodeType.BIPOLAR_S;
		//this.activationFx = EActivation.SYGMOID_0_1;
		this.activationFxPerNode = true;
	}

	public BiPolarSNode() {
		super();
		this.nodeType = ENodeType.BIPOLAR_S;
		//this.activationFx = EActivation.SYGMOID_0_1;
		this.activationFxPerNode = true;
	}

	public BiPolarSNode(EActivation activationFx) {
		super(activationFx);
		this.nodeType = ENodeType.BIPOLAR_S;
	}
	

	
	public void initParameters(int pixelCount){
		super.initParameters(pixelCount);
	}



	@Override
	public void newLearningCycle(int cycleCount) {
		// Randomisation des parametres à chaque cycle d'apprentissage

		// if(cycleCount % 100 == 0)
		// initRandomParameters();
	}

	
	@Override
	public void addGraphicInterface(Pane pane) {
		//((SecondDerivatedGaussianLinkage) getLinkage()).addGraphicInterface(pane);
		
	}



}
package RN.nodes.vision;

import RN.algoactivations.EActivation;
import RN.nodes.ENodeType;
import RN.nodes.INode;
import RN.nodes.PixelNode;
import javafx.scene.layout.Pane;

public class GanglionaryOFFNode extends PixelNode {
	
	public GanglionaryOFFNode(INode innerNode) {
		super(innerNode);
		this.nodeType = ENodeType.GANGLIONARY_OFF;
		//this.activationFx = EActivation.SYGMOID_0_1;
		this.activationFxPerNode = true;
	}

	public GanglionaryOFFNode() {
		super();
		this.nodeType = ENodeType.GANGLIONARY_OFF;
		//this.activationFx = EActivation.SYGMOID_0_1;
		this.activationFxPerNode = true;
	}

	public GanglionaryOFFNode(EActivation activationFx) {
		super(activationFx);
		this.nodeType = ENodeType.GANGLIONARY_OFF;
	}
	

	
	public void initParameters(int pixelCount){
		super.initParameters(pixelCount);
	}



	@Override
	public void newLearningCycle(int cycleCount) {
		// Randomisation des parametres à chaque cycle d'apprentissage

		// if(cycleCount % 100 == 0)
		// initRandomParameters();
	}

	
	@Override
	public void addGraphicInterface(Pane pane) {
		//((SecondDerivatedGaussianLinkage) getLinkage()).addGraphicInterface(pane);
		
	}


}
package RN.nodes.vision;

import RN.algoactivations.EActivation;
import RN.nodes.ENodeType;
import RN.nodes.INode;
import RN.nodes.PixelNode;
import javafx.scene.layout.Pane;

public class GanglionaryONNode extends PixelNode {
	
	public GanglionaryONNode(INode innerNode) {
		super(innerNode);
		this.nodeType = ENodeType.GANGLIONARY_ON;
		//this.activationFx = EActivation.SYGMOID_0_1_INVERSE;
		this.activationFxPerNode = true;
	}

	public GanglionaryONNode() {
		super();
		this.nodeType = ENodeType.GANGLIONARY_ON;
		//this.activationFx = EActivation.SYGMOID_0_1_INVERSE;
		this.activationFxPerNode = true;
	}

	public GanglionaryONNode(EActivation activationFx) {
		super(activationFx);
		this.nodeType = ENodeType.GANGLIONARY_ON;
	}
	

	
	public void initParameters(int pixelCount){
		super.initParameters(pixelCount);
	}



	@Override
	public void newLearningCycle(int cycleCount) {
		// Randomisation des parametres à chaque cycle d'apprentissage

		// if(cycleCount % 100 == 0)
		// initRandomParameters();
	}


	
	@Override
	public void addGraphicInterface(Pane pane) {
		//((SecondDerivatedGaussianLinkage) getLinkage()).addGraphicInterface(pane);
		
	}


}
package RN.strategy;

/**
 * @author Eric Marchand
 *
 */
public abstract class AbstractStrategyDecorator extends Strategy implements IStrategy{

	protected Strategy decoratedStrategy = null;
	
	public abstract void beforeProcess();
	
	
	@Override
	public void apply(){
		
		beforeProcess();
		
		if(decoratedStrategy != null)
			decoratedStrategy.apply();
		
		process();
		
		afterProcess();
		
	}
	
	public abstract void afterProcess();
	
}
package RN.strategy;

/**
 * @author Eric Marchand
 *
 */
public enum EStrategy {

	AUTO_GROWING_HIDDENS;
	
}
package RN.strategy;

import RN.ILayer;
import RN.TestNetwork;
import RN.links.Link;
import RN.nodes.Node;

/**
 * @author Eric Marchand
 *
 */
public class GrowingNetworkStrategy extends AbstractStrategyDecorator implements IStrategy{

	
	public GrowingNetworkStrategy() {
	}

	public GrowingNetworkStrategy(Strategy strategy){
		this.decoratedStrategy = strategy;
	}

	@Override
	public void beforeProcess() {
		
	}
	
	@Override
	public void process() {
		
		ILayer subLayer = network.getFirstLayer();
		ILayer growingLayer = network.getLayer(subLayer.getLayerId() + 1);
		ILayer nextLayer = network.getLayer(growingLayer.getLayerId() + 1);
		
		Node newNode = new Node();
		newNode.createBias();
		growingLayer.getArea(growingLayer.getAreaCount() - 1).addNode(newNode);
		
		if(network.getLayers().size() > 3){
			ILayer secondSubLayer = growingLayer;
			ILayer secondGrowingLayer = network.getLayer(secondSubLayer.getLayerId() + 2);
			ILayer secondNextLayer = network.getLayer(secondGrowingLayer.getLayerId() + 1);
			
			Node secondNewNode = new Node();
			secondNewNode.createBias();
			secondGrowingLayer.getArea(secondGrowingLayer.getAreaCount() - 1).addNode(secondNewNode);
			
			// we link after adding nodes
			crossLinkage(secondNewNode, secondSubLayer, secondGrowingLayer, secondNextLayer);
		}
		
		// we link after adding nodes
		crossLinkage(newNode, subLayer, growingLayer, nextLayer);
		
		
	}

	private void crossLinkage(Node newNode, ILayer subLayer, ILayer growingLayer, ILayer nextLayer) {
		TestNetwork tester = TestNetwork.getInstance();
		
		newNode.getArea().getLinkage().sublayerFanOutLinkage(newNode, subLayer);
		
		newNode.getArea().getLinkage().nextLayerFanOutLinkage(newNode, nextLayer);
		
		for (Link link : newNode.getInputs())
			link.initWeight(tester.getInitWeightRange(0), tester.getInitWeightRange(1));
		
		if (growingLayer.isDropOutLayer()) {
			newNode.setDropOutActive(true);
		}
	}


	@Override
	public void afterProcess() {
	}
	
}
package RN.strategy;

/**
 * @author Eric Marchand
 *
 */
public interface IStrategy {

	void beforeProcess();

	void afterProcess();
	
	void apply();
	
}
package RN.strategy;

import RN.INetwork;

/**
 * @author Eric Marchand
 *
 */
public class Strategy {

	protected static INetwork network = null;
	
	public Strategy(){
	}
	
	public Strategy(INetwork network){
		Strategy.network = network;
	}
	
	
	public void process(){
		System.out.println("Strategy process");
	}
	

	public void apply(){
		process();
	}
	
}
package RN.strategy;

import RN.INetwork;
import RN.Network;

/**
 * @author Eric Marchand
 *
 */
public class StrategyFactory {

	public static Strategy create(INetwork network, EStrategy eStrategy){
		
		Strategy strategy = new Strategy(network);

		
		if(eStrategy == EStrategy.AUTO_GROWING_HIDDENS){
			strategy = new GrowingNetworkStrategy();
		}
		
		return strategy;
	}
	
	public static void main(String[] args){
		create(Network.getInstance(), EStrategy.AUTO_GROWING_HIDDENS).apply();
	}
	
}
package RN.strategy;

/**
 * @author Eric Marchand
 *
 */
public class TestStrategy extends AbstractStrategyDecorator implements IStrategy{

	public TestStrategy(Strategy strategy) {
		this.decoratedStrategy = strategy;
	}

	@Override
	public void beforeProcess() {
		System.out.println("TestStrategy beforeProcess");
		
	}

	@Override
	public void afterProcess() {
		System.out.println("TestStrategy afterProcess");
		
	}

}
package RN;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;

import javafx.collections.FXCollections;
import javafx.scene.chart.LineChart;
import javafx.scene.chart.ScatterChart;
import javafx.scene.chart.XYChart;

import javax.xml.parsers.FactoryConfigurationError;

import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.apache.log4j.xml.DOMConfigurator;

import RN.algotrainings.ITrainer;
import RN.algotrainings.LSTMTrainer;
import RN.dataset.InputData;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import dmonner.xlbp.Network;
import dmonner.xlbp.UniformWeightInitializer;
import dmonner.xlbp.WeightUpdaterType;
import dmonner.xlbp.compound.InputCompound;
import dmonner.xlbp.compound.MemoryCellCompound;
import dmonner.xlbp.compound.XEntropyTargetCompound;
import dmonner.xlbp.trial.Step;

/**
 * @author Eric Marchand
 * 
 */
public class TestLSTMNetwork implements ITester {

	private static Logger logger = Logger.getLogger(TestLSTMNetwork.class);
	
	private static TestLSTMNetwork instance;

	public static INetwork net = null;

	InputCompound in = null;
	XEntropyTargetCompound out = null;

	final public static int trialLength = 500;
	final static int epochs = 10;
	static int insize = 4;
	final static int hidsize = 10;
	static int outsize = 2;
	// The number of trials in an epoch; i.e. size of group to measure. Default
	// = 100.
	final static int trialsPerEpoch = 4;

	Iterator<InputData> inputDataSetIterator = null;
	LineChart<Number, Number> sc = null;
	public static List<LineChart.Series<Number, Number>> seriesInList = new ArrayList<LineChart.Series<Number, Number>>();
	public static List<LineChart.Series<Number, Number>> seriesOutList = new ArrayList<LineChart.Series<Number, Number>>();
	public static List<LineChart.Series<Number, Number>> seriesIdealList = new ArrayList<LineChart.Series<Number, Number>>();	
	public static Properties properties = null;
	
	private static String filepath = null;
	private static Integer timeSeriesOffset = 0;
	
	static {

		properties = init();

		String timeSerieOffsetS = properties.getProperty("data.series.timeseries.offset");
		if (timeSerieOffsetS != null && !"".equals(timeSerieOffsetS))
			timeSeriesOffset = Integer.valueOf(timeSerieOffsetS);

		String fileS = properties.getProperty("data.series.filepath");
		if (fileS != null && !"".equals(fileS))
			filepath = fileS;
		
	}
	
	private static Properties init() throws FactoryConfigurationError {
		Properties properties;
		/**
		 * Mise en place log4j
		 */
		final InputStream log4jIs = TestNetwork.class.getResourceAsStream("/log4j.xml");
		new DOMConfigurator().doConfigure(log4jIs, LogManager.getLoggerRepository());

		/**
		 * Chargement du fichier de config
		 */
		final InputStream propertiesIs = TestNetwork.class.getResourceAsStream("/conf.properties");
		properties = new Properties();
		try {

			properties.load(propertiesIs);

		} catch (final IOException e) {

			final String message = "Unable to load properties file for Midas.";
			logger.error(message);

		} catch (final NullPointerException npe) {

			final String message = " property's missing.";
			logger.error(message);

		} finally {
			try {
				propertiesIs.close();
			} catch (IOException ignore) {
				// ignored
			}
			try {
				log4jIs.close();
			} catch (IOException ignore) {
				// ignored
			}
		}
		return properties;
	}
	
	public TestLSTMNetwork() {
	}

	public static void main(String[] args) throws IOException {
		ITester tester = TestLSTMNetwork.getInstance();
		ITrainer trainer = LSTMTrainer.getInstance();
//		DataSeries.getInstance().setTrainer(trainer);
		
//		InputSample.setSamples(1L, 1L, insize, outsize, delta, delay);
		
//        InputSample.setFileSample("src/RN/Sinus.xls", 6, 1L, 1L);
		
		ViewerFX.startViewerFX();
		ViewerFX.setTester(tester);
		ViewerFX.setTrainer(trainer);

		int idx = 1;
		
		for (String sheetName : InputSample.getSheetsName(filepath)) {
			ViewerFX.excelSheets.add(new InputSample("Sheet" + idx + ": " + sheetName, ESamples.FILE, idx));
			idx++;
		}
		
		// instance.trainLSTMNetwork();
	}

	public static TestLSTMNetwork getInstance() throws IOException {
		if (instance == null) {
			instance = new TestLSTMNetwork();
		}

		return instance;
	}


	
	public Network createLSTMNetwork() throws IOException {

		final String mctype = "IFOP";

		in = new InputCompound("Input", insize);
		final MemoryCellCompound mc = new MemoryCellCompound("Hidden", hidsize, mctype);
		final MemoryCellCompound mc2 = new MemoryCellCompound("Hidden2", hidsize, mctype);
		out = new XEntropyTargetCompound("Output", outsize);

		out.addUpstreamWeights(mc2);
		mc2.addUpstreamWeights(mc);
		mc.addUpstreamWeights(in);

		NetLSTMNetwork net = new NetLSTMNetwork("CanonicalLSTM");
		net.setWeightUpdaterType(WeightUpdaterType.basic(0.1F));
		net.setWeightInitializer(new UniformWeightInitializer(1.0F, -0.1F, 0.1F));
		net.add(in);
		net.add(mc);
		net.add(mc2);
		net.add(out);
		net.optimize();
		net.build();
		
		TestLSTMNetwork.net = net;

		// System.out.println(net.toString("NAWL"));

		// FileWriter outfile = new FileWriter(new File("test.dot"));
		// outfile.write((new NetworkDotBuilder(net)).toString());
		// outfile.flush();
		// outfile.close();

		// -- Print the network
		// System.out.println(net.toString("NICXW"));
		System.out.println("Creation of network LSTM\t#inputs: " + insize + " #outputs:" + outsize );
		System.out.println("Total weights: " + net.nWeights() + "\n");

//		net.getExitPoint(0).getDownstream().getUpstream().
		
		return net;

	}

	@Override
	public INetwork createNetwork(String name) {
		INetwork net = null;
		try {
			createLSTMNetwork();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return net;
	}

	@Override
	public void launchRealCompute() {

		DataSeries dataSeries = DataSeries.getInstance();
		ITrainer trainer = LSTMTrainer.getInstance();

		sc = ViewerFX.lineChart;		
		if (sc.getData() == null){
			sc.setData(FXCollections.<XYChart.Series<Number, Number>> observableArrayList());
		}
		
		
		LineChart.Series<Number, Number> series = null;
		seriesInList = new ArrayList<LineChart.Series<Number, Number>>();
		seriesOutList = new ArrayList<LineChart.Series<Number, Number>>();
		seriesIdealList = new ArrayList<LineChart.Series<Number, Number>>();
		
		for(int idx = 0; idx < getInputsCount(); idx++){
			series = new LineChart.Series<Number, Number>();
			series.setName("Run in" + (sc.getData().size() + 1));
			seriesInList.add(series);
		}
		
	
		for(int idx = 0; idx < getOutputsCount(); idx++){
			series = new LineChart.Series<Number, Number>();
			series.setName("Run out" + (sc.getData().size() + 1));
			seriesOutList.add(series);
		}
		

		for(int idx = 0; idx < getOutputsCount(); idx++){
			series = new LineChart.Series<Number, Number>();
			series.setName("Run ideal" + (sc.getData().size() + 1));
			seriesIdealList.add(series);
		}
		
		int runCycle = 0;
		for (InputData entry : dataSeries.getInputDataSet()) {

			// Clears the network, setting all units to their default activation
			// levels
			// net.clear();

			// Impose an input vector on the units of the input layer
			in.setInput(entry.getInputArray());

			((NetLSTMNetwork) net).activateTest();

			int idx = 0;
			for(LineChart.Series<Number, Number> seriesIn : seriesInList){
				seriesIn.getData().add(new ScatterChart.Data<Number, Number>(runCycle, in.getOutput().getActivations()[idx++]));
			}
			idx = 0;
			for(LineChart.Series<Number, Number> seriesOut : seriesOutList){
				seriesOut.getData().add(new ScatterChart.Data<Number, Number>(runCycle, out.getOutput().getActivations()[idx++]));
			}
			idx = 0;
			for(LineChart.Series<Number, Number> seriesIdeal : seriesIdealList){
				seriesIdeal.getData().add(new ScatterChart.Data<Number, Number>(runCycle, entry.getIdeal(idx++)));
			}
			runCycle++;
		}
		



		

	}

	// @Override
	// public Trial nextTestTrial()
	// {
	// return nextTrainTrial();
	// }
	//
	// @Override
	// public Trial nextTrainTrial()
	// {
	// final Trial trial = new Trial(getMetaNetwork());
	//
	// for(int i = 0; i < trialLength; i++)
	// {
	// // Adds a new Step to your Trial; the Trial automatically keeps track of
	// the steps & order.
	// final Step step = trial.nextStep();
	// // Optional: Set the sub-Network to activate on this step; defaults to
	// Trial's Network set above.
	// // step.setNetwork(stepNet);
	// // Note: You can do either or both of the following on a single Step; if
	// you have more than
	// // one simultaneous input or target (on different input/output layers) on
	// the same step, use the
	// // variants of these methods that allow you to specify the Layer the
	// input or target applies to.
	// // step.addInput(inputPattern);
	// // step.addTarget(targetPattern);
	//
	// setSamples(step, insize, outsize, delta, delay);
	//
	// // Optional: Tell the Trial to record the activation of the given Layer
	// after this step; these
	// // recordings can be saved and used for post-hoc analysis.
	// // step.addRecord(layerToRecord);
	// }
	//
	// return trial;
	// }
	//
	// @Override
	// public Trial nextValidationTrial()
	// {
	//
	// return nextTrainTrial();
	//
	// }
	//
	//
	//
	// @Override
	// public int nTestTrials()
	// {
	// return 1;
	// }
	//
	// @Override
	// public int nTrainTrials()
	// {
	// return trialsPerEpoch;
	// }
	//
	// @Override
	// public int nValidationTrials()
	// {
	// return 1;
	// }
	//


	static void setSamples(Step step, int inputCount, int outputCount, double delta, double delay) {
		InputSample.initIkeda();
		double d1 = (inputCount + outputCount - 2) * delta + delay;
		for (int j = 0; j < 500; j++) {
			float[] inputList = new float[inputCount];
			float[] outputList = new float[outputCount];
			double d2 = j * (1.0D - d1) / 500.0D;
			double d3;
			for (int i = 0; i < inputCount; i++) {
				d3 = d2 + delta * i;
				// inputList.add(InputSample.compute(ESamples.COSINUS, d3));
//				inputList[i] = (float) InputSample.getInstance().compute(ESamples.CHAOS, d3);
			}
			for (int i = 0; i < outputCount; i++) {
				d3 = d2 + delay + delta * (i + inputCount - 1);
				// outputList.add(InputSample.compute(ViewerFX.getSelectedSample(),
				// d3));
//				outputList[i] = (float) InputSample.getInstance().compute(ESamples.CHAOS, d3);
			}
			step.addInput(inputList);
			step.addTarget(outputList);
			// add(1L, 1L, inputList, outputList);
		}
	}


	@Override
	public int getInputsCount() {
		return insize;
	}

	@Override
	public int getOutputsCount() {
		return outsize;
	}

	@Override
	public void setInputsCount(int insize) {
		TestLSTMNetwork.insize = insize;
	}

	@Override
	public void setOutputsCount(int outsize) {
		TestLSTMNetwork.outsize = outsize;
	}

	public static INetwork getNet() {
		return net;
	}

	public InputCompound getIn() {
		return in;
	}

	public XEntropyTargetCompound getOut() {
		return out;
	}


	@Override
	public INetwork initWeights(double min, double max) {
		((NetLSTMNetwork) net).clear();
		return null;
	}

	


	@Override
	public INetwork getNetwork() {
		return net;
	}

	@Override
	public List<LineChart.Series<Number, Number>> getSeriesInList() {
		return seriesInList;
	}

	@Override
	public void setSeriesInList(List<LineChart.Series<Number, Number>> seriesInList) {
		TestLSTMNetwork.seriesInList = seriesInList;
	}

	@Override
	public List<LineChart.Series<Number, Number>> getSeriesOutList() {
		return seriesOutList;
	}

	@Override
	public void setSeriesOutList(List<LineChart.Series<Number, Number>> seriesOutList) {
		TestLSTMNetwork.seriesOutList = seriesOutList;
	}

	@Override
	public List<LineChart.Series<Number, Number>> getSeriesIdealList() {
		return seriesIdealList;
	}

	@Override
	public void setSeriesIdealList(List<LineChart.Series<Number, Number>> seriesIdealList) {
		TestLSTMNetwork.seriesIdealList = seriesIdealList;
	}



	@Override
	public void setNetwork(INetwork net) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public double getInitWeightRange(int idx) {
		// TODO Auto-generated method stub
		return 0D;
	}
	
	

	@Override
	public String getLineChartTitle() {
		return "LSTM network : " + insize + " input(s), " + outsize + " output(s)";
	}
	
	@Override
	public String getFilePath() {
		return filepath;
	}

	@Override
	public Integer getTimeSeriesOffset() {
		return 0;
	}

	@Override
	public void setTrainingVectorNumber(Integer lastRowNum) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Integer getLayerHidden0NodesCount() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setLayerHidden0NodesCount(Integer layerHidden0NodesCount) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Integer getLayerHidden1NodesCount() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setLayerHidden1NodesCount(Integer layerHidden1NodesCount) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Integer getLayerHidden2NodesCount() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setLayerHidden2NodesCount(Integer layerHidden2NodesCount) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Integer getLayerOutNodesCount() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setLayerOutNodesCount(Integer layerOutNodesCount) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public String getLayerOutActivation() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setLayerOutActivation(String layerOutActivation) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Boolean getLayerOutRecurrent() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setLayerOutRecurrent(Boolean layerOutRecurrent) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public String getLayerHidden0Activation() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setLayerHidden0Activation(String layerHidden0Activation) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Boolean getLayerHidden0Recurrent() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setLayerHidden0Recurrent(Boolean layerHidden0Recurrent) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public String getLayerHidden1Activation() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setLayerHidden1Activation(String layerHidden1Activation) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Boolean getLayerHidden1Recurrent() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setLayerHidden1Recurrent(Boolean layerHidden1Recurrent) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public String getLayerHidden2Activation() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setLayerHidden2Activation(String layerHidden2Activation) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Boolean getLayerHidden2Recurrent() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setLayerHidden2Recurrent(Boolean layerHidden2Recurrent) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public Integer getLayerInNodesCount() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setLayerInNodesCount(Integer layerInNodesCount) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public String getLayerInActivation() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void setLayerInActivation(String layerInActivation) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public int getOptimizedNumHiddens() {
		// TODO Auto-generated method stub
		return 0;
	}

	@Override
	public void setOptimizedNumHiddens(int optimizedNumHiddens) {
		// TODO Auto-generated method stub
		
	}

	@Override
	public INetwork createXLSNetwork(String networkName, NetworkContext netContext) {


		INetwork network = netContext.newNetwork(networkName);

		// network.show();

		TestLSTMNetwork.net = network;

		return network;
	}

	@Override
	public void launchTestCompute() throws Exception {
		// TODO Auto-generated method stub
		
	}

	public static String getFilepath() {
		return filepath;
	}

	public static void setFilepath(String filepath) {
		TestLSTMNetwork.filepath = filepath;
	}

	public static void setTimeSeriesOffset(Integer timeSeriesOffset) {
		TestLSTMNetwork.timeSeriesOffset = timeSeriesOffset;
	}

	@Override
	public boolean isDropOutActive() {
		return false;
	}



}
package RN;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;
import java.util.Properties;

import javax.xml.parsers.FactoryConfigurationError;

import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import org.apache.log4j.xml.DOMConfigurator;

import RN.algoactivations.EActivation;
import RN.algotrainings.BackPropagationTrainer;
import RN.algotrainings.ITrainer;
import RN.dataset.InputData;
import RN.dataset.OutputData;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.linkage.ELinkage;
import RN.links.Link;
import RN.nodes.ENodeType;
import RN.nodes.INode;
import javafx.collections.FXCollections;
import javafx.scene.chart.LineChart;
import javafx.scene.chart.XYChart;

/**
 * @author Eric Marchand
 * 
 */
public class TestNetwork implements ITester {

	private static Logger logger = Logger.getLogger(TestNetwork.class);

	private static TestNetwork instance = null;
	private static String filepath = null;
	private static Integer timeSeriesOffset = 0;
	private static Integer inputSize = null;
	private static Integer layerHidden0NodesCount = null;
	private static Integer layerHidden1NodesCount = null;
	private static Integer layerHidden2NodesCount = null;
	private static Integer outputSize = null;
	private static boolean dropOutActive = false;

	private static String key = null;
	private static String value = null;
	private static Integer layerOutNodesCount = null;
	private static String layerOutActivation = null;
	private static Boolean layerOutRecurrent = null;
	private static String layerHidden0Activation = null;
	private static Boolean layerHidden0Recurrent = null;
	private static String layerHidden1Activation = null;
	private static Boolean layerHidden1Recurrent = null;
	private static String layerHidden2Activation = null;
	private static Boolean layerHidden2Recurrent = null;
	private static Integer layerInNodesCount = null;
	private static String layerInActivation = null;
	private static Boolean layerOutNodesDropOut = Boolean.FALSE;
	private static Boolean layerHidden0NodesDropOut = Boolean.FALSE;
	private static Boolean layerHidden1NodesDropOut = Boolean.FALSE;
	private static Boolean layerHidden2NodesDropOut = Boolean.FALSE;
	private static Boolean layerInNodesDropOut = Boolean.FALSE;
	private static Boolean lateralLinkRecurrentNodes = Boolean.FALSE;
	private static Boolean hiddensNodeNumberOptimized = Boolean.FALSE;
	private static int optimizedNumHiddens = 0;

	private static Integer trainingVectorNumber = null;

	public static INetwork network;

	public static List<LineChart.Series<Number, Number>> seriesInList = new ArrayList<LineChart.Series<Number, Number>>();
	public static List<LineChart.Series<Number, Number>> seriesOutList = new ArrayList<LineChart.Series<Number, Number>>();
	public static List<LineChart.Series<Number, Number>> seriesIdealList = new ArrayList<LineChart.Series<Number, Number>>();
	public final double[] initWeightRange = new double[] { 0D, 1.0D };
	public static Properties properties = null;

	static {

		properties = init();

		String timeSerieOffsetS = properties.getProperty("data.series.timeseries.offset");
		if (timeSerieOffsetS != null && !"".equals(timeSerieOffsetS))
			timeSeriesOffset = Integer.valueOf(timeSerieOffsetS);

		String fileS = properties.getProperty("data.series.filepath");
		if (fileS != null && !"".equals(fileS))
			filepath = fileS;

		String dropOutActiveStr = properties.getProperty("nn.dropout.active");
		if (dropOutActiveStr != null && !"".equals(dropOutActiveStr))
			dropOutActive = dropOutActiveStr.equalsIgnoreCase("true");

	}

	private TestNetwork() {
	}

	public static TestNetwork getInstance() {
		if (instance == null) {
			instance = new TestNetwork();
		}

		return instance;
	}

	public static void main(String[] args) throws Exception {
		ITester tester = TestNetwork.getInstance();
		ITrainer trainer = new BackPropagationTrainer();

		ViewerFX.startViewerFX();
		ViewerFX.setTrainer(trainer);
		ViewerFX.setTester(tester);

		int idx = 1;

		for (String sheetName : InputSample.getSheetsName(filepath)) {
			ViewerFX.excelSheets.add(new InputSample("Sheet" + idx + ": " + sheetName, ESamples.FILE, idx));
			idx++;
		}

	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see RN.ITester#createNetwork(java.lang.Long, java.lang.Long)
	 */
	@Override
	public INetwork createNetwork(String networkName) {

		key = null;
		value = null;
		layerOutNodesCount = null;
		layerOutActivation = null;
		layerOutRecurrent = null;
		layerHidden0Activation = null;
		layerHidden0Recurrent = null;
		layerHidden1Activation = null;
		layerHidden1Recurrent = null;
		layerHidden2Activation = null;
		layerHidden2Recurrent = null;
		layerInNodesCount = null;
		layerInActivation = null;
		layerOutNodesDropOut = Boolean.FALSE;
		layerHidden0NodesDropOut = Boolean.FALSE;
		layerHidden1NodesDropOut = Boolean.FALSE;
		layerHidden2NodesDropOut = Boolean.FALSE;
		layerInNodesDropOut = Boolean.FALSE;
		lateralLinkRecurrentNodes = Boolean.FALSE;
		hiddensNodeNumberOptimized = Boolean.FALSE;

		for (final Object obj : properties.keySet()) {
			key = (String) obj;
			value = properties.getProperty(key);

			if (key.startsWith("nn.layer.out.nodes.count"))
				layerOutNodesCount = Integer.valueOf(value);

			if (key.startsWith("nn.layer.out.activation.fx"))
				layerOutActivation = value;
			if (key.startsWith("nn.layer.out.recurrent"))
				if (!"".equals(value))
					layerOutRecurrent = Boolean.valueOf(value);
			if (key.startsWith("nn.layer.out.nodes.dropout"))
				if (!"".equals(value))
					layerOutNodesDropOut = Boolean.valueOf(value);

			if (key.startsWith("nn.layer.hidden.0.nodes.count"))
				layerHidden0NodesCount = Integer.valueOf(value);
			if (key.startsWith("nn.layer.hidden.0.activation.fx"))
				layerHidden0Activation = value;
			if (key.startsWith("nn.layer.hidden.0.recurrent"))
				if (!"".equals(value))
					layerHidden0Recurrent = Boolean.valueOf(value);
			if (key.startsWith("nn.layer.hidden.0.nodes.dropout"))
				if (!"".equals(value))
					layerHidden0NodesDropOut = Boolean.valueOf(value);

			if (key.startsWith("nn.layer.hidden.1.nodes.count"))
				layerHidden1NodesCount = Integer.valueOf(value);
			if (key.startsWith("nn.layer.hidden.1.activation.fx"))
				layerHidden1Activation = value;
			if (key.startsWith("nn.layer.hidden.1.recurrent"))
				if (!"".equals(value))
					layerHidden1Recurrent = Boolean.valueOf(value);
			if (key.startsWith("nn.layer.hidden.1.nodes.dropout"))
				if (!"".equals(value))
					layerHidden1NodesDropOut = Boolean.valueOf(value);

			if (key.startsWith("nn.layer.hidden.2.nodes.count"))
				layerHidden2NodesCount = Integer.valueOf(value);
			if (key.startsWith("nn.layer.hidden.2.activation.fx"))
				layerHidden2Activation = value;
			if (key.startsWith("nn.layer.hidden.2.recurrent"))
				if (!"".equals(value))
					layerHidden2Recurrent = Boolean.valueOf(value);
			if (key.startsWith("nn.layer.hidden.2.nodes.dropout"))
				if (!"".equals(value))
					layerHidden2NodesDropOut = Boolean.valueOf(value);

			if (key.startsWith("nn.layer.in.nodes.count"))
				layerInNodesCount = Integer.valueOf(value);

			if (key.startsWith("nn.layer.in.activation.fx"))
				if (!"".equals(value))
					layerInActivation = value;
			if (key.startsWith("nn.layer.in.nodes.dropout"))
				if (!"".equals(value))
					layerInNodesDropOut = Boolean.valueOf(value);

			if (key.startsWith("nn.recurrent.nodes.linked"))
				if (!"".equals(value))
					lateralLinkRecurrentNodes = Boolean.valueOf(value);

			if (key.startsWith("nn.hidden.nodes.number.optimized"))
				if (!"".equals(value))
					hiddensNodeNumberOptimized = Boolean.valueOf(value);

		}

		INetwork network = Network.getInstance();
		network.setName(networkName);

		// Neuralware (2001) approach
		optimizedNumHiddens = getTrainingVectorNumber() / (5 * (getInputSize() + getOutputSize()));
		optimizedNumHiddens = Math.max(5, optimizedNumHiddens);

		Layer layer = new Layer(
				layerInActivation == null ? EActivation.IDENTITY : EActivation.getEnum(layerInActivation));
		Area area = new Area(inputSize != null ? inputSize : layerInNodesCount);
		layer.addArea(area);
		area.configureLinkage(ELinkage.ONE_TO_ONE, null, false);
		area.configureNode(false, EActivation.IDENTITY, ENodeType.REGULAR);
		area.createNodes(inputSize != null ? inputSize : layerInNodesCount);
		layer.setDropOut(layerInNodesDropOut);
		network.addLayer(layer);
		network.setTimeSeriesOffset(timeSeriesOffset);
		network.setRecurrentNodesLinked(lateralLinkRecurrentNodes);

		if (layerHidden0NodesCount != null && layerHidden0NodesCount > 0) {
			layer = new Layer(EActivation.getEnum(layerHidden0Activation));
			Area area0 = null;
			if (!hiddensNodeNumberOptimized) {
				area0 = new Area(layerHidden0NodesCount);
				layer.addArea(area0);
				area0.configureLinkage(ELinkage.MANY_TO_MANY, null, true);
				area0.configureNode(true, EActivation.IDENTITY, ENodeType.REGULAR);
				area0.createNodes(layerHidden0NodesCount);
			} else {
				area0 = new Area(optimizedNumHiddens);
				layer.addArea(area0);
				area0.configureLinkage(ELinkage.MANY_TO_MANY, null, false);
				area0.configureNode(true, EActivation.IDENTITY, ENodeType.REGULAR);
				area0.createNodes(optimizedNumHiddens);
			}
			if (layerHidden0Recurrent != null)
				layer.setReccurent(layerHidden0Recurrent);
			layer.setDropOut(layerHidden0NodesDropOut);
			network.addLayer(layer);
		}

		if (layerHidden1NodesCount != null && layerHidden1NodesCount > 0) {
			layer = new Layer(EActivation.getEnum(layerHidden1Activation));
			Area area1 = null;
			if (!hiddensNodeNumberOptimized) {
				area1 = new Area(layerHidden1NodesCount);
				layer.addArea(area1);
				area1.configureLinkage(ELinkage.MANY_TO_MANY, null, true);
				area1.configureNode(true, EActivation.IDENTITY, ENodeType.REGULAR);
				area1.createNodes(layerHidden1NodesCount);
			} else {
				area1 = new Area(optimizedNumHiddens);
				layer.addArea(area1);
				area1.configureLinkage(ELinkage.MANY_TO_MANY, null, true);
				area1.configureNode(true, EActivation.IDENTITY, ENodeType.REGULAR);
				area1.createNodes(optimizedNumHiddens);
			}

			if (layerHidden1Recurrent != null)
				layer.setReccurent(layerHidden1Recurrent);
			layer.setDropOut(layerHidden1NodesDropOut);
			network.addLayer(layer);
		}

		if (layerHidden2NodesCount != null && layerHidden2NodesCount > 0) {
			layer = new Layer(EActivation.getEnum(layerHidden2Activation));
			Area area2 = null;
			if (!hiddensNodeNumberOptimized) {
				area2 = new Area(layerHidden2NodesCount);
				layer.addArea(area2);
				area2.configureLinkage(ELinkage.MANY_TO_MANY, null, true);
				area2.configureNode(true, EActivation.IDENTITY, ENodeType.REGULAR);
				area2.createNodes(layerHidden2NodesCount);
			} else {
				area2 = new Area(optimizedNumHiddens);
				layer.addArea(area2);
				area2.configureLinkage(ELinkage.MANY_TO_MANY, null, true);
				area2.configureNode(true, EActivation.IDENTITY, ENodeType.REGULAR);
				area2.createNodes(optimizedNumHiddens);
			}

			if (layerHidden2Recurrent != null)
				layer.setReccurent(layerHidden2Recurrent);
			layer.setDropOut(layerHidden2NodesDropOut);
			network.addLayer(layer);
		}

		layer = new Layer(EActivation.getEnum(layerOutActivation));
		Area area3 = new Area(outputSize != null ? outputSize : layerOutNodesCount);
		layer.addArea(area3);
		area3.configureLinkage(ELinkage.MANY_TO_MANY, null, true);
		area3.configureNode(true, EActivation.IDENTITY, ENodeType.REGULAR);
		area3.createNodes(outputSize != null ? outputSize : layerOutNodesCount);
		if (layerOutRecurrent != null)
			layer.setReccurent(layerOutRecurrent);
		layer.setDropOut(layerOutNodesDropOut);
		network.addLayer(layer);

		network.setName(network.getName() + network.geneticCodec());
		// network.show();

		TestNetwork.network = network;

		return network;

	}

	@Override
	public INetwork createXLSNetwork(String networkName, NetworkContext netContext) {

		TestNetwork.network = null;

		INetwork network = netContext.newNetwork(networkName);

		// network.show();

		TestNetwork.network = network;

		return network;

	}

	private static Properties init() throws FactoryConfigurationError {
		
		Properties properties;
		/**
		 * Mise en place log4j
		 */
		final InputStream log4jIs = TestNetwork.class.getResourceAsStream("/log4j.xml");
		new DOMConfigurator().doConfigure(log4jIs, LogManager.getLoggerRepository());

		/**
		 * Chargement du fichier de config
		 */
		final InputStream propertiesIs = TestNetwork.class.getResourceAsStream("/conf.properties");
		properties = new Properties();
		try {

			properties.load(propertiesIs);

		} catch (final IOException e) {

			final String message = "Unable to load properties file for Deepnet.";
			logger.error(message);

		} catch (final NullPointerException npe) {

			final String message = " property's missing.";
			logger.error(message);

		} finally {
			try {
				propertiesIs.close();
			} catch (IOException ignore) {
				// ignored
			}
			try {
				log4jIs.close();
			} catch (IOException ignore) {
				// ignored
			}
		}
		return properties;
	}

	public Double computeY(INode node, Double x) {
		List<Link> inputs = node.getInputs();
		return (-inputs.get(0).getWeight() * x + node.getBiasInput().getValue() * node.getBiasInput().getWeight())
				/ inputs.get(1).getWeight();
	}





	/*
	 * (non-Javadoc)
	 * 
	 * @see RN.ITester#launchRealCompute(java.lang.Long, java.lang.Long)
	 */
	@Override
	public void launchRealCompute() throws Exception {

		DataSeries dataSeries = DataSeries.getInstance();
		INetwork network = getNetwork();
		LineChart<Number, Number> lineChart = ViewerFX.lineChart;

		if (network != null && !dataSeries.getInputDataSet().isEmpty()) {

			OutputData output = null;

			if (lineChart.getData() == null)
				lineChart.setData(FXCollections.<XYChart.Series<Number, Number>>observableArrayList());

			LineChart.Series<Number, Number> series = null;
			initLineChartSeries();

			for (int idx = 0; idx < getInputsCount(); idx++) {
				series = new LineChart.Series<Number, Number>();
				series.setName("Run in" + (lineChart.getData().size() + 1));
				seriesInList.add(series);
			}

			for (int idx = 0; idx < getOutputsCount(); idx++) {
				series = new LineChart.Series<Number, Number>();
				series.setName("Run out[" + idx + "]" + (lineChart.getData().size() + 1));
				seriesOutList.add(series);
			}

			for (int idx = 0; idx < getOutputsCount(); idx++) {
				series = new LineChart.Series<Number, Number>();
				series.setName("Run ideal[" + idx + "]" + (lineChart.getData().size() + 1));
				seriesIdealList.add(series);
			}

			int runCycle = 0;
			ListIterator<InputData> computeItr = dataSeries.getInputDataSet().listIterator();
			for (InputData entry : dataSeries.getInputDataSet()) {
				try {
					output = network.compute(computeItr);
				} catch (Exception e) {
					e.printStackTrace();
				}

				int idx = 0;
				if (ViewerFX.showLogs.isSelected()) {
					String log = "inputs[  ";
					for (double input : entry.getInput()) {
						log += input + "  ";
					}
					log += "]";
					log += "\r\noutputs[  ";
					for (double out : output.getOutput()) {
						log += out + "  ";
					}
					log += "]";
					log += "\r\nideals[  ";
					for (double ideal : entry.getIdeal()) {
						log += ideal + "  ";
					}

					log += "]\r\n";
					System.out.println(log);
					log = null;
				}

				idx = 0;
				for (LineChart.Series<Number, Number> seriesIn : seriesInList) {
					seriesIn.getData().add(new LineChart.Data<Number, Number>(runCycle, entry.getInput(idx++)));
				}
				idx = 0;
				for (LineChart.Series<Number, Number> seriesOut : seriesOutList) {
					seriesOut.getData().add(new LineChart.Data<Number, Number>(runCycle, output.getOutput(idx++)));
				}
				idx = 0;
				for (LineChart.Series<Number, Number> seriesIdeal : seriesIdealList) {
					seriesIdeal.getData().add(new LineChart.Data<Number, Number>(runCycle, entry.getIdeal(idx++)));
				}
				runCycle++;
			}
			ViewerFX.addSeriesToLineChart();
		}
	}

	@Override
	public void launchTestCompute() throws Exception {

		DataSeries dataSeries = DataSeries.getInstance();
		INetwork network = getNetwork();
		LineChart<Number, Number> lineChart = ViewerFX.lineChart;

		if (network != null && !dataSeries.testsAreEmpty()) {

			OutputData output = null;

			if (lineChart.getData() == null)
				lineChart.setData(FXCollections.<XYChart.Series<Number, Number>>observableArrayList());

			LineChart.Series<Number, Number> series = null;
			initLineChartSeries();

			for (int idx = 0; idx < getInputsCount(); idx++) {
				series = new LineChart.Series<Number, Number>();
				series.setName("Run in" + (lineChart.getData().size() + 1));
				seriesInList.add(series);
			}

			for (int idx = 0; idx < getOutputsCount(); idx++) {
				series = new LineChart.Series<Number, Number>();
				series.setName("Run out[" + idx + "]" + (lineChart.getData().size() + 1));
				seriesOutList.add(series);
			}

			int runCycle = 0;
			ListIterator<InputData> computeItr = dataSeries.getInputTestDataSet().listIterator();
			for (InputData entry : dataSeries.getInputTestDataSet()) {
				try {
					output = network.compute(computeItr);
				} catch (Exception e) {
					e.printStackTrace();
				}

				int idx = 0;
				if (ViewerFX.showLogs.isSelected()) {
					System.out.print("[  ");
					for (double input : entry.getInput()) {
						System.out.print(input + "  ");
					}
					System.out.print("]");

					for (double out : output.getOutput()) {
						System.out.print(", [actual=" + out);
					}
					System.out.println(" ");
				}

				idx = 0;
				for (LineChart.Series<Number, Number> seriesIn : seriesInList) {
					seriesIn.getData().add(new LineChart.Data<Number, Number>(runCycle, entry.getInput(idx++)));
				}
				idx = 0;
				for (LineChart.Series<Number, Number> seriesOut : seriesOutList) {
					seriesOut.getData().add(new LineChart.Data<Number, Number>(runCycle, output.getOutput(idx++)));
				}

				runCycle++;
			}
			ViewerFX.addSeriesToLineChart();
		}
	}

	private void initLineChartSeries() {
		seriesInList = new ArrayList<LineChart.Series<Number, Number>>();
		seriesOutList = new ArrayList<LineChart.Series<Number, Number>>();
		seriesIdealList = new ArrayList<LineChart.Series<Number, Number>>();
	}

	@Override
	public INetwork initWeights(double min, double max) {
		INetwork network = getNetwork();
		network.init(min, max);
		return network;
	}

	@Override
	public INetwork getNetwork() {
		return network;
	}

	@Override
	public int getInputsCount() {
		return network.getFirstLayer().getNodeCountMinusRecurrentOnes();
	}

	@Override
	public int getOutputsCount() {
		return network.getLastLayer().getNodeCount();
	}

	@Override
	public void setInputsCount(int insize) {
		this.inputSize = insize;
	}

	@Override
	public void setOutputsCount(int outsize) {
		this.outputSize = outsize;
	}

	public List<LineChart.Series<Number, Number>> getSeriesInList() {
		return seriesInList;
	}

	public void setSeriesInList(List<LineChart.Series<Number, Number>> seriesInList) {
		TestNetwork.seriesInList = seriesInList;
	}

	public List<LineChart.Series<Number, Number>> getSeriesOutList() {
		return seriesOutList;
	}

	public void setSeriesOutList(List<LineChart.Series<Number, Number>> seriesOutList) {
		TestNetwork.seriesOutList = seriesOutList;
	}

	public List<LineChart.Series<Number, Number>> getSeriesIdealList() {
		return seriesIdealList;
	}

	public void setSeriesIdealList(List<LineChart.Series<Number, Number>> seriesIdealList) {
		TestNetwork.seriesIdealList = seriesIdealList;
	}

	public void setNetwork(INetwork network) {
		TestNetwork.network = network;
	}

	@Override
	public double getInitWeightRange(int idx) {
		return initWeightRange[idx];
	}

	public String getFilePath() {
		return filepath;
	}

	public static void setFilepath(String filePath) {
		TestNetwork.filepath = filepath;
	}

	public Integer getTimeSeriesOffset() {
		return timeSeriesOffset;
	}

	public static void setTimeSeriesOffset(Integer timeSeriesOffset) {
		TestNetwork.timeSeriesOffset = timeSeriesOffset;
	}

	public static Integer getTrainingVectorNumber() {
		return trainingVectorNumber;
	}

	public void setTrainingVectorNumber(Integer trainingVectorNumber) {
		TestNetwork.trainingVectorNumber = trainingVectorNumber;
	}

	public static Integer getInputSize() {
		return inputSize;
	}

	public static Integer getOutputSize() {
		return outputSize;
	}

	@Override
	public String getLineChartTitle() {
		return "Please select a dataset";
	}

	public Integer getLayerHidden0NodesCount() {
		return layerHidden0NodesCount;
	}

	public void setLayerHidden0NodesCount(Integer layerHidden0NodesCount) {
		TestNetwork.layerHidden0NodesCount = layerHidden0NodesCount;
	}

	public Integer getLayerHidden1NodesCount() {
		return layerHidden1NodesCount;
	}

	public void setLayerHidden1NodesCount(Integer layerHidden1NodesCount) {
		TestNetwork.layerHidden1NodesCount = layerHidden1NodesCount;
	}

	public Integer getLayerHidden2NodesCount() {
		return layerHidden2NodesCount;
	}

	public void setLayerHidden2NodesCount(Integer layerHidden2NodesCount) {
		TestNetwork.layerHidden2NodesCount = layerHidden2NodesCount;
	}

	public Integer getLayerOutNodesCount() {
		return layerOutNodesCount;
	}

	public void setLayerOutNodesCount(Integer layerOutNodesCount) {
		TestNetwork.layerOutNodesCount = layerOutNodesCount;
	}

	public String getLayerOutActivation() {
		return layerOutActivation;
	}

	public void setLayerOutActivation(String layerOutActivation) {
		TestNetwork.layerOutActivation = layerOutActivation;
	}

	public Boolean getLayerOutRecurrent() {
		return layerOutRecurrent;
	}

	public void setLayerOutRecurrent(Boolean layerOutRecurrent) {
		TestNetwork.layerOutRecurrent = layerOutRecurrent;
	}

	public String getLayerHidden0Activation() {
		return layerHidden0Activation;
	}

	public void setLayerHidden0Activation(String layerHidden0Activation) {
		TestNetwork.layerHidden0Activation = layerHidden0Activation;
	}

	public Boolean getLayerHidden0Recurrent() {
		return layerHidden0Recurrent;
	}

	public void setLayerHidden0Recurrent(Boolean layerHidden0Recurrent) {
		TestNetwork.layerHidden0Recurrent = layerHidden0Recurrent;
	}

	public String getLayerHidden1Activation() {
		return layerHidden1Activation;
	}

	public void setLayerHidden1Activation(String layerHidden1Activation) {
		TestNetwork.layerHidden1Activation = layerHidden1Activation;
	}

	public Boolean getLayerHidden1Recurrent() {
		return layerHidden1Recurrent;
	}

	public void setLayerHidden1Recurrent(Boolean layerHidden1Recurrent) {
		TestNetwork.layerHidden1Recurrent = layerHidden1Recurrent;
	}

	public String getLayerHidden2Activation() {
		return layerHidden2Activation;
	}

	public void setLayerHidden2Activation(String layerHidden2Activation) {
		TestNetwork.layerHidden2Activation = layerHidden2Activation;
	}

	public Boolean getLayerHidden2Recurrent() {
		return layerHidden2Recurrent;
	}

	public void setLayerHidden2Recurrent(Boolean layerHidden2Recurrent) {
		TestNetwork.layerHidden2Recurrent = layerHidden2Recurrent;
	}

	public Integer getLayerInNodesCount() {
		return layerInNodesCount;
	}

	public void setLayerInNodesCount(Integer layerInNodesCount) {
		TestNetwork.layerInNodesCount = layerInNodesCount;
	}

	public String getLayerInActivation() {
		return layerInActivation;
	}

	public void setLayerInActivation(String layerInActivation) {
		TestNetwork.layerInActivation = layerInActivation;
	}

	public int getOptimizedNumHiddens() {
		return optimizedNumHiddens;
	}

	public void setOptimizedNumHiddens(int optimizedNumHiddens) {
		TestNetwork.optimizedNumHiddens = optimizedNumHiddens;
	}

	@Override
	public boolean isDropOutActive() {
		return dropOutActive;
	}

}
package RN.tests;

import static org.junit.Assert.assertEquals;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import RN.Area;
import RN.AreaSquare;
import RN.AreaSquareSampled;
import RN.IArea;
import RN.nodes.ENodeType;

public class AreaTest {
	
	private AreaSquare area = null;

	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
	}

	@Before
	public void setUp() throws Exception {
	}

	@After
	public void tearDown() throws Exception {
	}

	@Test
	public void testArea() {
		int width = 3;
		int widthXheight = width * width;
		area = new AreaSquare(widthXheight);
		int x = 0; 
		int y = 0; 
		assertEquals(width * y, area.nodeXYToNodeId(0, y), 0D);
		x = 1; 
		assertEquals(1, area.nodeXYToNodeId(x, y), 0D);
		assertEquals(x, area.nodeIdToNodeXY(1)[0], 0D);
		assertEquals(y, area.nodeIdToNodeXY(1)[1], 0D);
		y = 1; 
		assertEquals(4, area.nodeXYToNodeId(x, y), 0D);
		assertEquals(x, area.nodeIdToNodeXY(4)[0], 0D);
		assertEquals(y, area.nodeIdToNodeXY(4)[1], 0D);
		y = 2; 
		assertEquals(7, area.nodeXYToNodeId(x, y), 0D);
		assertEquals(x, area.nodeIdToNodeXY(7)[0], 0D);
		assertEquals(y, area.nodeIdToNodeXY(7)[1], 0D);
		x = 2; 
		assertEquals(x + width * y, area.nodeXYToNodeId(x, y), 0D);
		assertEquals(8, area.nodeXYToNodeId(x, y), 0D);
		assertEquals(x, area.nodeIdToNodeXY(8)[0], 0D);
		assertEquals(y, area.nodeIdToNodeXY(8)[1], 0D);
	}
	
	@Test
	public void testArea2() {
		int width = 100;
		int widthXheight = width * width;
		area = new AreaSquare(widthXheight);
		int x = 0; 
		int y = 0; 
		assertEquals(0, area.nodeXYToNodeId(0, y), 0D);
		assertEquals(x, area.nodeIdToNodeXY(0)[0], 0D);
		assertEquals(y, area.nodeIdToNodeXY(0)[1], 0D);
		x = 99; 
		assertEquals(99, area.nodeXYToNodeId(x, y), 0D);
		assertEquals(x, area.nodeIdToNodeXY(99)[0], 0D);
		assertEquals(y, area.nodeIdToNodeXY(99)[1], 0D);
		y = 99; 
		assertEquals(9999, area.nodeXYToNodeId(x, y), 0D);
		assertEquals(x, area.nodeIdToNodeXY(9999)[0], 0D);
		assertEquals(y, area.nodeIdToNodeXY(9999)[1], 0D);

	}
	
	@Test
	public void testArea3() {
		int width = 100;
		int widthXheight = width * width;
		area = new AreaSquare(widthXheight);
		int x = 0; 
		int y = 0; 
		assertEquals(0, area.nodeXYToNodeId(0, y), 0D);
		assertEquals(x, area.nodeIdToNodeXY(0)[0], 0D);
		assertEquals(y, area.nodeIdToNodeXY(0)[1], 0D);
		x = 99; 
		assertEquals(99, area.nodeXYToNodeId(x, y), 0D);
		assertEquals(x, area.nodeIdToNodeXY(99)[0], 0D);
		assertEquals(y, area.nodeIdToNodeXY(99)[1], 0D);
		y = 99; 
		assertEquals(9999, area.nodeXYToNodeId(x, y), 0D);
		assertEquals(x, area.nodeIdToNodeXY(9999)[0], 0D);
		assertEquals(y, area.nodeIdToNodeXY(9999)[1], 0D);

	}
	
	@Test
	public void testArea4() {
		int width = 100;
		int widthXheight = width * width;
		area = new AreaSquare(widthXheight);
		area.configureNode(false, ENodeType.REGULAR).createNodes(widthXheight);
		
		assertEquals(widthXheight, area.getNodeCount(), 0D);
		
		AreaSquareSampled areaSampled = new AreaSquareSampled((AreaSquare) area, 2);
		
		assertEquals(Math.pow(width / 2, 2), areaSampled.getNodeCount(), 0D);
		
		int x = 0; 
		int y = 0; 
		assertEquals(0, areaSampled.nodeXYToNodeId(0, y), 0D);
		assertEquals(x, areaSampled.nodeIdToNodeXY(0)[0], 0D);
		assertEquals(y, areaSampled.nodeIdToNodeXY(0)[1], 0D);
		x = 49; 
		assertEquals(49, areaSampled.nodeXYToNodeId(x, y), 0D);
		assertEquals(x, areaSampled.nodeIdToNodeXY(99)[0], 0D);
		assertEquals(y, areaSampled.nodeIdToNodeXY(49)[1], 0D);
		y = 49; 
		assertEquals(2499, areaSampled.nodeXYToNodeId(x, y), 0D);
		assertEquals(x, areaSampled.nodeIdToNodeXY(2499)[0], 0D);
		assertEquals(y, areaSampled.nodeIdToNodeXY(2499)[1], 0D);
		
		assertEquals(25, areaSampled.getNodeCenterX(), 0D);
		assertEquals(25, areaSampled.getNodeCenterY(), 0D);
		
		

	}
	
	@Test
	public void testArea5() {
		Sigma sigma = new Sigma(0D);
		sum(sigma);
		System.out.println(sigma.sig);
		
	}
	
	static class Sigma{
		public Double sig = null;
		public Sigma(Double sig){
			this.sig = sig;
		}
	}

	private void sum(Sigma sigma) {
		sigma.sig += 10;
	}
	

}
package RN.tests;

import java.io.FileInputStream;
import java.io.ObjectInputStream;
import java.util.HashSet;
import java.util.Set;

import RN.Network;
import RN.NetworkService;

public class DeserializeAndViewTest {

    public static void main(String[] args) {
        // Remplacez le chemin vers votre fichier .ser
        String filePath = "models/deeper-net-model-20240328021700.ser";

        try (FileInputStream fileIn = new FileInputStream(filePath);
             ObjectInputStream in = new ObjectInputStream(fileIn)) {

            // Désérialise l'objet depuis le fichier
        	Network object = (Network) in.readObject();

            // Affiche des informations sur l'objet désérialisé
            // Cette partie dépend du type d'objet et de ce que vous souhaitez visualiser
            System.out.println("Objet désérialisé (toString): " + object.toString());
//            System.out.println(object.getString());
            
            Set<Integer> seenObjects = new HashSet<>();
            System.out.println("Objet désérialisé: ");
            NetworkService.printObjectDetails(object, 0, seenObjects);


        } catch (Exception e) {
            e.printStackTrace();
            System.out.println("Erreur lors de la lecture du fichier .ser: " + e.getMessage());
        }
                
        
    }
    
 
    
}
package RN.tests;

import java.awt.Color;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.image.BufferedImage;
import java.awt.image.Kernel;
import java.io.File;
import java.io.IOException;

import javax.imageio.ImageIO;

import org.junit.Test;

import RN.linkage.GaborFilter;

/**
 * The test class for GaborFilter class
 */
public class GaborFilterTest {

   /**
    * A Gabor filter test
    *
    * @throws IOException - IOException
    */
   @Test
   public void testImage() throws IOException {

      Image imageLena = ImageIO.read(new File("./src/test/resources/lena.jpg"));
      
      GaborFilter gabor = null;
      Kernel kernel = null;
      
      File file = null;
      
      int orientationCount = 8;
      File fileFilter = null;
      BufferedImage bufferedImage = null;
      Graphics g = null;
      
      double[] orientations = new double[1];
      int angle;
      for(Integer orientationId=0; orientationId < orientationCount; orientationId++){
    	  
    	  angle = (int) ((360 / orientationCount) * orientationId);
    	  
    	  // Specifying the files
          file = new File("./src/test/resources/gaborred-lena-" + angle + ".jpg");
          fileFilter = new File("./src/test/resources/filter-" + angle + ".jpg");
          
    	  orientations[0] = (Math.PI / orientationCount) * orientationId;
    	  
	      // Creating buffered image from the given file. NOTE: It's crucial to build the data that way!
	      bufferedImage = new BufferedImage((int) imageLena.getWidth(null), imageLena.getHeight(null), BufferedImage.TYPE_INT_RGB);
	      g = bufferedImage.getGraphics();
	      g.drawImage(imageLena, 0, 0, null);
	      
	      
	      // Writing the filtered image to disk
	      gabor = new GaborFilter(16, orientations, 0, 0.5, 1, 7, 7);
	      ImageIO.write(gabor.filter(bufferedImage, null), "jpg", file);
	      
	      
    	  kernel = gabor.getKernel();
    	  
	      BufferedImage bufferedImageFilter = new BufferedImage(kernel.getWidth(), kernel.getHeight(), BufferedImage.TYPE_INT_RGB);
	      float data[] = kernel.getKernelData(null);
	      for(int x=0; x < kernel.getWidth(); x++){
	    	  for(int y=0; y < kernel.getWidth(); y++){
	    		  bufferedImageFilter.setRGB(x, y, Color.HSBtoRGB(1.2f, 1.0f, data[x*y + y]));
	    	  }
	      }
	      ImageIO.write(bufferedImageFilter, "jpg", fileFilter);
	      
      }
      
   }
   
   
   @Test
   public void testImage2() throws IOException {
	   // Specifying the files
	   File file = new File("./src/test/resources/gaborred-lena.jpg");
	   Image image = ImageIO.read(new File("./src/test/resources/lena.jpg"));
	
	   // Creating buffered image from the given file. NOTE: It's crucial to build the data that way!
	   BufferedImage bufferedImage = new BufferedImage(image.getWidth(null), image.getHeight(null), BufferedImage.TYPE_INT_RGB);
	   Graphics g = bufferedImage.getGraphics();
	   g.drawImage(image, 0, 0, null);
	
	   // Writing the filtered image to disk
	   GaborFilter gabor = new GaborFilter(16, new double[] {0, Math.PI/4, Math.PI}, 0, 0.5, 1, 3, 3);
	   ImageIO.write(gabor.filter(bufferedImage, null), "jpg", file);
   }
}package RN.tests;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import RN.Area;
import RN.AreaSquare;
import RN.ENetworkImplementation;
import RN.ILayer;
import RN.Layer;
import RN.Network;
import RN.algoactivations.EActivation;
import RN.linkage.ELinkage;
import RN.linkage.OneToOneFetchOctaveAreaLinkage;
import RN.linkage.vision.KeyPoint;
import RN.nodes.ENodeType;
import RN.nodes.PixelNode;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.image.Image;
import javafx.scene.image.PixelReader;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class HessianCourbureTest extends Application{

	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		
		Thread t = new Thread("JavaFX Init Thread") {
	        public void run() {
	        	
	        	Application.launch(TestImageNode.class, new String[0]);
	        }
	    };
	    t.setDaemon(true);
	    t.start();
	    Thread.sleep(1000);
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
	}

	@Before
	public void setUp() throws Exception {
	}

	@After
	public void tearDown() throws Exception {
	}
	
	@Test
	public void testCourbure()  {
		
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
		
				int nbPixels = 10000;
				int pixelGaussianNodes = 10000;
				
				Network net = Network.getInstance(ENetworkImplementation.UNLINKED);
				
				AreaSquare inArea = new AreaSquare(nbPixels, true);
				Layer inLayer = new Layer(inArea);
				
				AreaSquare hiddenArea = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer = new Layer(hiddenArea);
				
//				Area hidden2Area = new Area(nbPixels, true);
//				Layer hidden2Layer = new Layer(hidden2Area);
				
				AreaSquare outArea = new AreaSquare(1, true);
				ILayer outLayer = new Layer(outArea);
				net.addLayer(inLayer, hiddenLayer, outLayer);
				
				inArea.configureLinkage(ELinkage.ONE_TO_ONE, null, false);
				inArea.configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
				
				double k = 1.6D;
				//double k = 1.106D;
				double f = 2D;
				hiddenArea.configureLinkage(ELinkage.DOG, null, false, f * Math.pow(k, 5D), f * 1D).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(pixelGaussianNodes);
				
				//hidden2Area.configureLinkage(ELinkage.HESSIAN_COURBURE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.GAUSSIAN).createNodes(pixelGaussianNodes);
				
				outArea.configureLinkage(ELinkage.ONE_TO_ONE_FETCH_OCTAVE_AREA, null, false).configureNode( false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(pixelGaussianNodes);

				
				
				net.finalizeConnections();
				
				//Image noir et blanc en input
				System.out.println("Begin lecture image ...");
				PixelNode pixNode = null;
				Image image = new Image("file:D:\\git\\deepnet\\resources\\clochers.jpg");
				PixelReader pixelReader = image.getPixelReader();
				for(int idx = 0; idx < nbPixels; idx++){
					pixNode = (PixelNode) inArea.getNode(idx);
					Color color = pixelReader.getColor(pixNode.getX(), pixNode.getY());
					pixNode.setEntry(color.getBrightness());
					
				}
				System.out.println("End lecture image.");
				
				try {
					net.propagation(false);
				} catch (Exception e) {
					e.printStackTrace();
				}
				
				for(KeyPoint point : ((OneToOneFetchOctaveAreaLinkage)outArea.getLinkage()).getKeyPoints()){
					System.out.println(point);
				}
				
				//net.getNode(1, 0, 5050).getArea().filterToString(FilterLinkage.ID_FILTER_LOG);
				//net.getNode(1, 0, 5050).getArea().filterToString(1);
				
		
			}});
		
		try {
			Thread.sleep(500000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
	}
	
	@Test
	public void testArcTan2(){
	
		for(int idy = -3; idy <= 3; idy++){
			for(int idx = -3; idx <= 3; idx++){
				System.out.println("x=" + idx + " y=" + idy + " theta=" + (Math.atan2(idy, idx) * 180D) / Math.PI);
			}
		}
		
	}
	
	@Override
	public void start(Stage primaryStage) throws Exception {
		// TODO Auto-generated method stub
		
	}
}
package RN.tests.jocl;

/*
 * JOCL - Java bindings for OpenCL
 * 
 * Copyright 2009 Marco Hutter - http://www.jocl.org/
 */

import static org.jocl.CL.*;

import java.io.*;
import java.util.Random;

import org.jocl.*;

/**
 * This class is a port of the NVIDIA OpenCL SDK "Histogram" sample.
 * The structure of the code has intentionally been kept close 
 * to the original sample.  
 */
public class HistogramNVIDIA
{
    public static final int HISTOGRAM256_BIN_COUNT = 256;
    
    //OpenCL histogram256 program
    static cl_program cpHistogram256;

    //OpenCL histogram256 kernels
    static cl_kernel ckHistogram256, ckMergeHistogram256;

    //histogram256() intermediate results buffer
    static int PARTIAL_HISTOGRAM256_COUNT = 240;
    static cl_mem d_PartialHistograms;

    //Default command queue for histogram256 kernels
    static cl_command_queue cqDefaultCommandQue;

    
    
    ////////////////////////////////////////////////////////////////////////////////
    //Test driver
    ////////////////////////////////////////////////////////////////////////////////
    public static void main(String args[])
    {
      cl_context       cxGPUContext; //OpenCL context
      cl_command_queue cqCommandQue; //OpenCL command que
      cl_mem    d_Data, d_Histogram; //OpenCL memory buffer objects

      long dataBytes[] = new long[1];
      int ciErrNum[] = new int[1];
      int PassFailFlag = 1;

      byte h_Data[];
      int h_HistogramCPU[], h_HistogramGPU[];
      
      int byteCount = 128 * 8192;

      // start logs
      System.out.println("Starting...\n"); 

      System.out.println("Initializing data...");
      h_Data         = new byte[byteCount];
      h_HistogramCPU = new int[HISTOGRAM256_BIN_COUNT];
      h_HistogramGPU = new int[HISTOGRAM256_BIN_COUNT];
      
      Random random = new Random(2009);
      for(int i = 0; i < byteCount; i++)
          h_Data[i] = (byte)(random.nextInt() & 0xFF);

      // This will allow us to subsequently omit the "shrCheckError" calls for this sample
      CL.setExceptionsEnabled(true);
      
      System.out.println("Initializing OpenCL...");

      // Obtain the platform IDs and initialize the context properties
      cl_platform_id platforms[] = new cl_platform_id[1];
      clGetPlatformIDs(platforms.length, platforms, null);
      cl_context_properties contextProperties = new cl_context_properties();
      contextProperties.addProperty(CL_CONTEXT_PLATFORM, platforms[0]);
      cxGPUContext = clCreateContextFromType(contextProperties, CL_DEVICE_TYPE_GPU, null, null, ciErrNum);

      // get the list of GPU devices associated with context
      clGetContextInfo(cxGPUContext, CL_CONTEXT_DEVICES, 0, null, dataBytes);
      cl_device_id cdDevices[] = new cl_device_id[(int)dataBytes[0] / Sizeof.cl_device_id];
      
      clGetContextInfo(cxGPUContext, CL_CONTEXT_DEVICES, dataBytes[0], Pointer.to(cdDevices), null);

      //Create a command-queue
      cqCommandQue = clCreateCommandQueue(cxGPUContext, cdDevices[0], 0, ciErrNum);

      System.out.println("Allocating OpenCL memory...\n");
      d_Data = clCreateBuffer(cxGPUContext, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, byteCount * Sizeof.cl_char, Pointer.to(h_Data), ciErrNum);
      d_Histogram = clCreateBuffer(cxGPUContext, CL_MEM_READ_WRITE, HISTOGRAM256_BIN_COUNT * Sizeof.cl_int, null, ciErrNum);

      System.out.println("Initializing 256-bin OpenCL histogram...");
      initHistogram256(cxGPUContext, cqCommandQue);

      System.out.printf("Running 256-bin OpenCL histogram for %d bytes...\n", byteCount);
      histogram256(null, d_Histogram, d_Data, byteCount);

      System.out.println("Validating OpenCL results...");
      System.out.println("...reading back OpenCL results");
      clEnqueueReadBuffer(cqCommandQue, d_Histogram, CL_TRUE, 0, HISTOGRAM256_BIN_COUNT * Sizeof.cl_int, Pointer.to(h_HistogramGPU), 0, null, null);

      System.out.println("...histogram256CPU()");

      histogram256CPU(h_HistogramCPU, h_Data, byteCount);

      for(int i = 0; i < HISTOGRAM256_BIN_COUNT; i++)
      {
          if(h_HistogramGPU[i] != h_HistogramCPU[i])
          {
              PassFailFlag = 0;
          }
      }
      System.out.println(PassFailFlag != 0 ? "256-bin histograms match\n" : "***256-bin histograms do not match!!!***\n" );

      System.out.println("Shutting down 256-bin OpenCL histogram...\n\n"); 

      //Release kernels and program
      closeHistogram256();

      // pass or fail
      System.out.printf("TEST %s\n", PassFailFlag != 0 ? "PASSED" : "FAILED !!!");

      System.out.println("Shutting down...");

      //Release other OpenCL Objects
      ciErrNum[0]  = clReleaseMemObject(d_Histogram);
      ciErrNum[0] |= clReleaseMemObject(d_Data);
      ciErrNum[0] |= clReleaseCommandQueue(cqCommandQue);
      ciErrNum[0] |= clReleaseContext(cxGPUContext);
    }
    
    
    static void histogram256CPU(int h_Histogram[], byte h_Data[], int byteCount)
    {
        for(int i = 0; i < HISTOGRAM256_BIN_COUNT; i++)
            h_Histogram[i] = 0;

        for(int i = 0; i < byteCount; i++){
            int data = h_Data[i];
            if (data < 0)
            {
                data+=256;
            }
            h_Histogram[data]++;
        }
    }
    

    ////////////////////////////////////////////////////////////////////////////////
    // OpenCL launchers for histogram256 / mergeHistogram256 kernels
    ////////////////////////////////////////////////////////////////////////////////

    static void initHistogram256(cl_context cxGPUContext, cl_command_queue cqParamCommandQue)
    {
        int ciErrNum[] = new int[1];

        System.out.println("...loading Histogram256.cl");
        String cHistogram256 = readFile("/Users/ericmarchand/Documents/workspace_neural/RN/src/RN/tests/jocl/kernels/Histogram256.cl");

        System.out.println("...creating histogram256 program");
        cpHistogram256 = clCreateProgramWithSource(cxGPUContext, 1, new String[]{cHistogram256}, new long[]{cHistogram256.length()}, ciErrNum);
        
        System.out.println("...building histogram256 program");
        ciErrNum[0] = clBuildProgram(cpHistogram256, 0, null, null, null, null);

        System.out.println("...creating histogram256 kernels");
        ckHistogram256 = clCreateKernel(cpHistogram256, "histogram256", ciErrNum);
        ckMergeHistogram256 = clCreateKernel(cpHistogram256, "mergeHistogram256", ciErrNum);

        System.out.println("...allocating internal histogram256 buffer");
        d_PartialHistograms = clCreateBuffer(cxGPUContext, CL_MEM_READ_WRITE, PARTIAL_HISTOGRAM256_COUNT * HISTOGRAM256_BIN_COUNT * Sizeof.cl_uint, null, ciErrNum);

        //Save default command queue
        cqDefaultCommandQue = cqParamCommandQue;
    }

    static void closeHistogram256()
    {
        clReleaseMemObject(d_PartialHistograms);
        clReleaseKernel(ckMergeHistogram256);
        clReleaseKernel(ckHistogram256);
        clReleaseProgram(cpHistogram256);
    }

    static void histogram256(cl_command_queue cqCommandQue, cl_mem d_Histogram, cl_mem d_Data, int byteCount)
    {
        long localWorkSize[] = new long[1];
        long globalWorkSize[] = new long[1];

        if(cqCommandQue == null)
            cqCommandQue = cqDefaultCommandQue;

        int WARP_SIZE = 32;
        int WARP_COUNT = 6;

        int dataCount = byteCount / 4;
        clSetKernelArg(ckHistogram256, 0, Sizeof.cl_mem,  Pointer.to(d_PartialHistograms));
        clSetKernelArg(ckHistogram256, 1, Sizeof.cl_mem,  Pointer.to(d_Data));
        clSetKernelArg(ckHistogram256, 2, Sizeof.cl_uint, Pointer.to(new int[]{dataCount}));

        localWorkSize[0]  = WARP_SIZE * WARP_COUNT;
        globalWorkSize[0] = PARTIAL_HISTOGRAM256_COUNT * localWorkSize[0];

        clEnqueueNDRangeKernel(cqCommandQue, ckHistogram256, 1, null, globalWorkSize, localWorkSize, 0, null, null);

        int MERGE_WORKGROUP_SIZE = 256;
        clSetKernelArg(ckMergeHistogram256, 0, Sizeof.cl_mem,  Pointer.to(d_Histogram));
        clSetKernelArg(ckMergeHistogram256, 1, Sizeof.cl_mem,  Pointer.to(d_PartialHistograms));
        clSetKernelArg(ckMergeHistogram256, 2, Sizeof.cl_uint, Pointer.to(new int[]{PARTIAL_HISTOGRAM256_COUNT}));

        localWorkSize[0]  = MERGE_WORKGROUP_SIZE;
        globalWorkSize[0] = HISTOGRAM256_BIN_COUNT * localWorkSize[0];

        clEnqueueNDRangeKernel(cqCommandQue, ckMergeHistogram256, 1, null, globalWorkSize, localWorkSize, 0, null, null);
    }

    
    private static String readFile(String fileName)
    {
        try
        {
            BufferedReader br = new BufferedReader(new FileReader(fileName));
            StringBuilder sb = new StringBuilder();
            String line = null;
            while (true)
            {
                line = br.readLine();
                if (line == null)
                {
                    break;
                }
                sb.append(line+"\n");
            }
            return sb.toString();
        }
        catch (IOException e)
        {
            e.printStackTrace();
            return "";
        }
    }
    
}package RN.tests.jocl;

/*
 * JOCL - Java bindings for OpenCL
 *
 * Copyright 2010 Marco Hutter - http://www.jocl.org/
 */

import static org.jocl.CL.*;

import java.nio.*;
import java.util.*;

import org.jocl.*;

/**
 * A JOCL program that queries and prints information about all
 * available devices.
 */
public class JOCLDeviceQuery
{
    /**
     * The entry point of this program
     *
     * @param args Not used
     */
    public static void main(String args[])
    {
        // Obtain the number of platforms
        int numPlatforms[] = new int[1];
        clGetPlatformIDs(0, null, numPlatforms);

        System.out.println("Number of platforms: "+numPlatforms[0]);

        // Obtain the platform IDs
        cl_platform_id platforms[] = new cl_platform_id[numPlatforms[0]];
        clGetPlatformIDs(platforms.length, platforms, null);

        // Collect all devices of all platforms
        List<cl_device_id> devices = new ArrayList<cl_device_id>();
        for (int i=0; i<platforms.length; i++)
        {
            String platformName = getString(platforms[i], CL_PLATFORM_NAME);

            // Obtain the number of devices for the current platform
            int numDevices[] = new int[1];
            clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_ALL, 0, null, numDevices);

            System.out.println("Number of devices in platform "+platformName+": "+numDevices[0]);

            cl_device_id devicesArray[] = new cl_device_id[numDevices[0]];
            clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_ALL, numDevices[0], devicesArray, null);

            devices.addAll(Arrays.asList(devicesArray));
        }

        // Print the infos about all devices
        for (cl_device_id device : devices)
        {
            // CL_DEVICE_NAME
            String deviceName = getString(device, CL_DEVICE_NAME);
            System.out.println("--- Info for device "+deviceName+": ---");
            System.out.printf("CL_DEVICE_NAME: \t\t\t%s\n", deviceName);

            // CL_DEVICE_VENDOR
            String deviceVendor = getString(device, CL_DEVICE_VENDOR);
            System.out.printf("CL_DEVICE_VENDOR: \t\t\t%s\n", deviceVendor);

            // CL_DRIVER_VERSION
            String driverVersion = getString(device, CL_DRIVER_VERSION);
            System.out.printf("CL_DRIVER_VERSION: \t\t\t%s\n", driverVersion);

            // CL_DEVICE_TYPE
            long deviceType = getLong(device, CL_DEVICE_TYPE);
            if( (deviceType & CL_DEVICE_TYPE_CPU) != 0)
                System.out.printf("CL_DEVICE_TYPE:\t\t\t\t%s\n", "CL_DEVICE_TYPE_CPU");
            if( (deviceType & CL_DEVICE_TYPE_GPU) != 0)
                System.out.printf("CL_DEVICE_TYPE:\t\t\t\t%s\n", "CL_DEVICE_TYPE_GPU");
            if( (deviceType & CL_DEVICE_TYPE_ACCELERATOR) != 0)
                System.out.printf("CL_DEVICE_TYPE:\t\t\t\t%s\n", "CL_DEVICE_TYPE_ACCELERATOR");
            if( (deviceType & CL_DEVICE_TYPE_DEFAULT) != 0)
                System.out.printf("CL_DEVICE_TYPE:\t\t\t\t%s\n", "CL_DEVICE_TYPE_DEFAULT");

            // CL_DEVICE_MAX_COMPUTE_UNITS
            int maxComputeUnits = getInt(device, CL_DEVICE_MAX_COMPUTE_UNITS);
            System.out.printf("CL_DEVICE_MAX_COMPUTE_UNITS:\t\t%d\n", maxComputeUnits);

            // CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS
            long maxWorkItemDimensions = getLong(device, CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS);
            System.out.printf("CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS:\t%d\n", maxWorkItemDimensions);

            // CL_DEVICE_MAX_WORK_ITEM_SIZES
            long maxWorkItemSizes[] = getSizes(device, CL_DEVICE_MAX_WORK_ITEM_SIZES, 3);
            System.out.printf("CL_DEVICE_MAX_WORK_ITEM_SIZES:\t\t%d / %d / %d \n",
                maxWorkItemSizes[0], maxWorkItemSizes[1], maxWorkItemSizes[2]);

            // CL_DEVICE_MAX_WORK_GROUP_SIZE
            long maxWorkGroupSize = getSize(device, CL_DEVICE_MAX_WORK_GROUP_SIZE);
            System.out.printf("CL_DEVICE_MAX_WORK_GROUP_SIZE:\t\t%d\n", maxWorkGroupSize);

            // CL_DEVICE_MAX_CLOCK_FREQUENCY
            long maxClockFrequency = getLong(device, CL_DEVICE_MAX_CLOCK_FREQUENCY);
            System.out.printf("CL_DEVICE_MAX_CLOCK_FREQUENCY:\t\t%d MHz\n", maxClockFrequency);

            // CL_DEVICE_ADDRESS_BITS
            int addressBits = getInt(device, CL_DEVICE_ADDRESS_BITS);
            System.out.printf("CL_DEVICE_ADDRESS_BITS:\t\t\t%d\n", addressBits);

            // CL_DEVICE_MAX_MEM_ALLOC_SIZE
            long maxMemAllocSize = getLong(device, CL_DEVICE_MAX_MEM_ALLOC_SIZE);
            System.out.printf("CL_DEVICE_MAX_MEM_ALLOC_SIZE:\t\t%d MByte\n", (int)(maxMemAllocSize / (1024 * 1024)));

            // CL_DEVICE_GLOBAL_MEM_SIZE
            long globalMemSize = getLong(device, CL_DEVICE_GLOBAL_MEM_SIZE);
            System.out.printf("CL_DEVICE_GLOBAL_MEM_SIZE:\t\t%d MByte\n", (int)(globalMemSize / (1024 * 1024)));

            // CL_DEVICE_ERROR_CORRECTION_SUPPORT
            int errorCorrectionSupport = getInt(device, CL_DEVICE_ERROR_CORRECTION_SUPPORT);
            System.out.printf("CL_DEVICE_ERROR_CORRECTION_SUPPORT:\t%s\n", errorCorrectionSupport != 0 ? "yes" : "no");

            // CL_DEVICE_LOCAL_MEM_TYPE
            int localMemType = getInt(device, CL_DEVICE_LOCAL_MEM_TYPE);
            System.out.printf("CL_DEVICE_LOCAL_MEM_TYPE:\t\t%s\n", localMemType == 1 ? "local" : "global");

            // CL_DEVICE_LOCAL_MEM_SIZE
            long localMemSize = getLong(device, CL_DEVICE_LOCAL_MEM_SIZE);
            System.out.printf("CL_DEVICE_LOCAL_MEM_SIZE:\t\t%d KByte\n", (int)(localMemSize / 1024));

            // CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE
            long maxConstantBufferSize = getLong(device, CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE);
            System.out.printf("CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE:\t%d KByte\n", (int)(maxConstantBufferSize / 1024));

            // CL_DEVICE_QUEUE_PROPERTIES
            long queueProperties = getLong(device, CL_DEVICE_QUEUE_PROPERTIES);
            if(( queueProperties & CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE ) != 0)
                System.out.printf("CL_DEVICE_QUEUE_PROPERTIES:\t\t%s\n", "CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE");
            if(( queueProperties & CL_QUEUE_PROFILING_ENABLE ) != 0)
                System.out.printf("CL_DEVICE_QUEUE_PROPERTIES:\t\t%s\n", "CL_QUEUE_PROFILING_ENABLE");

            // CL_DEVICE_IMAGE_SUPPORT
            int imageSupport = getInt(device, CL_DEVICE_IMAGE_SUPPORT);
            System.out.printf("CL_DEVICE_IMAGE_SUPPORT:\t\t%d\n", imageSupport);

            // CL_DEVICE_MAX_READ_IMAGE_ARGS
            int maxReadImageArgs = getInt(device, CL_DEVICE_MAX_READ_IMAGE_ARGS);
            System.out.printf("CL_DEVICE_MAX_READ_IMAGE_ARGS:\t\t%d\n", maxReadImageArgs);

            // CL_DEVICE_MAX_WRITE_IMAGE_ARGS
            int maxWriteImageArgs = getInt(device, CL_DEVICE_MAX_WRITE_IMAGE_ARGS);
            System.out.printf("CL_DEVICE_MAX_WRITE_IMAGE_ARGS:\t\t%d\n", maxWriteImageArgs);

            // CL_DEVICE_SINGLE_FP_CONFIG
            long singleFpConfig = getLong(device, CL_DEVICE_SINGLE_FP_CONFIG);
            System.out.printf("CL_DEVICE_SINGLE_FP_CONFIG:\t\t%s\n",
                stringFor_cl_device_fp_config(singleFpConfig));

            // CL_DEVICE_IMAGE2D_MAX_WIDTH
            long image2dMaxWidth = getSize(device, CL_DEVICE_IMAGE2D_MAX_WIDTH);
            System.out.printf("CL_DEVICE_2D_MAX_WIDTH\t\t\t%d\n", image2dMaxWidth);

            // CL_DEVICE_IMAGE2D_MAX_HEIGHT
            long image2dMaxHeight = getSize(device, CL_DEVICE_IMAGE2D_MAX_HEIGHT);
            System.out.printf("CL_DEVICE_2D_MAX_HEIGHT\t\t\t%d\n", image2dMaxHeight);

            // CL_DEVICE_IMAGE3D_MAX_WIDTH
            long image3dMaxWidth = getSize(device, CL_DEVICE_IMAGE3D_MAX_WIDTH);
            System.out.printf("CL_DEVICE_3D_MAX_WIDTH\t\t\t%d\n", image3dMaxWidth);

            // CL_DEVICE_IMAGE3D_MAX_HEIGHT
            long image3dMaxHeight = getSize(device, CL_DEVICE_IMAGE3D_MAX_HEIGHT);
            System.out.printf("CL_DEVICE_3D_MAX_HEIGHT\t\t\t%d\n", image3dMaxHeight);

            // CL_DEVICE_IMAGE3D_MAX_DEPTH
            long image3dMaxDepth = getSize(device, CL_DEVICE_IMAGE3D_MAX_DEPTH);
            System.out.printf("CL_DEVICE_3D_MAX_DEPTH\t\t\t%d\n", image3dMaxDepth);

            // CL_DEVICE_PREFERRED_VECTOR_WIDTH_<type>
            System.out.printf("CL_DEVICE_PREFERRED_VECTOR_WIDTH_<t>\t");
            int preferredVectorWidthChar = getInt(device, CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR);
            int preferredVectorWidthShort = getInt(device, CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT);
            int preferredVectorWidthInt = getInt(device, CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT);
            int preferredVectorWidthLong = getInt(device, CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG);
            int preferredVectorWidthFloat = getInt(device, CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT);
            int preferredVectorWidthDouble = getInt(device, CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE);
            System.out.printf("CHAR %d, SHORT %d, INT %d, LONG %d, FLOAT %d, DOUBLE %d\n\n\n",
                   preferredVectorWidthChar, preferredVectorWidthShort,
                   preferredVectorWidthInt, preferredVectorWidthLong,
                   preferredVectorWidthFloat, preferredVectorWidthDouble);
        }
    }

    /**
     * Returns the value of the device info parameter with the given name
     *
     * @param device The device
     * @param paramName The parameter name
     * @return The value
     */
    private static int getInt(cl_device_id device, int paramName)
    {
        return getInts(device, paramName, 1)[0];
    }

    /**
     * Returns the values of the device info parameter with the given name
     *
     * @param device The device
     * @param paramName The parameter name
     * @param numValues The number of values
     * @return The value
     */
    private static int[] getInts(cl_device_id device, int paramName, int numValues)
    {
        int values[] = new int[numValues];
        clGetDeviceInfo(device, paramName, Sizeof.cl_int * numValues, Pointer.to(values), null);
        return values;
    }

    /**
     * Returns the value of the device info parameter with the given name
     *
     * @param device The device
     * @param paramName The parameter name
     * @return The value
     */
    private static long getLong(cl_device_id device, int paramName)
    {
        return getLongs(device, paramName, 1)[0];
    }

    /**
     * Returns the values of the device info parameter with the given name
     *
     * @param device The device
     * @param paramName The parameter name
     * @param numValues The number of values
     * @return The value
     */
    private static long[] getLongs(cl_device_id device, int paramName, int numValues)
    {
        long values[] = new long[numValues];
        clGetDeviceInfo(device, paramName, Sizeof.cl_long * numValues, Pointer.to(values), null);
        return values;
    }

    /**
     * Returns the value of the device info parameter with the given name
     *
     * @param device The device
     * @param paramName The parameter name
     * @return The value
     */
    private static String getString(cl_device_id device, int paramName)
    {
        // Obtain the length of the string that will be queried
        long size[] = new long[1];
        clGetDeviceInfo(device, paramName, 0, null, size);

        // Create a buffer of the appropriate size and fill it with the info
        byte buffer[] = new byte[(int)size[0]];
        clGetDeviceInfo(device, paramName, buffer.length, Pointer.to(buffer), null);

        // Create a string from the buffer (excluding the trailing \0 byte)
        return new String(buffer, 0, buffer.length-1);
    }

    /**
     * Returns the value of the platform info parameter with the given name
     *
     * @param platform The platform
     * @param paramName The parameter name
     * @return The value
     */
    private static String getString(cl_platform_id platform, int paramName)
    {
        // Obtain the length of the string that will be queried
        long size[] = new long[1];
        clGetPlatformInfo(platform, paramName, 0, null, size);

        // Create a buffer of the appropriate size and fill it with the info
        byte buffer[] = new byte[(int)size[0]];
        clGetPlatformInfo(platform, paramName, buffer.length, Pointer.to(buffer), null);

        // Create a string from the buffer (excluding the trailing \0 byte)
        return new String(buffer, 0, buffer.length-1);
    }
    
    /**
     * Returns the value of the device info parameter with the given name
     *
     * @param device The device
     * @param paramName The parameter name
     * @return The value
     */
    private static long getSize(cl_device_id device, int paramName)
    {
        return getSizes(device, paramName, 1)[0];
    }
    
    /**
     * Returns the values of the device info parameter with the given name
     *
     * @param device The device
     * @param paramName The parameter name
     * @param numValues The number of values
     * @return The value
     */
    static long[] getSizes(cl_device_id device, int paramName, int numValues)
    {
        // The size of the returned data has to depend on 
        // the size of a size_t, which is handled here
        ByteBuffer buffer = ByteBuffer.allocate(
            numValues * Sizeof.size_t).order(ByteOrder.nativeOrder());
        clGetDeviceInfo(device, paramName, Sizeof.size_t * numValues, 
            Pointer.to(buffer), null);
        long values[] = new long[numValues];
        if (Sizeof.size_t == 4)
        {
            for (int i=0; i<numValues; i++)
            {
                values[i] = buffer.getInt(i * Sizeof.size_t);
            }
        }
        else
        {
            for (int i=0; i<numValues; i++)
            {
                values[i] = buffer.getLong(i * Sizeof.size_t);
            }
        }
        return values;
    }
    
}package RN.tests.jocl;

/*
 * JOCL - Java bindings for OpenCL
 * 
 * Copyright 2009 Marco Hutter - http://www.jocl.org/
 */

import static org.jocl.CL.*;

import java.awt.*;
import java.awt.event.*;
import java.awt.geom.*;
import java.awt.image.*;
import java.io.*;
import java.util.*;
import java.util.List;

import javax.imageio.ImageIO;
import javax.swing.*;

import org.jocl.*;

/**
 * A class that shows how a simple OpenCL implementation of a convolution may be
 * used as a BufferedImageOp that serves as a hot-swap-replacement of the Java
 * ConvolveOp.
 */
public class JOCLSimpleConvolution {
	/**
	 * Entry point for this sample.
	 * 
	 * @param args
	 *            not used
	 */
	public static void main(String args[]) {
		SwingUtilities.invokeLater(new Runnable() {
			public void run() {
				new JOCLSimpleConvolution();
			}
		});
	}

	/**
	 * Creates a BufferedImage of with type TYPE_INT_RGB from the file with the
	 * given name.
	 * 
	 * @param fileName
	 *            The file name
	 * @return The image, or null if the file may not be read
	 */
	private static BufferedImage createBufferedImage(String fileName) {
		BufferedImage image = null;
		try {
			image = ImageIO.read(new File(fileName));
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}

		int sizeX = image.getWidth();
		int sizeY = image.getHeight();

		BufferedImage result = new BufferedImage(sizeX, sizeY, BufferedImage.TYPE_INT_RGB);
		Graphics g = result.createGraphics();
		g.drawImage(image, 0, 0, null);
		g.dispose();
		return result;
	}

	/**
	 * The JLabel which will display the computation time for Java
	 */
	private JLabel javaTimeLabel;

	/**
	 * The JLabel which will display the computation time for JOCL
	 */
	private JLabel joclTimeLabel;

	/**
	 * The input image to which the convolution will be applied
	 */
	private BufferedImage inputImage;

	/**
	 * The convoluted output image which is computed with Java
	 */
	private BufferedImage outputImage0;

	/**
	 * The convoluted output image which is computed with JOCL
	 */
	private BufferedImage outputImage1;

	/**
	 * The list of available kernels (not OpenCL kernels, but
	 * java.awt.image.Kernel objects - the convolution kernels...)
	 */
	private List<Kernel> kernels;

	/**
	 * The list of names of the kernels which are displayed in a combo box
	 */
	private List<String> kernelNames;

	/**
	 * Creates the JOCLSimpleConvolution sample
	 */
	public JOCLSimpleConvolution() {
		// Read the input image file and create the output images
		String fileName = "/Users/ericmarchand/Documents/workspace_neural/RN/src/RN/tests/jocl/images/lena512color.png";
		// fileName = "data/Porsche-14.jpg";

		inputImage = createBufferedImage(fileName);
		int sizeX = inputImage.getWidth();
		int sizeY = inputImage.getHeight();

		outputImage0 = new BufferedImage(sizeX, sizeY, BufferedImage.TYPE_INT_RGB);
		outputImage1 = new BufferedImage(sizeX, sizeY, BufferedImage.TYPE_INT_RGB);

		// Initialize the convolution kernels
		initKernels();

		final JPanel mainPanel = new JPanel(new GridLayout(1, 0));
		JPanel panel = null;

		// Create the panel containing the input image and the combo box
		// for selecting the kernel
		final JComboBox kernelComboBox = new JComboBox(kernelNames.toArray());
		kernelComboBox.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				int index = kernelComboBox.getSelectedIndex();
				Kernel kernel = kernels.get(index);
				applyKernel(kernel);
				mainPanel.repaint();
			}
		});
		panel = new JPanel(new BorderLayout());
		panel.add(new JLabel(new ImageIcon(inputImage)), BorderLayout.CENTER);
		panel.add(kernelComboBox, BorderLayout.NORTH);
		mainPanel.add(panel);

		// Create the panel containing the Java output image and time label
		javaTimeLabel = new JLabel();
		javaTimeLabel.setPreferredSize(kernelComboBox.getPreferredSize());
		panel = new JPanel(new BorderLayout());
		panel.add(new JLabel(new ImageIcon(outputImage0)), BorderLayout.CENTER);
		panel.add(javaTimeLabel, BorderLayout.NORTH);
		mainPanel.add(panel);

		// Create the panel containing the JOCL output image and time label
		joclTimeLabel = new JLabel();
		joclTimeLabel.setPreferredSize(kernelComboBox.getPreferredSize());
		panel = new JPanel(new BorderLayout());
		panel.add(new JLabel(new ImageIcon(outputImage1)), BorderLayout.CENTER);
		panel.add(joclTimeLabel, BorderLayout.NORTH);
		mainPanel.add(panel);

		// Create the main frame
		JFrame frame = new JFrame("JOCL Simple Convolution");
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.setLayout(new BorderLayout());
		frame.add(mainPanel, BorderLayout.CENTER);
		frame.pack();
		frame.setVisible(true);

		kernelComboBox.setSelectedIndex(0);
	}

	/**
	 * Apply the given kernel to the input image, once using a Java ConvolveOp,
	 * and once using a JOCLConvolveOp
	 * 
	 * @param kernel
	 *            The kernel to apply
	 */
	private void applyKernel(Kernel kernel) {
		long before = 0;
		long after = 0;
		double durationMS = 0;
		String message = null;

		// Apply the ConvolveOp and update the timing information
		BufferedImageOp bop = new ConvolveOp(kernel);
		before = System.nanoTime();
		outputImage0 = bop.filter(inputImage, outputImage0);
		after = System.nanoTime();
		durationMS = (after - before) / 1e6;
		message = "Java: " + String.format("%.2f", durationMS) + " ms";
		System.out.println(message);
		javaTimeLabel.setText(message);

		// Apply the JOCLConvolveOp and update the timing information
		JOCLConvolveOp jop = JOCLConvolveOp.create(kernel);
		before = System.nanoTime();
		outputImage1 = jop.filter(inputImage, outputImage1);
		after = System.nanoTime();
		durationMS = (after - before) / 1e6;
		message = "JOCL: " + String.format("%.2f", durationMS) + " ms";
		System.out.println(message);
		joclTimeLabel.setText(message);
		jop.shutdown();
	}

	/**
	 * Initialize the list of available kernels and the list containing their
	 * names, which will be displayed in the combo box
	 */
	private void initKernels() {
		kernels = new ArrayList<Kernel>();
		kernelNames = new ArrayList<String>();

		int kernelSizeX = 0;
		int kernelSizeY = 0;
		float kernelData[] = null;

		// Edge detection
		kernelSizeX = 3;
		kernelSizeY = 3;
		kernelData = new float[] { -1, 0, -1, 0, 4, 0, -1, 0, -1 };
		kernels.add(new Kernel(kernelSizeX, kernelSizeY, kernelData));
		kernelNames.add("Edge detection");

		// Sharpen
		kernelSizeX = 3;
		kernelSizeY = 3;
		kernelData = new float[] { -1, 0, -1, 0, 5, 0, -1, 0, -1 };
		kernels.add(new Kernel(kernelSizeX, kernelSizeY, kernelData));
		kernelNames.add("Sharpen");

		// Blur
		for (int i = 3; i <= 21; i += 2) {
			initBlurKernel(i);
		}
	}

	/**
	 * Create a blur kernel with the given size, and add the kernel and its name
	 * to the respective lists.
	 */
	private void initBlurKernel(int kernelSize) {
		int kernelSizeX = kernelSize;
		int kernelSizeY = kernelSize;
		int size = kernelSizeX * kernelSizeY;
		float value = 1.0f / size;
		float kernelData[] = new float[size];
		for (int i = 0; i < size; i++) {
			kernelData[i] = value;
		}
		kernels.add(new Kernel(kernelSizeX, kernelSizeY, kernelData));
		kernelNames.add("Blur " + kernelSizeX + "x" + kernelSizeY);
	}

}

/**
 * This class is a BufferedImageOp which performs a convolution using JOCL. For
 * BufferedImages of type TYPE_INT_RGB it may be used the same way as a Java
 * ConvolveOp.
 */
class JOCLConvolveOp implements BufferedImageOp {
	/**
	 * The name of the source file for the OpenCL kernel
	 */
	private static final String KERNEL_SOURCE_FILE_NAME = "/Users/ericmarchand/Documents/workspace_neural/RN/src/RN/tests/jocl/kernels/SimpleConvolution.cl";

	/**
	 * Compute the value which is the smallest multiple of the given group size
	 * that is greater than or equal to the given global size.
	 * 
	 * @param groupSize
	 *            The group size
	 * @param globalSize
	 *            The global size
	 * @return The rounded global size
	 */
	private static long round(long groupSize, long globalSize) {
		long r = globalSize % groupSize;
		if (r == 0) {
			return globalSize;
		} else {
			return globalSize + groupSize - r;
		}
	}

	/**
	 * Helper function which reads the file with the given name and returns the
	 * contents of this file as a String. Will exit the application if the file
	 * can not be read.
	 * 
	 * @param fileName
	 *            The name of the file to read.
	 * @return The contents of the file
	 */
	private static String readFile(String fileName) {
		try {
			BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(fileName)));
			StringBuffer sb = new StringBuffer();
			String line = null;
			while (true) {
				line = br.readLine();
				if (line == null) {
					break;
				}
				sb.append(line).append("\n");
			}
			return sb.toString();
		} catch (IOException e) {
			e.printStackTrace();
			System.exit(1);
			return null;
		}
	}

	/**
	 * The OpenCL context
	 */
	private cl_context context;

	/**
	 * The OpenCL command queue
	 */
	private cl_command_queue commandQueue;

	/**
	 * The OpenCL kernel which will perform the convolution
	 */
	private cl_kernel clKernel;

	/**
	 * The kernel which is used for the convolution
	 */
	private Kernel kernel;

	/**
	 * The memory object that stores the kernel data
	 */
	private cl_mem kernelMem;

	/**
	 * The memory object for the input image
	 */
	private cl_mem inputImageMem;

	/**
	 * The memory object for the output image
	 */
	private cl_mem outputImageMem;

	/**
	 * Creates a new JOCLConvolveOp which may be used to apply the given kernel
	 * to a BufferedImage. This method will create an OpenCL context for the
	 * first platform that is found, and a command queue for the first device
	 * that is found. To create a JOCLConvolveOp for an existing context and
	 * command queue, use the constructor of this class.
	 * 
	 * @param kernel
	 *            The kernel to apply
	 * @return The JOCLConvolveOp for the given kernel.
	 */
	public static JOCLConvolveOp create(Kernel kernel) {
		// The platform, device type and device number
		// that will be used
		final int platformIndex = 0;
		final long deviceType = CL_DEVICE_TYPE_ALL;
		final int deviceIndex = 0;

		// Enable exceptions and subsequently omit error checks in this sample
		CL.setExceptionsEnabled(true);

		// Obtain the number of platforms
		int numPlatformsArray[] = new int[1];
		clGetPlatformIDs(0, null, numPlatformsArray);
		int numPlatforms = numPlatformsArray[0];

		// Obtain a platform ID
		cl_platform_id platforms[] = new cl_platform_id[numPlatforms];
		clGetPlatformIDs(platforms.length, platforms, null);
		cl_platform_id platform = platforms[platformIndex];

		// Initialize the context properties
		cl_context_properties contextProperties = new cl_context_properties();
		contextProperties.addProperty(CL_CONTEXT_PLATFORM, platform);

		// Obtain the number of devices for the platform
		int numDevicesArray[] = new int[1];
		clGetDeviceIDs(platform, deviceType, 0, null, numDevicesArray);
		int numDevices = numDevicesArray[0];

		// Obtain a device ID
		cl_device_id devices[] = new cl_device_id[numDevices];
		clGetDeviceIDs(platform, deviceType, numDevices, devices, null);
		cl_device_id device = devices[deviceIndex];

		// Create a context for the selected device
		cl_context context = clCreateContext(contextProperties, 1, new cl_device_id[] { device }, null, null, null);

		// Create a command-queue for the selected device
		cl_command_queue commandQueue = clCreateCommandQueue(context, device, 0, null);

		return new JOCLConvolveOp(context, commandQueue, kernel);
	}

	/**
	 * Creates a JOCLConvolveOp for the given context and command queue, which
	 * may be used to apply the given kernel to a BufferedImage.
	 * 
	 * @param context
	 *            The context
	 * @param commandQueue
	 *            The command queue
	 * @param kernel
	 *            The kernel to apply
	 */
	public JOCLConvolveOp(cl_context context, cl_command_queue commandQueue, Kernel kernel) {
		this.context = context;
		this.commandQueue = commandQueue;
		this.kernel = kernel;

		// Create the OpenCL kernel from the program
		String source = readFile(KERNEL_SOURCE_FILE_NAME);
		cl_program program = clCreateProgramWithSource(context, 1, new String[] { source }, null, null);
		String compileOptions = "-cl-mad-enable";
		clBuildProgram(program, 0, null, compileOptions, null, null);
		clKernel = clCreateKernel(program, "convolution", null);
		clReleaseProgram(program);

		// Create the ... other kernel... for the convolution
		float kernelData[] = kernel.getKernelData(null);
		kernelMem = clCreateBuffer(context, CL_MEM_READ_ONLY, kernelData.length * Sizeof.cl_uint, null, null);
		clEnqueueWriteBuffer(commandQueue, kernelMem, true, 0, kernelData.length * Sizeof.cl_uint, Pointer.to(kernelData), 0, null, null);

	}

	/**
	 * Release all resources that have been created for this instance.
	 */
	public void shutdown() {
		clReleaseMemObject(kernelMem);
		clReleaseKernel(clKernel);
		clReleaseCommandQueue(commandQueue);
		clReleaseContext(context);
	}

	@Override
	public BufferedImage createCompatibleDestImage(BufferedImage src, ColorModel destCM) {
		int w = src.getWidth();
		int h = src.getHeight();
		BufferedImage result = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
		return result;
	}

	@Override
	public BufferedImage filter(BufferedImage src, BufferedImage dst) {
		// Validity checks for the given images
		if (src.getType() != BufferedImage.TYPE_INT_RGB) {
			throw new IllegalArgumentException("Source image is not TYPE_INT_RGB");
		}
		if (dst == null) {
			dst = createCompatibleDestImage(src, null);
		} else if (dst.getType() != BufferedImage.TYPE_INT_RGB) {
			throw new IllegalArgumentException("Destination image is not TYPE_INT_RGB");
		}
		if (src.getWidth() != dst.getWidth() || src.getHeight() != dst.getHeight()) {
			throw new IllegalArgumentException("Images do not have the same size");
		}
		int imageSizeX = src.getWidth();
		int imageSizeY = src.getHeight();

		// Create the memory object for the input- and output image
		DataBufferInt dataBufferSrc = (DataBufferInt) src.getRaster().getDataBuffer();

		int dataSrc[] = dataBufferSrc.getData();

		inputImageMem = clCreateBuffer(context, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR, dataSrc.length * Sizeof.cl_uint, Pointer.to(dataSrc), null);

		outputImageMem = clCreateBuffer(context, CL_MEM_WRITE_ONLY, imageSizeX * imageSizeY * Sizeof.cl_uint, null, null);

		// Set work sizes and arguments, and execute the kernel
		int kernelSizeX = kernel.getWidth();
		int kernelSizeY = kernel.getHeight();
		int kernelOriginX = kernel.getXOrigin();
		int kernelOriginY = kernel.getYOrigin();

		long localWorkSize[] = new long[2];
		localWorkSize[0] = kernelSizeX;
		localWorkSize[1] = kernelSizeY;

		long globalWorkSize[] = new long[2];
		globalWorkSize[0] = round(localWorkSize[0], imageSizeX);
		globalWorkSize[1] = round(localWorkSize[1], imageSizeY);

		int imageSize[] = new int[] { imageSizeX, imageSizeY };
		int kernelSize[] = new int[] { kernelSizeX, kernelSizeY };
		int kernelOrigin[] = new int[] { kernelOriginX, kernelOriginY };

		clSetKernelArg(clKernel, 0, Sizeof.cl_mem, Pointer.to(inputImageMem));
		clSetKernelArg(clKernel, 1, Sizeof.cl_mem, Pointer.to(kernelMem));
		clSetKernelArg(clKernel, 2, Sizeof.cl_mem, Pointer.to(outputImageMem));
		clSetKernelArg(clKernel, 3, Sizeof.cl_int2, Pointer.to(imageSize));
		clSetKernelArg(clKernel, 4, Sizeof.cl_int2, Pointer.to(kernelSize));
		clSetKernelArg(clKernel, 5, Sizeof.cl_int2, Pointer.to(kernelOrigin));

		System.out.println("global " + Arrays.toString(globalWorkSize));
		System.out.println("local  " + Arrays.toString(localWorkSize));

		clEnqueueNDRangeKernel(commandQueue, clKernel, 2, null, globalWorkSize, null, 0, null, null);

		// Read the pixel data into the BufferedImage
		DataBufferInt dataBufferDst = (DataBufferInt) dst.getRaster().getDataBuffer();
		int dataDst[] = dataBufferDst.getData();
		clEnqueueReadBuffer(commandQueue, outputImageMem, CL_TRUE, 0, dataDst.length * Sizeof.cl_uint, Pointer.to(dataDst), 0, null, null);

		// Clean up
		clReleaseMemObject(inputImageMem);
		clReleaseMemObject(outputImageMem);

		return dst;
	}

	@Override
	public Rectangle2D getBounds2D(BufferedImage src) {
		return src.getRaster().getBounds();
	}

	@Override
	public final Point2D getPoint2D(Point2D srcPt, Point2D dstPt) {
		if (dstPt == null) {
			dstPt = new Point2D.Float();
		}
		dstPt.setLocation(srcPt.getX(), srcPt.getY());
		return dstPt;
	}

	@Override
	public RenderingHints getRenderingHints() {
		return null;
	}
}
package RN.tests.jocl;

/*
 * JOCL - Java bindings for OpenCL
 *
 * Copyright 2010 Marco Hutter - http://www.jocl.org/
 */

import static org.jocl.CL.*;

import java.awt.*;
import java.awt.image.*;
import java.io.*;

import javax.imageio.ImageIO;
import javax.swing.*;

import org.jocl.*;

/**
 * A simple example demonstrating image handling between JOCL
 * and Swing. It shows an animation of a rotating image,
 * which is rotated using an OpenCL kernel involving some
 * basic image operations.
 */
public class JOCLSimpleImage
{
    /**
     * Entry point for this sample.
     *
     * @param args not used
     */
    public static void main(String args[])
    {
        SwingUtilities.invokeLater(new Runnable()
        {
            public void run()
            {
                new JOCLSimpleImage();
            }
        });
    }

    /**
     * The source code of the kernel to execute. It will rotate the
     * input image by the given angle and write the result into the
     * output image.
     */
    private static String programSource =
        ""+ "\n" +
        "const sampler_t samplerIn = "+ "\n" +
        "    CLK_NORMALIZED_COORDS_FALSE | "+ "\n" +
        "    CLK_ADDRESS_CLAMP |"+ "\n" +
        "    CLK_FILTER_NEAREST;"+ "\n" +
        ""+ "\n" +
        "const sampler_t samplerOut = "+ "\n" +
        "    CLK_NORMALIZED_COORDS_FALSE |"+ "\n" +
        "    CLK_ADDRESS_CLAMP |"+ "\n" +
        "    CLK_FILTER_NEAREST;"+ "\n" +
        ""+ "\n" +
        "__kernel void rotateImage("+ "\n" +
        "    __read_only  image2d_t sourceImage, "+ "\n" +
        "    __write_only image2d_t targetImage, "+ "\n" +
        "    float angle)"+ "\n" +
        "{"+ "\n" +
        "    int gidX = get_global_id(0);"+ "\n" +
        "    int gidY = get_global_id(1);"+ "\n" +
        "    int w = get_image_width(sourceImage);"+ "\n" +
        "    int h = get_image_height(sourceImage);"+ "\n" +
        "    int cx = w/2;"+ "\n" +
        "    int cy = h/2;"+ "\n" +
        "    int dx = gidX-cx;"+ "\n" +
        "    int dy = gidY-cy;"+ "\n" +
        "    float ca = cos(angle);"+ "\n" +
        "    float sa = sin(angle);"+ "\n" +
        "    int inX = (int)(cx+ca*dx-sa*dy);"+ "\n" +
        "    int inY = (int)(cy+sa*dx+ca*dy);"+ "\n" +
        "    int2 posIn = {inX, inY};"+ "\n" +
        "    int2 posOut = {gidX, gidY};"+ "\n" +
        "    uint4 pixel = read_imageui(sourceImage, samplerIn, posIn);"+ "\n" +
        "    write_imageui(targetImage, posOut, pixel);"+ "\n" +
        "}";


    /**
     * Creates a BufferedImage of with type TYPE_INT_RGB from the
     * file with the given name.
     *
     * @param fileName The file name
     * @return The image, or null if the file may not be read
     */
    private static BufferedImage createBufferedImage(String fileName)
    {
        BufferedImage image = null;
        try
        {
            image = ImageIO.read(new File(fileName));
        }
        catch (IOException e)
        {
            e.printStackTrace();
            return null;
        }

        int sizeX = image.getWidth();
        int sizeY = image.getHeight();

        BufferedImage result = new BufferedImage(
            sizeX, sizeY, BufferedImage.TYPE_INT_RGB);
        Graphics g = result.createGraphics();
        g.drawImage(image, 0, 0, null);
        g.dispose();
        return result;
    }

    /**
     * The input image
     */
    private BufferedImage inputImage;

    /**
     * The output image
     */
    private BufferedImage outputImage;

    /**
     * The OpenCL context
     */
    private cl_context context;

    /**
     * The OpenCL command queue
     */
    private cl_command_queue commandQueue;

    /**
     * The OpenCL kernel
     */
    private cl_kernel kernel;

    /**
     * The memory object for the input image
     */
    private cl_mem inputImageMem;

    /**
     * The memory object for the output image
     */
    private cl_mem outputImageMem;

    /**
     * The width of the image
     */
    private int imageSizeX;

    /**
     * The height of the image
     */
    private int imageSizeY;

    /**
     * Creates the JOCLSimpleImage sample
     */
    public JOCLSimpleImage()
    {
        // Read the input image file and create the output images
        String fileName = "/Users/ericmarchand/Documents/workspace_neural/RN/src/RN/tests/jocl/images/lena512color.png";
        //fileName = "data/Porsche-14.jpg";

        inputImage = createBufferedImage(fileName);
        imageSizeX = inputImage.getWidth();
        imageSizeY = inputImage.getHeight();

        outputImage = new BufferedImage(
            imageSizeX, imageSizeY, BufferedImage.TYPE_INT_RGB);

        // Create the panel showing the input and output images
        JPanel mainPanel = new JPanel(new GridLayout(1,0));
        JLabel inputLabel = new JLabel(new ImageIcon(inputImage));
        mainPanel.add(inputLabel, BorderLayout.CENTER);
        JLabel outputLabel = new JLabel(new ImageIcon(outputImage));
        mainPanel.add(outputLabel, BorderLayout.CENTER);

        // Create the main frame
        JFrame frame = new JFrame("JOCL Simple Image Sample");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setLayout(new BorderLayout());
        frame.add(mainPanel, BorderLayout.CENTER);
        frame.pack();
        frame.setVisible(true);

        initCL();
        initImageMem();
        startAnimation(outputLabel);
    }


    /**
     * Starts the thread which will advance the animation state
     * and call call the animation method.
     *
     * @param outputComponent The component to repaint after each step
     */
    private void startAnimation(final Component outputComponent)
    {
        System.out.println("Starting animation...");
        Thread thread = new Thread(new Runnable()
        {
            float angle = 0.0f;
            public void run()
            {
                while (true)
                {
                    rotateImage(angle);
                    angle += 0.1f;
                    outputComponent.repaint();

                    try
                    {
                        Thread.sleep(20);
                    }
                    catch (InterruptedException e)
                    {
                        Thread.currentThread().interrupt();
                        return;
                    }
                }
            }
        });
        thread.setDaemon(true);
        thread.start();
    }


    /**
     * Initialize the OpenCL context, command queue and kernel
     */
    void initCL()
    {
        final int platformIndex = 0;
        final long deviceType = CL_DEVICE_TYPE_ALL;
        final int deviceIndex = 1;

        // Enable exceptions and subsequently omit error checks in this sample
        CL.setExceptionsEnabled(true);

        // Obtain the number of platforms
        int numPlatformsArray[] = new int[1];
        clGetPlatformIDs(0, null, numPlatformsArray);
        int numPlatforms = numPlatformsArray[0];

        // Obtain a platform ID
        cl_platform_id platforms[] = new cl_platform_id[numPlatforms];
        clGetPlatformIDs(platforms.length, platforms, null);
        cl_platform_id platform = platforms[platformIndex];

        // Initialize the context properties
        cl_context_properties contextProperties = new cl_context_properties();
        contextProperties.addProperty(CL_CONTEXT_PLATFORM, platform);
        
        // Obtain the number of devices for the platform
        int numDevicesArray[] = new int[1];
        clGetDeviceIDs(platform, deviceType, 0, null, numDevicesArray);
        int numDevices = numDevicesArray[0];
        
        // Obtain a device ID 
        cl_device_id devices[] = new cl_device_id[numDevices];
        clGetDeviceIDs(platform, deviceType, numDevices, devices, null);
        cl_device_id device = devices[deviceIndex];

        // Create a context for the selected device
        context = clCreateContext(
            contextProperties, 1, new cl_device_id[]{device}, 
            null, null, null);
        
        // Check if images are supported
        int imageSupport[] = new int[1];
        clGetDeviceInfo (device, CL.CL_DEVICE_IMAGE_SUPPORT,
            Sizeof.cl_int, Pointer.to(imageSupport), null);
        System.out.println("Images supported: "+(imageSupport[0]==1));
        if (imageSupport[0]==0)
        {
            System.out.println("Images are not supported");
            System.exit(1);
            return;
        }

        // Create a command-queue
        System.out.println("Creating command queue...");
        long properties = 0;
        properties |= CL_QUEUE_PROFILING_ENABLE;
        //properties |= CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE;
        commandQueue = clCreateCommandQueue(context, device, properties, null);

        // Create the program
        System.out.println("Creating program...");
        cl_program program = clCreateProgramWithSource(context,
            1, new String[]{ programSource }, null, null);

        // Build the program
        System.out.println("Building program...");
        clBuildProgram(program, 0, null, null, null, null);

        // Create the kernel
        System.out.println("Creating kernel...");
        kernel = clCreateKernel(program, "rotateImage", null);

    }

    /**
     * Initialize the memory objects for the input and output images
     */
    private void initImageMem()
    {
        // Create the memory object for the input- and output image
        DataBufferInt dataBufferSrc =
            (DataBufferInt)inputImage.getRaster().getDataBuffer();
        int dataSrc[] = dataBufferSrc.getData();

        cl_image_format imageFormat = new cl_image_format();
        imageFormat.image_channel_order = CL_RGBA;
        imageFormat.image_channel_data_type = CL_UNSIGNED_INT8;

        inputImageMem = clCreateImage2D(
            context, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR,
            new cl_image_format[]{imageFormat}, imageSizeX, imageSizeY,
            imageSizeX * Sizeof.cl_uint, Pointer.to(dataSrc), null);

        outputImageMem = clCreateImage2D(
            context, CL_MEM_WRITE_ONLY,
            new cl_image_format[]{imageFormat}, imageSizeX, imageSizeY,
            0, null, null);
    }


    /**
     * Rotate the input image by the given angle, and write it into
     * the output image
     *
     * @param angle The rotation angle
     */
    void rotateImage(float angle)
    {
        // Set up the work size and arguments, and execute the kernel
        long globalWorkSize[] = new long[2];
        globalWorkSize[0] = imageSizeX;
        globalWorkSize[1] = imageSizeY;
        clSetKernelArg(kernel, 0, Sizeof.cl_mem, Pointer.to(inputImageMem));
        clSetKernelArg(kernel, 1, Sizeof.cl_mem, Pointer.to(outputImageMem));
        clSetKernelArg(kernel, 2, Sizeof.cl_float,
            Pointer.to(new float[]{angle}));
        clEnqueueNDRangeKernel(commandQueue, kernel, 2, null,
            globalWorkSize, null, 0, null, null);

        // Read the pixel data into the output image
        DataBufferInt dataBufferDst =
            (DataBufferInt)outputImage.getRaster().getDataBuffer();
        int dataDst[] = dataBufferDst.getData();
        clEnqueueReadImage(
            commandQueue, outputImageMem, true, new long[3],
            new long[]{imageSizeX, imageSizeY, 1},
            imageSizeX * Sizeof.cl_uint, 0,
            Pointer.to(dataDst), 0, null, null);
    }
}
package RN.tests.jocl;

/*
 * JOCL - Java bindings for OpenCL
 * 
 * Copyright 2009 Marco Hutter - http://www.jocl.org/
 */

import static org.jocl.CL.*;

import java.awt.*;
import java.awt.event.*;
import java.awt.image.*;
import java.io.*;

import javax.swing.*;

import org.jocl.*;

/**
 * A class that uses a simple OpenCL kernel to compute the
 * Mandelbrot set and displays it in an image
 */
public class JOCLSimpleMandelbrot
{
    /**
     * Entry point for this sample.
     * 
     * @param args not used
     */
    public static void main(String args[])
    {
        SwingUtilities.invokeLater(new Runnable()
        {
            public void run()
            {
                new JOCLSimpleMandelbrot(500,500);
            }
        });
    }

    /**
     * The image which will contain the Mandelbrot pixel data
     */
    private BufferedImage image;

    /**
     * The width of the image
     */
    private int sizeX = 0;

    /**
     * The height of the image
     */
    private int sizeY = 0;

    /**
     * The component which is used for rendering the image
     */
    private JComponent imageComponent;
    
    /** 
     * The OpenCL context
     */
    private cl_context context;

    /**
     * The OpenCL command queue
     */
    private cl_command_queue commandQueue;

    /**
     * The OpenCL kernel which will actually compute the Mandelbrot
     * set and store the pixel data in a CL memory object
     */
    private cl_kernel kernel;

    /**
     * The OpenCL memory object which stores the pixel data
     */
    private cl_mem pixelMem;
    
    /**
     * An OpenCL memory object which stores a nifty color map,
     * encoded as integers combining the RGB components of
     * the colors.
     */
    private cl_mem colorMapMem;

    /**
     * The color map which will be copied to OpenCL for filling
     * the PBO. 
     */
    private int colorMap[];
    
    /**
     * The minimum x-value of the area in which the Mandelbrot 
     * set should be computed
     */
    private float x0 = -2f;

    /**
     * The minimum y-value of the area in which the Mandelbrot 
     * set should be computed
     */
    private float y0 = -1.3f;

    /**
     * The maximum x-value of the area in which the Mandelbrot 
     * set should be computed
     */
    private float x1 = 0.6f;

    /**
     * The maximum y-value of the area in which the Mandelbrot 
     * set should be computed
     */
    private float y1 = 1.3f;

    
    /**
     * Creates the JOCLSimpleMandelbrot sample with the given
     * width and height
     */
    public JOCLSimpleMandelbrot(int width, int height)
    {
        this.sizeX = width;
        this.sizeY = height;

        // Create the image and the component that will paint the image
        image = new BufferedImage(sizeX, sizeY, BufferedImage.TYPE_INT_RGB);
        imageComponent = new JPanel()
        {
            private static final long serialVersionUID = 1L;
            public void paintComponent(Graphics g)
            {
                super.paintComponent(g);
                g.drawImage(image, 0,0,this);
            }   
        };
        
        // Initialize the mouse interaction
        initInteraction();

        // Initialize OpenCL
        initCL();

        // Initial image update 
        updateImage();
        
        // Create the main frame
        JFrame frame = new JFrame("JOCL Simple Mandelbrot");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setLayout(new BorderLayout());
        imageComponent.setPreferredSize(new Dimension(width, height));
        frame.add(imageComponent, BorderLayout.CENTER);
        frame.pack();
        
        frame.setVisible(true);
    }
    
    /**
     * Initialize OpenCL: Create the context, the command queue
     * and the kernel.
     */
    private void initCL()
    {
        final int platformIndex = 0;
        final long deviceType = CL_DEVICE_TYPE_ALL;
        final int deviceIndex = 0;

        // Enable exceptions and subsequently omit error checks in this sample
        CL.setExceptionsEnabled(true);

        // Obtain the number of platforms
        int numPlatformsArray[] = new int[1];
        clGetPlatformIDs(0, null, numPlatformsArray);
        int numPlatforms = numPlatformsArray[0];

        // Obtain a platform ID
        cl_platform_id platforms[] = new cl_platform_id[numPlatforms];
        clGetPlatformIDs(platforms.length, platforms, null);
        cl_platform_id platform = platforms[platformIndex];

        // Initialize the context properties
        cl_context_properties contextProperties = new cl_context_properties();
        contextProperties.addProperty(CL_CONTEXT_PLATFORM, platform);
        
        // Obtain the number of devices for the platform
        int numDevicesArray[] = new int[1];
        clGetDeviceIDs(platform, deviceType, 0, null, numDevicesArray);
        int numDevices = numDevicesArray[0];
        
        // Obtain a device ID 
        cl_device_id devices[] = new cl_device_id[numDevices];
        clGetDeviceIDs(platform, deviceType, numDevices, devices, null);
        cl_device_id device = devices[deviceIndex];

        // Create a context for the selected device
        context = clCreateContext(
            contextProperties, 1, new cl_device_id[]{device}, 
            null, null, null);
        
        // Create a command-queue for the selected device
        commandQueue = 
            clCreateCommandQueue(context, device, 0, null);

        // Program Setup
        String source = readFile("/Users/ericmarchand/Documents/workspace_neural/RN/src/RN/tests/jocl/kernels/SimpleMandelbrot.cl");

        // Create the program
        cl_program cpProgram = clCreateProgramWithSource(context, 1, 
            new String[]{ source }, null, null);

        // Build the program
        clBuildProgram(cpProgram, 0, null, "-cl-mad-enable", null, null);

        // Create the kernel
        kernel = clCreateKernel(cpProgram, "computeMandelbrot", null);

        // Create the memory object which will be filled with the
        // pixel data
        pixelMem = clCreateBuffer(context, CL_MEM_WRITE_ONLY, 
            sizeX * sizeY * Sizeof.cl_uint, null, null);
        
        // Create and fill the memory object containing the color map
        initColorMap(32, Color.RED, Color.GREEN, Color.BLUE);
        colorMapMem = clCreateBuffer(context, CL_MEM_READ_WRITE, 
            colorMap.length * Sizeof.cl_uint, null, null);
        clEnqueueWriteBuffer(commandQueue, colorMapMem, true, 0, 
            colorMap.length * Sizeof.cl_uint, Pointer.to(colorMap), 0, null, null);
    }
    
    /**
     * Helper function which reads the file with the given name and returns 
     * the contents of this file as a String. Will exit the application
     * if the file can not be read.
     * 
     * @param fileName The name of the file to read.
     * @return The contents of the file
     */
    private String readFile(String fileName)
    {
        try
        {
            BufferedReader br = new BufferedReader(
                new InputStreamReader(new FileInputStream(fileName)));
            StringBuffer sb = new StringBuffer();
            String line = null;
            while (true)
            {
                line = br.readLine();
                if (line == null)
                {
                    break;
                }
                sb.append(line).append("\n");
            }
            return sb.toString();
        }
        catch (IOException e)
        {
            e.printStackTrace();
            System.exit(1);
            return null;
        }
    }
    
    /**
     * Creates the colorMap array which contains RGB colors as integers,
     * interpolated through the given colors with colors.length * stepSize
     * steps
     * 
     * @param stepSize The number of interpolation steps between two colors
     * @param colors The colors for the map
     */
    private void initColorMap(int stepSize, Color ... colors)
    {
        colorMap = new int[stepSize*colors.length];
        int index = 0;
        for (int i=0; i<colors.length-1; i++)
        {
            Color c0 = colors[i];
            int r0 = c0.getRed();
            int g0 = c0.getGreen();
            int b0 = c0.getBlue();

            Color c1 = colors[i+1];
            int r1 = c1.getRed();
            int g1 = c1.getGreen();
            int b1 = c1.getBlue();
            
            int dr = r1-r0;
            int dg = g1-g0;
            int db = b1-b0;

            for (int j=0; j<stepSize; j++)
            {
                float alpha = (float)j / (stepSize-1);
                int r = (int)(r0 + alpha * dr);
                int g = (int)(g0 + alpha * dg);
                int b = (int)(b0 + alpha * db);
                int rgb = 
                    (r << 16) |
                    (g <<  8) |
                    (b <<  0);
                colorMap[index++] = rgb;
            }
        }
    }
    
    
    /**
     * Attach the mouse- and mouse wheel listeners to the glComponent
     * which allow zooming and panning the fractal
     */
    private void initInteraction()
    {
        final Point previousPoint = new Point();
        
        imageComponent.addMouseMotionListener(new MouseMotionListener()
        {
            @Override
            public void mouseDragged(MouseEvent e)
            {
                int dx = previousPoint.x - e.getX();
                int dy = previousPoint.y - e.getY();
                
                float wdx = x1-x0;
                float wdy = y1-y0;
                
                x0 += (dx / 150.0f) * wdx;
                x1 += (dx / 150.0f) * wdx;

                y0 += (dy / 150.0f) * wdy;
                y1 += (dy / 150.0f) * wdy;
                
                previousPoint.setLocation(e.getX(), e.getY());
                
                updateImage();
            }

            @Override
            public void mouseMoved(MouseEvent e)
            {
                previousPoint.setLocation(e.getX(), e.getY());
            }
            
        });
        
        imageComponent.addMouseWheelListener(new MouseWheelListener()
        {
            @Override
            public void mouseWheelMoved(MouseWheelEvent e)
            {
                float dx = x1-x0;
                float dy = y1-y0;
                float delta = e.getWheelRotation() / 20.0f;
                x0 += delta * dx;
                x1 -= delta * dx;
                y0 += delta * dy;
                y1 -= delta * dy;
                
                updateImage();
            }
        });
    }
    

    /**
     * Execute the kernel function and read the resulting pixel data
     * into the BufferedImage
     */
    private void updateImage()
    {
        // Set work size and execute the kernel
        long globalWorkSize[] = new long[2];
        globalWorkSize[0] = sizeX;
        globalWorkSize[1] = sizeY;

        int maxIterations = 250;
        clSetKernelArg(kernel, 0, Sizeof.cl_mem, Pointer.to(pixelMem));
        clSetKernelArg(kernel, 1, Sizeof.cl_uint, Pointer.to(new int[]{sizeX}));
        clSetKernelArg(kernel, 2, Sizeof.cl_uint, Pointer.to(new int[]{sizeY}));
        clSetKernelArg(kernel, 3, Sizeof.cl_float, Pointer.to(new float[]{ x0 }));
        clSetKernelArg(kernel, 4, Sizeof.cl_float, Pointer.to(new float[]{ y0 }));
        clSetKernelArg(kernel, 5, Sizeof.cl_float, Pointer.to(new float[]{ x1 }));
        clSetKernelArg(kernel, 6, Sizeof.cl_float, Pointer.to(new float[]{ y1 }));
        clSetKernelArg(kernel, 7, Sizeof.cl_int, Pointer.to(new int[]{ maxIterations }));
        clSetKernelArg(kernel, 8, Sizeof.cl_mem, Pointer.to(colorMapMem));
        clSetKernelArg(kernel, 9, Sizeof.cl_int, Pointer.to(new int[]{ colorMap.length }));

        clEnqueueNDRangeKernel(commandQueue, kernel, 2, null, 
            globalWorkSize, null, 0, null, null);
        
        // Read the pixel data into the BufferedImage
        DataBufferInt dataBuffer = (DataBufferInt)image.getRaster().getDataBuffer();
        int data[] = dataBuffer.getData();
        clEnqueueReadBuffer(commandQueue, pixelMem, CL_TRUE, 0, 
            Sizeof.cl_int * sizeY * sizeX, Pointer.to(data), 0, null, null);
        
        imageComponent.repaint();
    }
    
    
}package RN.tests;

import static org.ojalgo.constant.PrimitiveMath.PI;
import static org.ojalgo.constant.PrimitiveMath.ZERO;
import static org.ojalgo.function.PrimitiveFunction.DIVIDE;
import static org.ojalgo.function.PrimitiveFunction.SUBTRACT;

import java.io.File;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import org.ojalgo.OjAlgoUtils;
import org.ojalgo.array.Array2D;
import org.ojalgo.array.ArrayAnyD;
import org.ojalgo.array.BufferArray;
import org.ojalgo.function.aggregator.AggregatorFunction;
import org.ojalgo.function.aggregator.PrimitiveAggregator;
import org.ojalgo.machine.JavaType;
import org.ojalgo.matrix.store.MatrixStore;
import org.ojalgo.matrix.store.PhysicalStore;
import org.ojalgo.matrix.store.PrimitiveDenseStore;
import org.ojalgo.netio.BasicLogger;
import org.ojalgo.random.Uniform;

import RN.AreaSquare;
import RN.links.ELinkType;
import RN.links.Link;
import RN.nodes.ENodeType;

public class MatrixTest {

	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
	}

	@Before
	public void setUp() throws Exception {
	}

	@After
	public void tearDown() throws Exception {
	}
	
	@Test
	public void testA() {
		
        BasicLogger.debug();
        BasicLogger.debug(MatrixTest.class.getSimpleName());
        BasicLogger.debug(OjAlgoUtils.getTitle());
        BasicLogger.debug(OjAlgoUtils.getDate());
        BasicLogger.debug();

        // The file pathname - previously existing or not
        final File tmpFile = new File("BasicDemo.array");

        final long tmpJvmMemory = OjAlgoUtils.ENVIRONMENT.memory;
        BasicLogger.debug("The JVM was started with a max heap size of {}MB", (tmpJvmMemory / 1024L) / 1024L);

        final long tmpMaxDimension = (long) Math.sqrt(tmpJvmMemory / JavaType.DOUBLE.memory());
        BasicLogger.debug("The maximum number of rows and columns: {}", tmpMaxDimension);
        // Disregarding any overhead and all other objects

        // A max sized 2-dimensional file based array
        final Array2D<Double> tmpArray2D = BufferArray.make(tmpFile, tmpMaxDimension, tmpMaxDimension);

        // An equally sized multi/any-dimensional array, based on the same file
        final ArrayAnyD<Double> tmpArrayAnyD = BufferArray.make(tmpFile, tmpMaxDimension, tmpMaxDimension, 1L, 1L);
        // An any-dimensional array can of course be 1- or 2-dimensional. In this case we instantiated a 4-dimensional
        // array, but the size of the 3:d and 4:th dimensions are just 1. Effectively this is just a 2-dimensioanl array.

        // Fill the entire array/file with zeros
        tmpArrayAnyD.fillAll(ZERO);

        BasicLogger.debug("Number of elements in...");
        BasicLogger.debug("\t2D: {}", tmpArray2D.count());
        BasicLogger.debug("\tAnyD: {}", tmpArrayAnyD.count());

        final AggregatorFunction<Double> tmpCardinality = PrimitiveAggregator.getSet().cardinality();

        final long tmpRowIndex = Uniform.randomInteger(tmpMaxDimension);
        final long tmpColumnIndex = Uniform.randomInteger(tmpMaxDimension);

        // Using the arbitrary dimensinal interface/facade we will update an entire row (all columns) of the first matrix of the first cube...
        long[] tmpReferenceToFirstElement = new long[] { tmpRowIndex, 0L, 0L, 0L };
        int tmpDimension = 1; // That's the column-dimension
        tmpArrayAnyD.fillSet(tmpReferenceToFirstElement, tmpDimension, PI);

        // Using the arbitrary dimensional interface/facade we will update an entire row (all columns) of the first matrix of the first cube...
        tmpReferenceToFirstElement = new long[] { 0L, tmpColumnIndex, 0L, 0L };
        tmpDimension = 0; // That's the row-dimension
        tmpArrayAnyD.fillSet(tmpReferenceToFirstElement, tmpDimension, PI);

        // So far we've been writing to the array-file using ArrayAnyD
        // Now we'll switch to using Array2D, but they're both mapped to the same files

        tmpCardinality.reset();
        tmpArray2D.visitRow(tmpRowIndex, 0L, tmpCardinality);
        BasicLogger.debug("Number of nonzero elements in row {}: {}", tmpRowIndex, tmpCardinality.intValue());

        tmpCardinality.reset();
        tmpArray2D.visitColumn(0L, tmpColumnIndex, tmpCardinality);
        BasicLogger.debug("Number of nonzero elements in column {}: {}", tmpColumnIndex, tmpCardinality.intValue());

        tmpCardinality.reset();
        tmpArray2D.visitAll(tmpCardinality);
        BasicLogger.debug("Number of nonzero elements in the 2D array: {}", tmpCardinality.intValue());

        BasicLogger.debug("Divide the elements of row {} to create 1.0:s", tmpRowIndex);
        tmpArray2D.modifyRow(tmpRowIndex, 0L, DIVIDE.second(PI));
        BasicLogger.debug("Subtract from the elements of column {} to create 0.0:s", tmpColumnIndex);
        tmpArray2D.modifyColumn(0L, tmpColumnIndex, SUBTRACT.second(PI));
        BasicLogger.debug("Explictly set the intersection element to 0.0 using the arbitrary-dimensional array.");
        tmpArrayAnyD.set(new long[] { tmpRowIndex, tmpColumnIndex }, ZERO);

        final AggregatorFunction<Double> tmpSum = PrimitiveAggregator.getSet().sum();
        BasicLogger.debug("Expected sum of all elements: {}", tmpMaxDimension - 1L);
        tmpSum.reset();
        tmpArray2D.visitAll(tmpSum);
        BasicLogger.debug("Actual sum of all elements: {}", tmpSum.intValue());

	}

	@Test
	public void test() {
		
		final PhysicalStore.Factory<Double, PrimitiveDenseStore> tmpFactory = PrimitiveDenseStore.FACTORY;
		
		final PrimitiveDenseStore pds = tmpFactory.rows(new double[]{1D, 2D, 3D, 4D, 5D, 6D, 7D, 8D, 9D});
		
		MatrixStore<Double> ms = pds.builder().row(1,9).build();
		System.out.println(ms.toString());
		
	}
	
	@Test
	public void test2() {
		
//		DoubleMatrix values = new DoubleMatrix(new double[][]{{1,2,3,4,5,6,7,8,9}});
//		System.out.println(values.toString("%.2f", "", "", "\t", "\n"));
//		
//		
//		System.out.println();
//		DoubleMatrix weights = new DoubleMatrix(9,2);
//		weights.putColumn(0, new DoubleMatrix(new double[]{1,2,3,4,5,6,7,8,9}));
//		weights.putColumn(1, new DoubleMatrix(new double[]{1,2,3,4,5,6,7,8,9}));
//		System.out.println(weights.toString("%.2f", "", "", "\t", "\n"));
//		
//		
//		System.out.println();
//		//DoubleMatrix results = values.mul(weights);
//		DoubleMatrix results2 = values.mmul(weights);
//		//System.out.println(results.toString(" %.2f ", "", "", "\t", "\n"));
//		System.out.println(results2.toString(" %.2f ", "", "", "\t", "\n"));
		
		
	}
	
	@Test
	public void test3() {
		
		final PhysicalStore.Factory<Double, PrimitiveDenseStore> tmpFactory = PrimitiveDenseStore.FACTORY;
		
		final PrimitiveDenseStore pds = tmpFactory.makeZero(10000, 10000);
		final PrimitiveDenseStore pds2 = tmpFactory.makeZero(10000, 10000);
		final PrimitiveDenseStore pds3 = tmpFactory.makeZero(10000, 10000);
		final PrimitiveDenseStore pds4 = tmpFactory.makeZero(10000, 10000);
		
		MatrixStore<Double> ms = pds.builder().build();
		System.out.println(ms.toString());
		
	}
	
	@Test
	public void test4() {
		
		Double[][] m1 = new Double[10000][10000];
		Double[][] m2 = new Double[10000][10000];
		Double[][] m3 = new Double[10000][10000];
		Double[][] m4 = new Double[10000][10000];
		Double[][] m5 = new Double[10000][10000];
		
		System.out.println(m1[0][0]);
		
	}
	
	@Test
	public void test5() throws Exception{
		int width = 23;
		int centerIdx = (width -1) /2;
		int nbNode = width*width;
		AreaSquare area = new AreaSquare(nbNode);
		
		area.configureNode(false, ENodeType.REGULAR).createNodes(nbNode);
		for(int idx = 0; idx < nbNode; idx++){
			area.getNode(idx).addInput(Link.getInstance(ELinkType.REGULAR, true));
			area.getNode(idx).setEntry(0D);
		}
		
		for(int y = 0; y < width; y++){
			for(int x = 0; x < width; x++){
				if(y == centerIdx)
					area.getNodeXY(x , y).setEntry((double)x+y);
			}
		}
		
		System.out.print("Matrice : \n");
		for(int y = 0; y < width; y++){
			for(int x = 0; x < width; x++){
				System.out.print(area.getNodeXY(x , y).getInput(0).getValue());
				System.out.print("\t");
			}
			System.out.print("\n");
		}
		
		for(double theta = 0; theta <= 2*Math.PI; theta += Math.PI / 6D){
			System.out.println("\n Rotation d'angle theta = " + Math.toDegrees(theta) + " degree");
			for(int y = 0; y < width; y++){
				for(int x = 0; x < width; x++){
					double value = area.getNode(area.nodeXYToNodeId(x , y , centerIdx, centerIdx, theta)).getInput(0).getValue();
					System.out.print(value == 0D ? "." : value);
					System.out.print("\t");
				}
				System.out.print("\n");
			}
			System.out.print("\n\n");
			
		}
		
	}
	

	
	@Test
	public void test6(){
		for(double theta = 0; theta <= 2*Math.PI; theta += Math.PI / 2){
			System.out.println(Math.toDegrees(theta));
		}
		
		System.out.println();
		for(int y = 0; y < 3; y++){
			for(int x = 0; x < 3; x++){
				double thetaInit = Math.atan2(y - 1, x - 1);
				thetaInit = thetaInit < 0 ? thetaInit + 2*Math.PI : thetaInit;
				System.out.println(Math.toDegrees(thetaInit));
			}
		}
		
		System.out.println();
		int x0 = 3;
		int y0 = 2;
		int newX = 0;
		int newY = 0;
		for(int y = 0; y < 3; y++){
			for(int x = 0; x < 3; x++){
				
				double distance = Math.sqrt(Math.pow(x0 - (x-1 + x0), 2D) + Math.pow(y0 - (y-1 + y0), 2D));
				double thetaInit = Math.atan2(y-1, x-1);
				newX = ((int) (distance * (Math.cos(thetaInit) + 1) ) + x0);
				newY = ((int) (distance * (Math.sin(thetaInit) + 1) ) + y0);
				//System.out.println("angle=" + Math.toDegrees(thetaInit) + "  newX="+ newX + " newY=" + newY);
				System.out.print("\t");
			}
			System.out.println();
		}
	}
	
	@Test
	public void test7(){
		
		System.out.println(4%3);
		System.out.println(-12%10);
		
	}
	

}
package RN.tests.parallel;

import java.util.concurrent.ForkJoinPool;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import RN.AreaSquare;
import RN.ILayer;
import RN.Layer;
import RN.Network;
import RN.algoactivations.EActivation;
import RN.nodes.ImageNode;
import RN.nodes.PixelNode;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.image.Image;
import javafx.scene.image.PixelReader;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class ParallelTest extends Application{
	
	Network net = null;
	int nbPixels = 25;

	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		Thread t = new Thread("JavaFX Init Thread") {
	        public void run() {
	        	
	        	Application.launch(ParallelTest.class, new String[0]);
	        }
	    };
	    t.setDaemon(true);
	    t.start();
	    Thread.sleep(1000);
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
	}

	@Before
	public void setUp() throws Exception {
	}

	@After
	public void tearDown() throws Exception {
	}

	@Test
	public void testProcessors() {
		int processors = Runtime.getRuntime().availableProcessors();
		System.out.println("No of processors: " + processors);
		
		createMultiScaleNetwork();
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		finalizeNet();

		PropagationProblem bigProblem = new PropagationProblem( 0, 1);
		bigProblem.layer = net.getLastLayer();

		Task task = new Task(bigProblem);
		ForkJoinPool pool = new ForkJoinPool(processors);
		pool.invoke(task);

	}
	
	private void finalizeNet(){
		
		net.finalizeConnections();
		
		//Image noir et blanc en input
		Image image = new Image("file:D:\\git\\deepnet\\resources\\bikes.jpg");
		PixelReader pixelReader = image.getPixelReader();
		PixelNode pixNode = null;
		for(int idx = 0; idx < nbPixels; idx++){
			pixNode = (PixelNode) net.getFirstLayer().getArea(0).getNode(idx);
			
			Color color = pixelReader.getColor(pixNode.getX(), pixNode.getY());
			pixNode.getInput(0).setUnlinkedValue(color.getBrightness());
			
		}
	}
	
	private void createMultiScaleNetwork(){
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
		
				
				
				ImageNode imageNode0 = new ImageNode(EActivation.IDENTITY);
				ImageNode imageNode1 = new ImageNode(EActivation.IDENTITY);
				ImageNode imageNode2 = new ImageNode(EActivation.IDENTITY);
				ImageNode imageNode3 = new ImageNode(EActivation.IDENTITY);
				ImageNode imageNode4 = new ImageNode(EActivation.IDENTITY);
				ImageNode imageNode5 = new ImageNode(EActivation.IDENTITY);
				
				net = Network.getInstance();
				
				AreaSquare inArea = new AreaSquare(nbPixels, true);
				Layer inLayer = new Layer(inArea);
				
				AreaSquare hiddenArea_1_0 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_1 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_2 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_3 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_4 = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer = new Layer(hiddenArea_1_0, hiddenArea_1_1, hiddenArea_1_2, hiddenArea_1_3, hiddenArea_1_4);
				
				AreaSquare hiddenArea2 = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer1 = new Layer(hiddenArea2);

				AreaSquare hiddenArea_2_0 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_1 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_2 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_3 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_4 = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer2 = new Layer(hiddenArea_2_0, hiddenArea_2_1, hiddenArea_2_2, hiddenArea_2_3, hiddenArea_2_4);
				
				AreaSquare hiddenArea3 = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer3 = new Layer(hiddenArea3);
				
				AreaSquare hiddenArea_3_0 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_3_1 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_3_2 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_3_3 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_3_4 = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer4 = new Layer(hiddenArea_3_0, hiddenArea_3_1, hiddenArea_3_2, hiddenArea_3_3, hiddenArea_3_4);

				AreaSquare outArea = new AreaSquare(nbPixels, true);
				ILayer outLayer = new Layer(outArea);
				
				net.addLayer(inLayer, hiddenLayer, hiddenLayer1, hiddenLayer2, hiddenLayer3, hiddenLayer4, outLayer);
				
				
				
//				inArea.configureNode(false, EActivation.IDENTITY, ELinkage.ONE_TO_ONE, false, ENodeType.PIXEL).createNodes(nbPixels);
//				
//				double sigma0 = 0.3D;
//				double t = 0;
//				double k = Math.pow(2D, t) * 1.01D;
//				hiddenArea_1_0.configureNode(false, EActivation.IDENTITY, ELinkage.DOG, false, ENodeType.GAUSSIAN).configureNodeOptParams(sigma0, 1D).createNodes(nbPixels);
//				hiddenArea_1_1.configureNode(false, EActivation.IDENTITY, ELinkage.DOG, false, ENodeType.GAUSSIAN).configureNodeOptParams(k*sigma0, k).createNodes(nbPixels);
//				hiddenArea_1_2.configureNode(false, EActivation.IDENTITY, ELinkage.DOG, false, ENodeType.GAUSSIAN).configureNodeOptParams(Math.pow(k, 2D)*sigma0, Math.pow(k, 2D)).createNodes(nbPixels);
//				hiddenArea_1_3.configureNode(false, EActivation.IDENTITY, ELinkage.DOG, false, ENodeType.GAUSSIAN).configureNodeOptParams(Math.pow(k, 3D)*sigma0, Math.pow(k, 3D)).createNodes(nbPixels);
//				hiddenArea_1_4.configureNode(false, EActivation.IDENTITY, ELinkage.DOG, false, ENodeType.GAUSSIAN).configureNodeOptParams(Math.pow(k, 4D)*sigma0, Math.pow(k, 4D)).createNodes(nbPixels);
//				
//				hiddenArea2.configureNode( false, EActivation.IDENTITY, ELinkage.ONE_TO_ONE_FETCH_AREA, false, ENodeType.PIXEL).createNodes(nbPixels);
//				
//				t = 1;
//				k = Math.pow(2D, t) * 1.01D;
//				hiddenArea_2_0.configureNode(false, EActivation.IDENTITY, ELinkage.DOG, false, ENodeType.GAUSSIAN).configureNodeOptParams(Math.pow(k, 0)*sigma0, Math.pow(k, 0)).createNodes(nbPixels);
//				hiddenArea_2_1.configureNode(false, EActivation.IDENTITY, ELinkage.DOG, false, ENodeType.GAUSSIAN).configureNodeOptParams(Math.pow(k, 1)*sigma0, Math.pow(k, 1)).createNodes(nbPixels);
//				hiddenArea_2_2.configureNode(false, EActivation.IDENTITY, ELinkage.DOG, false, ENodeType.GAUSSIAN).configureNodeOptParams(Math.pow(k, 2)*sigma0, Math.pow(k, 2)).createNodes(nbPixels);
//				hiddenArea_2_3.configureNode(false, EActivation.IDENTITY, ELinkage.DOG, false, ENodeType.GAUSSIAN).configureNodeOptParams(Math.pow(k, 3)*sigma0, Math.pow(k, 3)).createNodes(nbPixels);
//				hiddenArea_2_4.configureNode(false, EActivation.IDENTITY, ELinkage.DOG, false, ENodeType.GAUSSIAN).configureNodeOptParams(Math.pow(k, 4)*sigma0, Math.pow(k, 4)).createNodes(nbPixels);
//				
//				hiddenArea3.configureNode( false, EActivation.IDENTITY, ELinkage.ONE_TO_ONE_FETCH_AREA, false, ENodeType.PIXEL).createNodes(nbPixels);
//				
//				t = 2;
//				k = Math.pow(2D, t) * 1.01D;
//				hiddenArea_3_0.configureNode(false, EActivation.IDENTITY, ELinkage.DOG, false, ENodeType.GAUSSIAN).configureNodeOptParams(Math.pow(k, 0)*sigma0, Math.pow(k, 0)).createNodes(nbPixels);
//				hiddenArea_3_1.configureNode(false, EActivation.IDENTITY, ELinkage.DOG, false, ENodeType.GAUSSIAN).configureNodeOptParams(Math.pow(k, 1)*sigma0, Math.pow(k, 1)).createNodes(nbPixels);
//				hiddenArea_3_2.configureNode(false, EActivation.IDENTITY, ELinkage.DOG, false, ENodeType.GAUSSIAN).configureNodeOptParams(Math.pow(k, 2)*sigma0, Math.pow(k, 2)).createNodes(nbPixels);
//				hiddenArea_3_3.configureNode(false, EActivation.IDENTITY, ELinkage.DOG, false, ENodeType.GAUSSIAN).configureNodeOptParams(Math.pow(k, 3)*sigma0, Math.pow(k, 3)).createNodes(nbPixels);
//				hiddenArea_3_4.configureNode(false, EActivation.IDENTITY, ELinkage.DOG, false, ENodeType.GAUSSIAN).configureNodeOptParams(Math.pow(k, 4)*sigma0, Math.pow(k, 4)).createNodes(nbPixels);
//				
//				outArea.configureNode( false, EActivation.IDENTITY, ELinkage.ONE_TO_ONE_FETCH_AREA, false, ENodeType.REGULAR).createNodes(nbPixels);
				
				
//				System.out.println("Begin propagation...");
//				try {
//					net.propagation(false);
//				} catch (Exception e) {
//					e.printStackTrace();
//				}
//				System.out.println("End propagation.");
				
				
				//System.out.println(net.getNode(3, 0, 0).getString());
				//net.getNode(1, 0, 5050).getArea().filterToString(FilterLinkage.ID_FILTER_LOG);
				//net.getNode(2, 0, 5050).getArea().filterToString(FilterLinkage.ID_FILTER_V1Orientation);
		
			}});

	}

	@Override
	public void start(Stage primaryStage) throws Exception {
		// TODO Auto-generated method stub
		
	}

}
package RN.tests.parallel;

import java.util.List;

import RN.ILayer;
import RN.links.Link;
import RN.nodes.INode;

public class PropagationProblem {

	public static ILayer layer;
	public int idxStart;
	public int idxStop;
	

	public PropagationProblem(int idxStart, int idxStop) {
		this.idxStart = idxStart;
		this.idxStop = idxStop;
	}
	

	public void propagate() {
		 if(idxStop > layer.getNodeCount() - 1)
			 idxStop = layer.getNodeCount() - 1;
		 propagate(layer.getLayerNodes().subList(idxStart, idxStop));
	}
	
	private void propagate(List<INode> nodes) {
		for(INode node : nodes){
			propagate(node);
		}
		
	}

	private Double propagate(INode node) {

		System.out.println("Thread: " + Thread.currentThread().getName() + " calculates " + node);
		
		try {
			node.computeOutput(false);
		} catch (Exception e) {
			e.printStackTrace();
		}

		if (node.getInputs().size() == 1 && node.getInput(0).getSourceNode() == null) {

			return node.getComputedOutput();

		} else {

			for (Link currentLink : node.getInputs()) {
				propagate(currentLink.getSourceNode());
			}

			return node.getComputedOutput();

		}
	}

}
package RN.tests.parallel;

import java.util.concurrent.RecursiveAction;

public class Task extends RecursiveAction {

	/**
	 * 
	 */
	private static final long serialVersionUID = 3464928662682916133L;

	public Double result = 0D;
	private static final int THRESHOLD = 1;
	private PropagationProblem problem = null;

	public Task(PropagationProblem problem) {
		this.problem = problem;
	}

	@Override
	protected void compute() {
		
		if (problem.idxStop >= problem.layer.getNodeCount() - 1) { 

			return;
			
		} else {
			Task worker1 = new Task(new PropagationProblem( 0, problem.layer.getNodeCount() / 2));
			Task worker2 = new Task(new PropagationProblem(problem.layer.getNodeCount() / 2, problem.layer.getNodeCount() / 2 + 1));

			
//			for (int idx = 1; idx < problem.layer.getNodeCount(); idx += 10) {
//				worker2 = new Task(new PropagationProblem(problem.layer, idx, idx + 1));
//				result += worker2.compute();
//			}
			
			worker1.fork();
			worker2.compute();
			
			//result = worker2.compute() + worker1.join();


		}
	}

}
package RN.tests;

	
	import javafx.application.Application;
import javafx.scene.Group;
import javafx.scene.PointLight;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.paint.PhongMaterial;
import javafx.scene.shape.Box;
import javafx.scene.shape.CullFace;
import javafx.scene.shape.Cylinder;
import javafx.scene.shape.DrawMode;
import javafx.scene.shape.Shape3D;
import javafx.scene.shape.Sphere;
import javafx.scene.transform.Rotate;
import javafx.scene.transform.Translate;
import javafx.stage.Stage;
	 
	public class Test3D extends Application {
		
//	    @Override 
//	    public void start(Stage stage) {
//	    	
//	        Group root = test();
//	         
//	        Scene scene = new Scene(root, 800, 400, true);
//	        scene.setFill(Color.rgb(10, 10, 40));
//	        scene.setCamera(new PerspectiveCamera(false));
//	        stage.setScene(scene);
//	        stage.show();
//	    }
	    
	    public void start(Stage primaryStage) {
	        Sphere sphere = new Sphere(100);
	        sphere.setMaterial(new PhongMaterial(Color.BLUE));
	        Box box = new Box(50,50,50);
	        box.setMaterial(new PhongMaterial(Color.RED));
	        box.setTranslateX(300);
	        Cylinder cylinder = new Cylinder(2, 300);
	        cylinder.setMaterial(new PhongMaterial(Color.GREEN));
	        // Transformations applied:
	        cylinder.getTransforms().addAll(new Translate(150, 0, 0), new Rotate(90, Rotate.Z_AXIS));

	        Group group = new Group(cylinder, sphere, box);
	        StackPane root = new StackPane(group);

	        Scene scene = new Scene(root, 600, 400);

	        primaryStage.setScene(scene);
	        primaryStage.show();

	        // export as single mesh
//	        EquivalentMesh equivalentMesh = new EquivalentMesh(root);
//	        equivalentMesh.export("group");
	    }

		private Group test() {
			PhongMaterial material = new PhongMaterial();
	        material.setDiffuseColor(Color.LIGHTGRAY);
	        material.setSpecularColor(Color.rgb(30, 30, 30));
	 
	        Shape3D[] meshView = new Shape3D[] {
	            new Box(200, 200, 200),
	            new Sphere(100),
	            new Cylinder(100, 200),
	        };
	 
	        for (int i=0; i!=3; ++i) {
	            meshView[i].setMaterial(material);
	            meshView[i].setTranslateX((i) * 220 + 180);
	            meshView[i].setTranslateY(200);
	            meshView[i].setTranslateZ(20);
	            meshView[i].setDrawMode(DrawMode.FILL);
	            meshView[i].setCullFace(CullFace.BACK);
	        };
	 
	        PointLight pointLight = new PointLight(Color.ANTIQUEWHITE);
	        pointLight.setTranslateX(800);
	        pointLight.setTranslateY(-100);
	        pointLight.setTranslateZ(-1000);
	 
	        Button button = new Button("Hello");
	        Group root = new Group(meshView);
	        root.getChildren().addAll(pointLight, button);
			return root;
		}
	 
	    public static void main(String[] args) {
	        launch(args);
	    }
	}

package RN.tests;

import static org.junit.Assert.fail;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import RN.Area;
import RN.AreaSquare;
import RN.ILayer;
import RN.Layer;
import RN.Network;
import RN.algoactivations.EActivation;
import RN.nodes.Node;
import RN.nodes.PixelNode;

public class TestGaussianNode {

	PixelNode gaussNode = null;
	int nbPixels = 10000;
	Network net = Network.getInstance();
	AreaSquare inArea = new AreaSquare(nbPixels);
	Layer inLayer = new Layer(inArea);
	Area hiddenArea = new Area(1);
	ILayer hiddenLayer = new Layer(hiddenArea);
	Area outArea = new Area(1);
	ILayer outLayer = new Layer(outArea);
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
	}

	@Before
	public void setUp() throws Exception {
		
		gaussNode = new PixelNode();
		
		net.addLayer(inLayer, hiddenLayer, outLayer);
		
		Node outputNode = new Node(EActivation.SYGMOID_0_1);
		outputNode.createBias();
		//outputNode.setInnerNode(imageNode);
		
		outArea.addNode(outputNode);
		
		//imageNode.initImageScene(outputNode);
		
		PixelNode pixNode = null;
		for(double idx = 0; idx < nbPixels; idx++){
			
			pixNode = new PixelNode();
			inArea.addNode(pixNode);
			
			pixNode.initParameters(nbPixels);
			
		}

	}

	@After
	public void tearDown() throws Exception {
		gaussNode = null;
		net = null;
	}

	@Test
	public void testSublayerFanOutCrossLinkageLayer() {
		
		net.finalizeConnections();
		
		System.out.println(gaussNode.getString());
		
		double margeCarre = 30D;
		for(int idx = 0; idx < nbPixels; idx++){
			PixelNode pixNode = (PixelNode) inArea.getNode(idx);
			// carré
			if(pixNode.getX() > margeCarre && pixNode.getX() < inArea.getWidthPx() - margeCarre && pixNode.getY() > margeCarre && pixNode.getY() < inArea.getHeightPx() - margeCarre)
				pixNode.getInput(0).setUnlinkedValue(1D);
			else
				pixNode.getInput(0).setUnlinkedValue(0D);
			
		}
	}

	@Test
	public void testComputeOutput() {

		//System.out.println(net.getNode(1, 0, 3031).getString());
		
		try {
			net.propagation(false);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	@Test
	public void testGetFilterValue() {
		fail("Not yet implemented");
	}

}
package RN.tests;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.util.ArrayList;
import java.util.List;
import java.util.Map.Entry;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import RN.Area;
import RN.AreaSquare;
import RN.ENetworkImplementation;
import RN.IArea;
import RN.ILayer;
import RN.Layer;
import RN.Network;
import RN.algoactivations.EActivation;
import RN.linkage.ELinkage;
import RN.linkage.ELinkageBetweenAreas;
import RN.linkage.LaplacianOfGaussianLinkage;
import RN.linkage.OneToOneOctaveAreaLinkage;
import RN.linkage.vision.Histogram;
import RN.linkage.vision.KeyPoint;
import RN.links.ELinkType;
import RN.links.Link;
import RN.nodes.ENodeType;
import RN.nodes.ImageNode;
import RN.nodes.Node;
import RN.nodes.PixelNode;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.image.Image;
import javafx.scene.image.PixelReader;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class TestImageNode extends Application{

	private ImageNode imageNode = null;
	private ImageNode imageNode2 = null;
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		
		Thread t = new Thread("JavaFX Init Thread") {
	        public void run() {
	        	
	        	Application.launch(TestImageNode.class, new String[0]);
	        }
	    };
	    t.setDaemon(true);
	    t.start();
	    Thread.sleep(1000);
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		
	}

	@Before
	public void setUp() throws Exception {
		
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
				
				imageNode = new ImageNode(EActivation.IDENTITY);
				
			}
			
		});

	}

	@After
	public void tearDown() throws Exception {
		
		imageNode = null;
	}

	@Test
	public void testDisconnect() {
		assertTrue(imageNode.getInputs().size() > 0);
		assertTrue(imageNode.getOutputs().size() > 0);
		imageNode.disconnect();
		assertEquals(0, imageNode.getInputs().size());
		assertEquals(0, imageNode.getOutputs().size());
	}
	
	@Test
	public void testDrawImageData() {
		
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
				
				int pixels = 10000;
				int width = (int) Math.sqrt(pixels);
				
				double filterIntensity = 255D;
				double imagePixelsIntensity = 255D;
				
				for (int pixIdx = 0; pixIdx < pixels * 3; pixIdx+=3) {
					
					imageNode.setImageData(pixIdx, (byte)  (255D * Math.exp((double)(-pixIdx - 15000D) / (2D * width * width * 3D)))) ;
					//imageData[idx + 1] =  (byte) ((byte)  filterIntensity & (byte)  imagePixelsIntensity);
					imageNode.setImageData(pixIdx + 1, (byte)  (((float) pixIdx / (pixels * 3)) * filterIntensity) ) ;
					imageNode.setImageData(pixIdx + 2, (byte)  ((1f - (float) pixIdx / (pixels * 3)) * imagePixelsIntensity)) ;
				}

				imageNode.scaleImage(2);
				//imageNode.initImageScene();
				imageNode.drawImageData(null);
				
			}
		});
		
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
	}
	
	@Test
	public void testRotateImageData() {
		
		Image image = new Image("file:./resources/bikes.jpg");
		int pixels = (int) (image.getWidth() * image.getHeight());
		int width = (int) Math.sqrt(pixels);
		PixelReader pixelReader = image.getPixelReader();
		
		
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
				
				imageNode2 = new ImageNode(EActivation.IDENTITY);
				imageNode2.initImageData(width, width);
				imageNode2.scaleImage(3D);
				imageNode.initImageData(width, width);
				
				boolean isMiddle;
				int[] coord;
				Color color = null;
				
				System.out.println("Begin lecture image ...");


				for(int idx = 0; idx < pixels * 3; idx+=3){
					coord = nodeIdToNodeXY(idx / 3, width);
					color = pixelReader.getColor(coord[0], coord[1]);
					imageNode.setImageData(idx, (byte)  (255D * color.getRed()) ) ;
					imageNode.setImageData(idx + 1, (byte) (255D * color.getGreen())  ) ;
					imageNode.setImageData(idx + 2, (byte)  (255D * color.getBlue()) ) ;
					
				}
				System.out.println("End lecture image.");
				
				for (int pixIdx = 0; pixIdx < pixels * 3; pixIdx+=3) {
					isMiddle = (pixIdx/3) % (width/2) == 0 && (pixIdx/3) % 100 != 0;
					if(isMiddle){
						imageNode.setImageData(pixIdx, (byte)  0 ) ;
						imageNode.setImageData(pixIdx + 1, (byte) 255D ) ;
						imageNode.setImageData(pixIdx + 2, (byte)  0 ) ;
					}
				}
				
				
				for (int pixIdx = 0; pixIdx < pixels * 3; pixIdx+=3) {
						coord = nodeIdToNodeXY(pixIdx / 3, width);
						if(coord[0] >= 45 && coord[0] <= 55 && coord[1] >= 0 && coord[1] <= 20){
							imageNode.setImageData(pixIdx, (byte)  0 ) ;
							imageNode.setImageData(pixIdx + 1, (byte) 255D) ;
							imageNode.setImageData(pixIdx + 2, (byte)  0 ) ;
						}
				}
				
				
//				imageNode.initImageScene();
//				imageNode.drawImageData(null);
				
				
				
			}
		});
		
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		int[] coord;
		int nodeId;
		int previousRow;
		Color color = null;
		
		
		//imageNode2.initImageData();
		byte rByte;
		byte gByte;
		byte bByte;
		

		for (double theta = 0; theta < 2 * Math.PI; theta += (Math.PI / 360D)) {

					for (int pixIdx = 0; pixIdx < pixels * 3; pixIdx += 3) {
						
						coord = nodeIdToNodeXY(pixIdx / 3, width);
						nodeId = nodeXYToNodeId(coord[0], coord[1], width / 2, width / 2, theta, width) * 3;
						//BaseTransform aff = Affine2D.getRotateInstance(theta, coord[0], coord[1]);
						
						rByte = imageNode.getImageData(nodeId);
						gByte = imageNode.getImageData(nodeId + 1);
						bByte = imageNode.getImageData(nodeId + 2);
						
						imageNode2.setImageData(pixIdx, rByte);
						imageNode2.setImageData(pixIdx + 1, gByte);
						imageNode2.setImageData(pixIdx + 2, bByte);
						
						// Je le garde car : A l'orgine un Lissage bilinéaire mais produit un effet spectaculaire du fait de l'erreur imageNode au lieu de imageNode2
//						color = pixelReader.getColor(coord[0], coord[1]);
//						if(pixIdx >= 3){
//							imageNode.setImageData(pixIdx - 3, (byte)  ( (rByte + imageNode.getImageData(pixIdx - 3)) / 2 ) );
//							imageNode.setImageData(pixIdx - 2, (byte) ( (gByte + imageNode.getImageData(pixIdx - 2)) / 2)  );
//							imageNode.setImageData(pixIdx - 1, (byte)  ( (bByte + imageNode.getImageData(pixIdx - 1)) / 2)  );
//						}
//						
//						if(pixIdx >= width*3){
//							previousRow = pixIdx - (width * 3);
//							imageNode.setImageData(previousRow, (byte)  ( (rByte + imageNode.getImageData(previousRow)) / 2 ) );
//							imageNode.setImageData(previousRow + 1, (byte) ( (gByte + imageNode.getImageData(previousRow + 1)) / 2)  );
//							imageNode.setImageData(previousRow + 2, (byte)  ( (bByte + imageNode.getImageData(previousRow + 2)) / 2)  );
//						}

					}

					
					//final Double theto = theta;
					
					Platform.runLater(new Runnable(){

						@Override
						public void run() {
							//imageNode2.getStage().setTitle("Tetha : " + (int) Math.toDegrees(theto));
							imageNode2.drawImageData(null);
						}
					});
					
					
//					try {
//						Thread.sleep(50);
//					} catch (InterruptedException e) {
//						e.printStackTrace();
//					}

		
		}
		
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
	}
	
	
	public int[] nodeIdToNodeXY(int id, int widthPx) {

		int x;
		int y;

		double val = (double) id / widthPx;
		x = (int) (id - (Math.floor(val) * widthPx));
		y = (int) Math.floor(val);

		return new int[] { x, y };

	}
	
	public int nodeXYToNodeId(int x, int y, int x0, int y0, double theta, int widthpx){
		
		int newX = 0;
		int newY = 0;
		
		newX = (int) Math.round((x-x0) * Math.cos(theta) - (y-y0) * Math.sin(theta)) + x0 ;
		newY = (int) Math.round((x-x0) * Math.sin(theta) + (y-y0) * Math.cos(theta)) + y0 ;
		
		newX = Math.min( Math.max(newX, 0), widthpx - 1 );
		newY = Math.min( Math.max(newY, 0), widthpx - 1 );
		
		return newX + newY * widthpx ;
	}
	
	@Test
	public void testShowCenterPointImage() {
		
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
				
				int nbPixels = 10000;
				
				AreaSquare area = new AreaSquare(nbPixels, true);
				
				PixelNode centerPix = new PixelNode();
				Link in = Link.getInstance(ELinkType.REGULAR, false);
				in.setUnlinkedValue(1D);
				centerPix.addInput(in);
				
				area.addNode(centerPix);
				
				centerPix.setNodeId(5050);
				centerPix.initParameters();
				
				

				assertEquals(50D, centerPix.getX(), 0.0D);
				assertEquals(50D, centerPix.getY(), 0.0D);
				assertEquals(100.0, area.getWidthPx(), 0.0D);
				assertEquals(area.getWidthPx(), area.getHeightPx(), 0.0D);
				
				Area area1 = new Area(1);
				Node hiddenPix = new Node();
				area1.addNode(hiddenPix);
				centerPix.link(hiddenPix, ELinkType.REGULAR);
				
				try {
					centerPix.computeOutput(false);
				} catch (Exception e) {
					e.printStackTrace();
				}
				
				imageNode.scaleImage(2);
				imageNode.showImage(hiddenPix);
				
			}
		});
		
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
	}
	
	@Test
	public void testShowSimpleImage() {
		showImageSimple();
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
	
	private void showImageSimple(){
		
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
		
				Area areaOut = new Area(1);
				Node outNode = new Node();
				areaOut.addNode(outNode);
				//outNode.createBias();
				outNode.setActivationFx(EActivation.SYGMOID_0_1);
				outNode.setInnerNode(imageNode);
				
				int nbPixels = 10000;
				AreaSquare areaIn = new AreaSquare(nbPixels);
				PixelNode pixNode = null;
				Link link = null;
				double margeCarre = 5D;
				
				for(double idx = 1; idx <= nbPixels; idx++){
					
					pixNode = new PixelNode();
					areaIn.addNode(pixNode);
					pixNode.setNodeId((int) idx - 1);
					pixNode.link(outNode, ELinkType.REGULAR, false);
					link = Link.getInstance(ELinkType.REGULAR, false);
					pixNode.addInput(link);
					
					// les photorécepteurs sont continuellements activés même en l'absence de stimulis -> 0.5D
					if(pixNode.getX() > margeCarre && pixNode.getX() < (pixNode.getAreaSquare().getWidthPx() - margeCarre) && pixNode.getY() > margeCarre && pixNode.getY() < (pixNode.getAreaSquare().getHeightPx() - margeCarre))
						link.setUnlinkedValue(1D);
					else
						link.setUnlinkedValue(0D);
					
					
					try {
						pixNode.computeOutput(false);
					} catch (Exception e) {
						e.printStackTrace();
					}
				}

				imageNode.scaleImage(2);
				imageNode.showImage(outNode);
		
			}});
		

	}
	
	/**
	 * Test de la dérivée seconde de gaussienne
	 * ou les différences de luminance dans l'image.
	 * Vision : réalise un champ récépteur ON/OFF, liaisons des photorécépteurs (cones et batonnets) vers un neurone bipolaire puis
	 * vers un neurone ganglionnaire ON/OFF.
	 */
	@Test
	public void testShowGaussianImage() {
		
		
		//int nbPixels = 4;
		double N = 9D;
		double deltaX = 1;
		double k = 13D;
		double Ox = (N-1) * deltaX / k;
		double Oy = Ox;
		double alpha = 1D;
		double Mu = 0D;
		
		showImage( alpha, Ox, Oy, Mu);
		
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

	}
	
	private void showImage( final double alpha, final double ox, final double oy, final double mu){
		
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
				
				int nbPixels = 50 * 100;
				
				Network net = Network.getInstance();
				
				AreaSquare areaIn = new AreaSquare(50, 100, true);
				areaIn.getImageArea().scaleImage(2);
				Layer layerIn = new Layer(areaIn);
				
				AreaSquare area = new AreaSquare(50, 100, true);
				area.getImageArea().scaleImage(2);
				ILayer hiddenLayer = new Layer(area);
				
				net.addLayer(layerIn, hiddenLayer);
				
				PixelNode gaussNode = new PixelNode();
				gaussNode.setArea(area);
				gaussNode.setNodeId(5050);
				area.addNode(gaussNode);
				
				LaplacianOfGaussianLinkage linkage = new LaplacianOfGaussianLinkage();
				linkage.setLinkageAreas(ELinkageBetweenAreas.ONE_TO_ONE);

				linkage.setSigmaX(ox);
				linkage.setSigmaY(oy);
				linkage.setAlpha(alpha);
				linkage.setMu(mu);
				area.setLinkage(linkage);
				linkage.setArea(area);
				
				
				PixelNode pixNode = null;
				Link link = null;
				double margeCarre = 15D;
				
				for(int idx = 1; idx <= nbPixels; idx++){
					
					pixNode = new PixelNode();
					areaIn.addNode(pixNode);
					
					link = Link.getInstance(ELinkType.REGULAR, false);
					pixNode.addInput(link);
					
					// les photorécepteurs sont continuellements activés même en l'absence de stimulis -> 0.2D
					if(pixNode.getX() > margeCarre && pixNode.getX() < pixNode.getAreaSquare().getWidthPx() - margeCarre && pixNode.getY() > margeCarre && pixNode.getY() < pixNode.getAreaSquare().getHeightPx() - margeCarre)
						pixNode.setEntry(1D);
					else
						pixNode.setEntry(0D);
					
					
				}
				
				net.finalizeConnections();
				
				try {
					net.propagation(false);
				} catch (Exception e) {
					e.printStackTrace();
				}
				
				areaIn.showGradients(15D, 0D, 5, null);
				
				System.out.println(gaussNode.getString());
				
				int idx = 0;
				double somme = 0D;
				for(Link liaison : gaussNode.getInputs()){
					System.out.println(idx++ + " w"+ liaison.getSourceNode().getNodeId() + " : "+ liaison.getWeight());
					somme += liaison.getWeight();
				}
				System.out.println("Somme :" + somme);

				//areaIn.showImageArea();
				//area.showImageArea();
				
		
			}});
		

	}
	

	
	@Test
	public void testShowConvolutionImage() {
		
		
		showConvolutionImage();
		
		try {
			Thread.sleep(15000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

	}
	

	
	private void showConvolutionImage(){
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
		
				
				Image image = new Image("file:./resources/circle-square-1.png");
				int width = (int) image.getWidth();
				int height = (int) image.getHeight();
				int nbPixels = width * height;
				
				Network net = Network.getInstance(ENetworkImplementation.UNLINKED);
				
				AreaSquare inArea = new AreaSquare(width, height, true);
				inArea.configureLinkage(ELinkage.ONE_TO_ONE, null, false).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
				inArea.getImageArea().scaleImage(2);
				Layer inLayer = new Layer(inArea);
				
				AreaSquare hiddenArea = new AreaSquare(nbPixels/4, true);
				hiddenArea.configureLinkage(ELinkage.LOG_STATIC, null, 2, false).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels/4);
				hiddenArea.getImageArea().scaleImage(2);
				ILayer hiddenLayer = new Layer(hiddenArea);
				
				AreaSquare outArea = new AreaSquare(1);
				outArea.configureLinkage(ELinkage.MANY_TO_MANY, null, false).configureNode(false, ENodeType.PIXEL).createNodes(1);
				ILayer outLayer = new Layer(outArea);
				
				net.addLayer(inLayer, hiddenLayer, outLayer);
				
				
				net.finalizeConnections();
				
				
				System.out.println("Begin lecture image ...");
				PixelNode pixNode = null;
				PixelReader pixelReader = image.getPixelReader();
				for(int idx = 0; idx < nbPixels; idx++){
					pixNode = (PixelNode) inArea.getNode(idx);
					Color color = pixelReader.getColor(pixNode.getX(), pixNode.getY());
					pixNode.setEntry(color.getBrightness());

				}
				System.out.println("End lecture image.");
				
				try {
					net.propagation(false);
				} catch (Exception e) {
					e.printStackTrace();
				}
				
				
				inArea.showGradients(10D, 0D, 1, null);
				
				//System.out.println(net.getString());
				
		
			}});

	}
	
	@Test
	public void testShowConvolutionGaussianImage() {
		
		
//		Le traitement repose sur cinq paramètres :
//		
//			N représente la taille du masque (matrice carrée) implantant le filtre LOG. N est impair.
//			σ permet d'ajuster la taille du chapeau mexicain.
//			∆x et ∆y sont les pas d'échantillonnage utilisés pour discrétiser h''(x,y). Généralement ∆x = ∆ y
//			S est le seuil qui permet de sélectionner les contours les plus marqués.
//		
//			Il est à noter que le choix des paramètres N, σ et ∆x ne doit pas se faire de façon indépendante. 
//  		En effet, le masque, même de taille réduite, doit ressembler à un chapeau mexicain. Le problème ici est le même que celui que l'on rencontre lors de l'échantillonnage d'une fonction gaussienne. 
//          Le nombre de points N à considérer doit être tel que l'étendue occupe l'intervalle [-3σ , 3σ].
//			En fonction du pas d'échantillonnage, l'étendue spatiale vaut : (N-1) ∆x  .
//			Cette étendue peut aussi s'écrire en fonction de σ : (N-1) ∆x = kσ  avec k entier.
//			En prenant par exemple  ∆x = 1 , il s'agit de choisir N et σ de sorte que l'étendue du chapeau mexicain soit pertinente. 
//  		Pour le chapeau mexicain, la valeur de k doit être au moins de 4.
		
		double N = 3D;
		double deltaX = 1;
		double k = 4D;
		double Ox = (N-1) * deltaX / k;
		double Oy = Ox;
		double alpha = 1D;
		double Mu = 0D;
		
		
		//showLearningConvolutionGaussianImage(Ox, Oy, Mu, alpha);
		//showConvolutionGaussianImage(Ox, Oy, Mu, alpha);
		//showMultiScale(Ox, Oy, Mu, alpha);
		showMultiScale0(Ox, Oy, Mu, alpha);
		//showMultiScale2(Ox, Oy, Mu, alpha);
		//showDetectionCoinsImage(Ox, Oy, Mu, alpha);
			

		
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

	}
	
	private void showLearningConvolutionGaussianImage( final double ox, final double oy, final double mu, final double alpha){
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
		
				Image image = new Image("file:./resources/icon_128x128.png");
				int nbPixels = (int) (image.getWidth() * image.getHeight());
				
				
				Network net = Network.getInstance(ENetworkImplementation.LINKED);
				
				AreaSquare inArea = new AreaSquare(nbPixels, true);
				Layer inLayer = new Layer(inArea);
				
				AreaSquare hiddenArea = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer = new Layer(hiddenArea);
				
				AreaSquare hidden2Area = new AreaSquare(nbPixels / 4, true);
				ILayer hidden2Layer = new Layer(hidden2Area);
				
				AreaSquare outArea = new AreaSquare(625, true);
				ILayer outLayer = new Layer(outArea);
				
				net.addLayer(inLayer, hiddenLayer, hidden2Layer, outLayer);
				
				inArea.configureLinkage(ELinkage.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				inArea.getImageArea().scaleImage(2);
				
				double k = 1.106D;
				double f = 6D;
				hiddenArea.configureLinkage(ELinkage.SONAG, null, false, f * k).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea.getImageArea().scaleImage(2);
				
				hidden2Area.configureLinkage(ELinkage.MAX_POOLING, null, false, 3D, 2D).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels / 4);
				hidden2Area.getImageArea().scaleImage(2);
				
				outArea.configureLinkage(ELinkage.MANY_TO_MANY, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(625);
				outArea.getImageArea().scaleImage(2);
				
				net.finalizeConnections();
				
				//Image noir et blanc en input
				System.out.println("Begin lecture image ...");
				PixelNode pixNode = null;
				PixelReader pixelReader = image.getPixelReader();
				Color color = null;
				for(int idx = 0; idx < nbPixels; idx++){
					pixNode = (PixelNode) inArea.getNode(idx);
					color = pixelReader.getColor(pixNode.getX(), pixNode.getY());
					pixNode.setEntry(color.getOpacity());
				}
				System.out.println("End lecture image.");
				
				try {
					net.propagation(false);
				} catch (Exception e) {
					e.printStackTrace();
				}
				
				//System.out.println(net.getNode(1, 0, 5050).getString());
				//net.getNode(1, 0, 5050).getArea().filterToString(FilterLinkage.ID_FILTER_LOG);
				//net.getNode(1, 0, 5050).getArea().filterToString(1);
				//System.out.println(net.getString());
		
			}});

	}
	
	private void showConvolutionGaussianImage( final double ox, final double oy, final double mu, final double alpha){
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
		
				Image image = new Image("file:./resources/icon_128x128.png");
				int nbPixels = (int) (image.getWidth() * image.getHeight());
				
				
				Network net = Network.getInstance(ENetworkImplementation.UNLINKED);
				
				AreaSquare inArea = new AreaSquare(nbPixels, true);
				AreaSquare in2Area = new AreaSquare(nbPixels, true);
				Layer inLayer = new Layer(inArea, in2Area);
				
				AreaSquare hiddenArea = new AreaSquare(nbPixels, true);
				AreaSquare hidden2Area = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer = new Layer(hiddenArea);
				
				
				
				AreaSquare outArea = new AreaSquare(nbPixels, true);
				ILayer outLayer = new Layer(outArea);
				
				net.addLayer(inLayer, hiddenLayer, outLayer);
				
//				inArea.configureLinkage(ELinkage.ONE_TO_ONE, null, false).configureNode(true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(nbPixels);
//				inArea.getImageArea().scaleImage(2);
//				inArea.initBiasWeights(-0.5D);
//				
//				in2Area.configureLinkage(ELinkage.ONE_TO_ONE, null, false).configureNode(true, EActivation.SYGMOID_0_1_INVERSE, ENodeType.PIXEL).createNodes(nbPixels);
//				in2Area.getImageArea().scaleImage(2);
//				inArea.initBiasWeights(0.5D);
				
				inArea.configureLinkage(ELinkage.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				inArea.getImageArea().scaleImage(2);
				in2Area.configureLinkage(ELinkage.ONE_TO_ONE, null, false).configureNode(false, EActivation.NEGATIVE, ENodeType.PIXEL).createNodes(nbPixels);
				in2Area.getImageArea().scaleImage(2);
				
				
				double k = 1.106D;
				double f = 2D;
				hiddenArea.configureLinkage(ELinkage.ONE_TO_ONE, ELinkageBetweenAreas.MANY_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea.getImageArea().scaleImage(2);
				
//				hidden2Area.configureLinkage(ELinkage.ONE_TO_ONE_FETCH_AREA, null, false).configureNode(false, EActivation.NEGATIVE, ENodeType.GAUSSIAN).createNodes(nbPixels);
//				hidden2Area.getImageArea().scaleImage(2);
				
				outArea.configureLinkage(ELinkage.ONE_TO_ONE_FETCH_OCTAVE_AREA, null, false).configureNode( false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				outArea.getImageArea().scaleImage(2);
				
				
				//net.finalizeConnections();
				
				//Image noir et blanc en input
				System.out.println("Begin lecture image ...");
				PixelNode pixNode = null;
				PixelNode pix2Node = null;
				PixelReader pixelReader = image.getPixelReader();
				for(int idx = 0; idx < nbPixels; idx++){
					pixNode = (PixelNode) inArea.getNode(idx);
					pix2Node = (PixelNode) in2Area.getNode(idx);
					Color color = pixelReader.getColor(pixNode.getX(), pixNode.getY());
					pixNode.setEntry(color.getOpacity());
					pix2Node.setEntry(color.getOpacity());
				}
				System.out.println("End lecture image.");
				
				try {
					net.propagation(false);
				} catch (Exception e) {
					e.printStackTrace();
				}
				
				//System.out.println(net.getNode(1, 0, 5050).getString());
				//net.getNode(1, 0, 5050).getArea().filterToString(FilterLinkage.ID_FILTER_LOG);
				//net.getNode(1, 0, 5050).getArea().filterToString(1);
				
		
			}});

	}
	
	private void showMultiScale(final double ox, final double oy, final double mu, final double alpha){
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
		
				Image image = new Image("file:./resources/square-2.png");
				int nbPixels = (int) (image.getWidth() * image.getHeight());
				
				Network net = Network.getInstance(ENetworkImplementation.UNLINKED);
				
				AreaSquare inArea = new AreaSquare(nbPixels, true);
				Layer inLayer = new Layer(inArea);
				
				AreaSquare hiddenArea_1_0 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_1 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_2 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_3 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_4 = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer = new Layer(hiddenArea_1_0, hiddenArea_1_1, hiddenArea_1_2, hiddenArea_1_3, hiddenArea_1_4);
				
				
				AreaSquare hiddenArea_2_0 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_1 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_2 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_3 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_4 = new AreaSquare(nbPixels, true);
				hiddenLayer.addAreas(hiddenArea_2_0, hiddenArea_2_1, hiddenArea_2_2, hiddenArea_2_3, hiddenArea_2_4);
				
				
				AreaSquare hiddenArea_3_0 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_3_1 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_3_2 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_3_3 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_3_4 = new AreaSquare(nbPixels, true);
				hiddenLayer.addAreas(hiddenArea_3_0, hiddenArea_3_1, hiddenArea_3_2, hiddenArea_3_3, hiddenArea_3_4);

				Area outArea = new AreaSquare(nbPixels, true);
				ILayer outLayer = new Layer(outArea);
				
				net.addLayer(inLayer, hiddenLayer, outLayer);
				
				
				PixelNode pixNode = null;
				
				inArea.configureLinkage(ELinkage.ONE_TO_ONE, null, false);
				inArea.configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				double t = 0D;
				double f = Math.pow(2D, t);
				double k = 1.106D;
				//double k = 1.6D;
				hiddenArea_1_0.configureLinkage(ELinkage.DOG, null, false, f * k).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_1.configureLinkage(ELinkage.DOG, null, false, f * Math.pow(k, 2D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_2.configureLinkage(ELinkage.DOG, null, false, f * Math.pow(k, 3D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_3.configureLinkage(ELinkage.DOG, null, false, f * Math.pow(k, 4D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_4.configureLinkage(ELinkage.DOG, null, false, f * Math.pow(k, 5D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				t = 1D;
				f = Math.pow(2D, t);
				hiddenArea_2_0.configureLinkage(ELinkage.DOG, null, false, f * k).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_1.configureLinkage(ELinkage.DOG, null, false, f * Math.pow(k, 2D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_2.configureLinkage(ELinkage.DOG, null, false, f * Math.pow(k, 3D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_3.configureLinkage(ELinkage.DOG, null, false, f * Math.pow(k, 4D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_4.configureLinkage(ELinkage.DOG, null, false, f * Math.pow(k, 5D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				
				t = 2D;
				f = Math.pow(2D, t);
				hiddenArea_3_0.configureLinkage(ELinkage.DOG, null, false, f * k).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_3_1.configureLinkage(ELinkage.DOG, null, false, f * Math.pow(k, 2D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_3_2.configureLinkage(ELinkage.DOG, null, false, f * Math.pow(k, 3D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_3_3.configureLinkage(ELinkage.DOG, null, false, f * Math.pow(k, 4D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_3_4.configureLinkage(ELinkage.DOG, null, false, f * Math.pow(k, 5D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
			
				outArea.configureLinkage(ELinkage.ONE_TO_ONE_FETCH_OCTAVE_AREA, null, false).configureNode( false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				
				long start = System.currentTimeMillis();
				net.finalizeConnections();
				long stop = System.currentTimeMillis();
				System.out.println("finalize Connections : " + (stop - start) / 1000l + " secondes");
				
				//Image noir et blanc en input
				PixelReader pixelReader = image.getPixelReader();
				for(int idx = 0; idx < nbPixels; idx++){
					pixNode = (PixelNode) inArea.getNode(idx);
					
					Color color = pixelReader.getColor(pixNode.getX(), pixNode.getY());
					pixNode.setEntry(color.grayscale().getBrightness());
					
				}
				
				System.out.println("Begin propagation...");
				start = System.currentTimeMillis();
				try {
					net.propagation(false);
				} catch (Exception e) {
					e.printStackTrace();
				}
				stop = System.currentTimeMillis();
				System.out.println("End propagation.");
				System.out.println("Propagation : " + (stop - start) / 1000l + " secondes");
				
				inArea.imageToString();
				hiddenArea_1_0.imageToString();
				hiddenArea_1_1.imageToString();
				hiddenArea_1_2.imageToString();
				hiddenArea_1_3.imageToString();
				hiddenArea_1_4.imageToString();
				
				//System.out.println(net.getNode(3, 0, 0).getString());
				//net.getNode(1, 0, 5050).getArea().filterToString(FilterLinkage.ID_FILTER_LOG);
				//net.getNode(2, 0, 5050).getArea().filterToString(FilterLinkage.ID_FILTER_V1Orientation);
		
			}});

	}
	
	private void showMultiScale0(final double ox, final double oy, final double mu, final double alpha){
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
				
				Image image = new Image("file:./resources/square-2.png");
				int nbPixels = (int) (image.getWidth() * image.getHeight());
				
				Network net = Network.getInstance(ENetworkImplementation.UNLINKED);
				
				AreaSquare inArea = new AreaSquare(nbPixels, true);
				Layer inLayer = new Layer(inArea);
				
				AreaSquare hiddenArea_0_0 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_0_1 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_0_2 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_0_3 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_0_4 = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer0 = new Layer(hiddenArea_0_0, hiddenArea_0_1, hiddenArea_0_2, hiddenArea_0_3, hiddenArea_0_4);
				
				//------------- 
				
				AreaSquare hiddenArea_1_0 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_1 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_2 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_3 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_4 = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer1 = new Layer(hiddenArea_1_0, hiddenArea_1_1, hiddenArea_1_2, hiddenArea_1_3, hiddenArea_1_4);
				
				
				//------------- 
				
				AreaSquare hiddenArea_2_0 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_1 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_2 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_3 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_4 = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer2 = new Layer(hiddenArea_2_0, hiddenArea_2_1, hiddenArea_2_2, hiddenArea_2_3, hiddenArea_2_4);
				
				AreaSquare outArea = new AreaSquare(nbPixels, true);
				ILayer outLayer = new Layer(outArea);
				
				
				net.addLayer(inLayer, hiddenLayer0, hiddenLayer1, hiddenLayer2, outLayer);
				
				PixelNode pixNode = null;
				
				inArea.configureLinkage(ELinkage.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				double t = 0D;
				double f = Math.pow(2D, t);
				//double k = 1.106D;
				double k = 1.3D;
				//double k = 1.6D;
				hiddenArea_0_0.configureLinkage(ELinkage.GAUSSIAN, null, false, f * k).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_0_1.configureLinkage(ELinkage.GAUSSIAN, null, false, f * Math.pow(k, 2D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_0_2.configureLinkage(ELinkage.GAUSSIAN, null, false, f * Math.pow(k, 3D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_0_3.configureLinkage(ELinkage.GAUSSIAN, null, false, f * Math.pow(k, 4D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_0_4.configureLinkage(ELinkage.GAUSSIAN, null, false, f * Math.pow(k, 5D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				
				hiddenArea_1_0.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_1.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_2.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_3.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_4.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				
				hiddenArea_2_0.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_1.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_2.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_3.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_4.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				outArea.configureLinkage(ELinkage.MANY_TO_MANY, ELinkageBetweenAreas.MANY_TO_ONE, null, true).configureNode(true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(10);
				
				
				long start = System.currentTimeMillis();
				net.finalizeConnections();
				long stop = System.currentTimeMillis();
				System.out.println("finalize Connections : " + (stop - start) / 1000l + " secondes");
				
				//Image noir et blanc en input
				PixelReader pixelReader = image.getPixelReader();
				for(int idx = 0; idx < nbPixels; idx++){
					pixNode = (PixelNode) inArea.getNode(idx);
					Color color = pixelReader.getColor(pixNode.getX(), pixNode.getY());
					pixNode.setEntry(color.getBrightness());
				}
				
				System.out.println("Begin propagation...");
				start = System.currentTimeMillis();
				try {
					net.propagation(false);
				} catch (Exception e) {
					e.printStackTrace();
				}
				stop = System.currentTimeMillis();
				System.out.println("End propagation.");
				System.out.println("Propagation : " + (stop - start) / 1000l + " secondes");
				
				
				List<KeyPoint> kpList1 = new ArrayList<KeyPoint>();
				for(IArea area : hiddenLayer2.getAreas()){
					kpList1.addAll(((OneToOneOctaveAreaLinkage) area.getLinkage()).getKeyPoints());
				}
				System.out.println("\n SQUARE 1 : nb key points: "+ kpList1.size());
				
				image = new Image("file:./resources/square-3.png");
				
				pixelReader = image.getPixelReader();
				for(int idx = 0; idx < nbPixels; idx++){
					pixNode = (PixelNode) inArea.getNode(idx);
					Color color = pixelReader.getColor(pixNode.getX(), pixNode.getY());
					pixNode.setEntry(color.getBrightness());
				}
				
				try {
					net.propagation(false);
				} catch (Exception e) {
					e.printStackTrace();
				}
				
				List<KeyPoint> kpList2 = new ArrayList<KeyPoint>();
				for(IArea area : hiddenLayer2.getAreas()){
					kpList2.addAll(((OneToOneOctaveAreaLinkage) area.getLinkage()).getKeyPoints());
				}

				System.out.println("\n SQUARE 3 : nb key points: "+ kpList2.size());
				
//				inArea.imageToString();
//				hiddenArea_0_0.imageToString();
//				inArea.compareArea(hiddenArea_0_0);
				
//				hiddenArea_1_0.imageToString();
//				hiddenArea_1_1.imageToString();
//				hiddenArea_1_2.imageToString();
//				hiddenArea_1_3.imageToString();
//				hiddenArea_1_4.imageToString();
				
				//hiddenArea_0_0.compareArea(hiddenArea_0_6);
				
			}
			
		});
	}
	
	private void showMultiScale2(final double ox, final double oy, final double mu, final double alpha){
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
		
				Image image = new Image("file:./resources/e-16x16.png");
				int nbPixels = (int) (image.getWidth() * image.getHeight());
				
				Network net = Network.getInstance(ENetworkImplementation.UNLINKED);
				
				AreaSquare inArea = new AreaSquare(nbPixels, true);
				Layer inLayer = new Layer(inArea);
				
				AreaSquare hiddenArea_0_0 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_0_1 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_0_2 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_0_3 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_0_4 = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer0 = new Layer();
				hiddenLayer0.addAreas(hiddenArea_0_0, hiddenArea_0_1, hiddenArea_0_2, hiddenArea_0_3, hiddenArea_0_4);
				
				
				AreaSquare hiddenArea_0_5 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_0_6 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_0_7 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_0_8 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_0_9 = new AreaSquare(nbPixels, true);
				hiddenLayer0.addAreas(hiddenArea_0_5, hiddenArea_0_6, hiddenArea_0_7, hiddenArea_0_8, hiddenArea_0_9);
				
				
				AreaSquare hiddenArea_0_10 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_0_11 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_0_12 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_0_13 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_0_14 = new AreaSquare(nbPixels, true);
				hiddenLayer0.addAreas(hiddenArea_0_10, hiddenArea_0_11, hiddenArea_0_12, hiddenArea_0_13, hiddenArea_0_14);
				
				//------------- 
				
				AreaSquare hiddenArea_1_0 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_1 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_2 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_3 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_4 = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer1 = new Layer(hiddenArea_1_0, hiddenArea_1_1, hiddenArea_1_2, hiddenArea_1_3, hiddenArea_1_4);
				
				
				AreaSquare hiddenArea_1_5 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_6 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_7 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_8 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_9 = new AreaSquare(nbPixels, true);
				hiddenLayer1.addAreas(hiddenArea_1_5, hiddenArea_1_6, hiddenArea_1_7, hiddenArea_1_8, hiddenArea_1_9);
				
				
				AreaSquare hiddenArea_1_10 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_11 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_12 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_13 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_1_14 = new AreaSquare(nbPixels, true);
				hiddenLayer1.addAreas(hiddenArea_1_10, hiddenArea_1_11, hiddenArea_1_12, hiddenArea_1_13, hiddenArea_1_14);
				
				//------------- 
				
				AreaSquare hiddenArea_2_0 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_1 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_2 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_3 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_4 = new AreaSquare(nbPixels, true);
				
				AreaSquare hiddenArea_2_5 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_6 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_7 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_8 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_9 = new AreaSquare(nbPixels, true);
				
				AreaSquare hiddenArea_2_10 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_11 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_12 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_13 = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea_2_14 = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer2 = new Layer(hiddenArea_2_0, hiddenArea_2_1, hiddenArea_2_2, hiddenArea_2_3, hiddenArea_2_4);
				hiddenLayer2.addAreas(hiddenArea_2_5, hiddenArea_2_6, hiddenArea_2_7, hiddenArea_2_8, hiddenArea_2_9);
				hiddenLayer2.addAreas(hiddenArea_2_10, hiddenArea_2_11, hiddenArea_2_12, hiddenArea_2_13, hiddenArea_2_14);
				
				//------------- 
				int pixCountL3 = 625;
				
				AreaSquare hiddenArea_3_0 = new AreaSquare(pixCountL3, true);
				AreaSquare hiddenArea_3_1 = new AreaSquare(pixCountL3, true);
				AreaSquare hiddenArea_3_2 = new AreaSquare(pixCountL3, true);
				AreaSquare hiddenArea_3_3 = new AreaSquare(pixCountL3, true);
				AreaSquare hiddenArea_3_4 = new AreaSquare(pixCountL3, true);
				
				AreaSquare hiddenArea_3_5 = new AreaSquare(pixCountL3, true);
				AreaSquare hiddenArea_3_6 = new AreaSquare(pixCountL3, true);
				AreaSquare hiddenArea_3_7 = new AreaSquare(pixCountL3, true);
				AreaSquare hiddenArea_3_8 = new AreaSquare(pixCountL3, true);

				
				ILayer hiddenLayer3 = new Layer(hiddenArea_3_0, hiddenArea_3_1, hiddenArea_3_2, hiddenArea_3_3, hiddenArea_3_4);
				hiddenLayer3.addAreas(hiddenArea_3_5, hiddenArea_3_6, hiddenArea_3_7, hiddenArea_3_8);

				AreaSquare outArea = new AreaSquare(nbPixels, true);
				ILayer outLayer = new Layer(outArea);
				
				net.addLayer(inLayer, hiddenLayer0, hiddenLayer1, hiddenLayer2, hiddenLayer3, outLayer);
				
				
				PixelNode pixNode = null;
				
				inArea.configureLinkage(ELinkage.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				double t = 0D;
				double f = Math.pow(2D, t);
				//double k = 1.106D;
				double k = 1.3D;
				//double k = 1.6D;
				hiddenArea_0_0.configureLinkage(ELinkage.GAUSSIAN, null, false, f * k).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_0_1.configureLinkage(ELinkage.GAUSSIAN, null, false, f * Math.pow(k, 2D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_0_2.configureLinkage(ELinkage.GAUSSIAN, null, false, f * Math.pow(k, 3D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_0_3.configureLinkage(ELinkage.GAUSSIAN, null, false, f * Math.pow(k, 4D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_0_4.configureLinkage(ELinkage.GAUSSIAN, null, false, f * Math.pow(k, 5D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				t = 1D;
				f = Math.pow(2D, t);
				hiddenArea_0_5.configureLinkage(ELinkage.GAUSSIAN, null, false, f * k).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_0_6.configureLinkage(ELinkage.GAUSSIAN, null, false, f * Math.pow(k, 2D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_0_7.configureLinkage(ELinkage.GAUSSIAN, null, false, f * Math.pow(k, 3D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_0_8.configureLinkage(ELinkage.GAUSSIAN, null, false, f * Math.pow(k, 4D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_0_9.configureLinkage(ELinkage.GAUSSIAN, null, false, f * Math.pow(k, 5D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				t = 2D;
				f = Math.pow(2D, t);
				hiddenArea_0_10.configureLinkage(ELinkage.GAUSSIAN, null, false, f * k).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_0_11.configureLinkage(ELinkage.GAUSSIAN, null, false, f * Math.pow(k, 2D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_0_12.configureLinkage(ELinkage.GAUSSIAN, null, false, f * Math.pow(k, 3D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_0_13.configureLinkage(ELinkage.GAUSSIAN, null, false, f * Math.pow(k, 4D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_0_14.configureLinkage(ELinkage.GAUSSIAN, null, false, f * Math.pow(k, 5D)).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				
				
				hiddenArea_1_0.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_1.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE,null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_2.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_3.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_4.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				hiddenArea_1_5.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_6.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_7.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_8.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_9.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				hiddenArea_1_10.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_11.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_12.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_13.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_1_14.configureLinkage(ELinkage.ONE_TO_ONE_FILTER, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				
				
				hiddenArea_2_0.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_1.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_2.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_3.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_4.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				hiddenArea_2_5.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_6.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_7.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_8.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_9.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				hiddenArea_2_10.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_11.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_12.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_13.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea_2_14.configureLinkage(ELinkage.ONE_TO_ONE_OCTAVE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				
				
				hiddenArea_3_0.configureLinkage(ELinkage.MANY_TO_MANY_OCTAVE, ELinkageBetweenAreas.MANY_TO_ONE, null, true).configureNode(true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(pixCountL3);
				hiddenArea_3_1.configureLinkage(ELinkage.MANY_TO_MANY_OCTAVE, ELinkageBetweenAreas.MANY_TO_ONE, null, true).configureNode(true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(pixCountL3);
				hiddenArea_3_2.configureLinkage(ELinkage.MANY_TO_MANY_OCTAVE, ELinkageBetweenAreas.MANY_TO_ONE, null, true).configureNode(true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(pixCountL3);
				hiddenArea_3_3.configureLinkage(ELinkage.MANY_TO_MANY_OCTAVE, ELinkageBetweenAreas.MANY_TO_ONE, null, true).configureNode(true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(pixCountL3);
				hiddenArea_3_4.configureLinkage(ELinkage.MANY_TO_MANY_OCTAVE, ELinkageBetweenAreas.MANY_TO_ONE, null, true).configureNode(true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(pixCountL3);
				
				hiddenArea_3_5.configureLinkage(ELinkage.MANY_TO_MANY_OCTAVE, ELinkageBetweenAreas.MANY_TO_ONE, null, true).configureNode(true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(pixCountL3);
				hiddenArea_3_6.configureLinkage(ELinkage.MANY_TO_MANY_OCTAVE, ELinkageBetweenAreas.MANY_TO_ONE, null, true).configureNode(true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(pixCountL3);
				hiddenArea_3_7.configureLinkage(ELinkage.MANY_TO_MANY_OCTAVE, ELinkageBetweenAreas.MANY_TO_ONE, null, true).configureNode(true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(pixCountL3);
				hiddenArea_3_8.configureLinkage(ELinkage.MANY_TO_MANY_OCTAVE, ELinkageBetweenAreas.MANY_TO_ONE, null, true).configureNode(true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(pixCountL3);

				
				
				outArea.configureLinkage(ELinkage.MANY_TO_MANY, ELinkageBetweenAreas.MANY_TO_ONE, null, true).configureNode(true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(10);
				
				
				long start = System.currentTimeMillis();
				net.finalizeConnections();
				long stop = System.currentTimeMillis();
				System.out.println("finalize Connections : " + (stop - start) / 1000l + " secondes");
				
				//Image noir et blanc en input
				PixelReader pixelReader = image.getPixelReader();
				for(int idx = 0; idx < nbPixels; idx++){
					pixNode = (PixelNode) inArea.getNode(idx);
					Color color = pixelReader.getColor(pixNode.getX(), pixNode.getY());
					pixNode.setEntry(color.getOpacity());
				}
				
				System.out.println("Begin propagation...");
				start = System.currentTimeMillis();
				try {
					net.propagation(false);
				} catch (Exception e) {
					e.printStackTrace();
				}
				stop = System.currentTimeMillis();
				System.out.println("End propagation.");
				System.out.println("Propagation : " + (stop - start) / 1000l + " secondes");
				
				
				List<KeyPoint> kpList1 = new ArrayList<KeyPoint>();
				for(IArea area : hiddenLayer2.getAreas()){
					kpList1.addAll(((OneToOneOctaveAreaLinkage) area.getLinkage()).getKeyPoints());
				}
				System.out.println("\n SQUARE 1 : nb key points: "+ kpList1.size());
				
				image = new Image("file:./resources/e-translated-16x16.png");
				
				pixelReader = image.getPixelReader();
				for(int idx = 0; idx < nbPixels; idx++){
					pixNode = (PixelNode) inArea.getNode(idx);
					Color color = pixelReader.getColor(pixNode.getX(), pixNode.getY());
					pixNode.setEntry(color.getOpacity());
				}
				
				try {
					net.propagation(false);
				} catch (Exception e) {
					e.printStackTrace();
				}
				
				List<KeyPoint> kpList2 = new ArrayList<KeyPoint>();
				for(IArea area : hiddenLayer2.getAreas()){
					kpList2.addAll(((OneToOneOctaveAreaLinkage) area.getLinkage()).getKeyPoints());
				}

				System.out.println("\n SQUARE 3 : nb key points: "+ kpList2.size());
				boolean keyPointMatches = true;
				for(KeyPoint kp1 : kpList1){
					for(Histogram histo1 : kp1.getDescriptor().getHistograms()){
						
						for(KeyPoint kp2 : kpList2){
							
							for(Histogram histo2 : kp2.getDescriptor().getHistograms()){
								
								if(histo1.getMaxOrientationKey() != null && histo2.getMaxOrientationKey() != null && histo1.getMaxOrientationKey() != histo2.getMaxOrientationKey()){
									keyPointMatches = false;
								}
								
							}
							if(keyPointMatches){
								System.out.println(kp1.getKeyPointNode() + " matches with keyPoint : " + kp2.getKeyPointNode());
							}
						}
					}
				}
				
				
//				hiddenArea_1_0.imageToString();
//				hiddenArea_1_1.imageToString();
//				hiddenArea_1_2.imageToString();
//				hiddenArea_1_3.imageToString();
//				hiddenArea_1_4.imageToString();
				
				//hiddenArea_0_0.imageToString();
				//hiddenArea_0_14.imageToString();
				
				//hiddenArea_0_0.compareArea(hiddenArea_0_6);
				
				//System.out.println(net.getString());
				
				//System.out.println(net.getNode(3, 0, 0).getString());
				//net.getNode(1, 0, 5050).getArea().filterToString(FilterLinkage.ID_FILTER_LOG);
				//net.getNode(2, 0, 5050).getArea().filterToString(FilterLinkage.ID_FILTER_V1Orientation);
		
			}});

	}
	
	@Test
	public void testArchitecture() {
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
		
				//Image noir et blanc en input
				Image image = new Image("file:D:\\git\\deepnet\\resources\\bikes.jpg");
				
				int nbPixels = (int) (image.getHeight() * image.getWidth());
				
				
				Network net = Network.getInstance(ENetworkImplementation.UNLINKED);
				
				AreaSquare inArea = new AreaSquare(nbPixels, true);
				Layer inLayer = new Layer(inArea);
				
				AreaSquare hiddenArea = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer = new Layer(hiddenArea);
				
				AreaSquare hidden_1_0_Area = new AreaSquare(nbPixels, true);
				AreaSquare hidden_1_1_Area = new AreaSquare(nbPixels, true);
				AreaSquare hidden_1_2_Area = new AreaSquare(nbPixels, true);
				AreaSquare hidden_1_3_Area = new AreaSquare(nbPixels, true);
				AreaSquare hidden_1_4_Area = new AreaSquare(nbPixels, true);
				ILayer hidden1Layer = new Layer(hidden_1_0_Area, hidden_1_1_Area, hidden_1_2_Area, hidden_1_3_Area);
				
				AreaSquare hidden2Area = new AreaSquare(nbPixels, true);
				ILayer hidden2Layer = new Layer(hidden2Area);
				
				AreaSquare outArea = new AreaSquare(9, true);
				ILayer outLayer = new Layer(outArea);
				
				net.addLayer(inLayer, hiddenLayer, hidden1Layer, hidden2Layer, outLayer);
				
				
				PixelNode pixNode = null;
				
				inArea.configureLinkage(ELinkage.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL)
						.createNodes(nbPixels);
				
				hiddenArea.configureLinkage(ELinkage.LOG, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL)
							.createNodes(nbPixels);
				
				hidden_1_0_Area.configureLinkage(ELinkage.LOG_GABOR2, null, false, 8D, 3D, 1D, 2D).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hidden_1_1_Area.configureLinkage(ELinkage.LOG_GABOR2, null, false, 8D, 3D, 2D, 2D).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hidden_1_2_Area.configureLinkage(ELinkage.LOG_GABOR2, null, false, 8D, 3D, 3D, 2D).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				hidden_1_3_Area.configureLinkage(ELinkage.LOG_GABOR2, null, false, 8D, 3D, 4D, 2D).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
//				hidden_1_1_Area.configureLinkage(ELinkage.V1_ORIENTATIONS, null, false, 45D).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
//				hidden_1_2_Area.configureLinkage(ELinkage.V1_ORIENTATIONS, null, false, 90D).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
//				hidden_1_3_Area.configureLinkage(ELinkage.V1_ORIENTATIONS, null, false, 135D).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
//				hidden_1_4_Area.configureLinkage(ELinkage.V1_ORIENTATIONS, null, false, 180D).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				hidden2Area.configureLinkage(ELinkage.ONE_TO_ONE, ELinkageBetweenAreas.MANY_TO_ONE, null, false).configureNode(true, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(nbPixels);
				
				outArea.configureLinkage(ELinkage.MANY_TO_MANY, null, false).configureNode( true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(1);
				
				
				net.finalizeConnections();
				
				PixelReader pixelReader = image.getPixelReader();
				Color color = null;
				for(int idx = 0; idx < nbPixels; idx++){
					pixNode = (PixelNode) inArea.getNode(idx);
					color = pixelReader.getColor(pixNode.getX(), pixNode.getY());
					pixNode.setEntry(color.getBrightness());
					
				}
				
				
				System.out.println("Begin propagation...");
				try {
					net.propagation(false);
				} catch (Exception e) {
					e.printStackTrace();
				}
				System.out.println("End propagation.");
				
				
//				System.out.println(net.getNode(3, 0, 0).getString());
//				net.getNode(1, 0, 5050).getArea().getFilter(FilterLinkage.ID_FILTER_LOG).filterToString();
//				net.getNode(2, 0, 5050).getArea().getFilter(FilterLinkage.ID_FILTER_V1Orientation).filterToString();
				
			}});
		
		try {
			Thread.sleep(6000000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
	private void showDetectionCoinsImage( final double ox, final double oy, final double mu, final double alpha){
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
		
				int nbPixels = 10000;
				int pixelGaussianNodes = 10000;
				
				ImageNode imageNode0 = new ImageNode(EActivation.IDENTITY);
				ImageNode imageNode1 = new ImageNode(EActivation.IDENTITY);
				ImageNode imageNode2 = new ImageNode(EActivation.IDENTITY);
				ImageNode imageNode3 = new ImageNode(EActivation.IDENTITY);
				ImageNode imageNode4 = new ImageNode(EActivation.IDENTITY);
				ImageNode imageNode5 = new ImageNode(EActivation.IDENTITY);
				
				Network net = Network.getInstance();
				
				AreaSquare inArea = new AreaSquare(nbPixels, true, "Input");
				Layer inLayer = new Layer(inArea);
				net.addLayer(inLayer);
				
				AreaSquare hiddenArea_1 = new AreaSquare(nbPixels, true, "Simple contour");
				Layer hiddenLayer_1 = new Layer(hiddenArea_1);
				net.addLayer(hiddenLayer_1);
				
				AreaSquare hiddenArea_2_0 = new AreaSquare(nbPixels, true, "Pass by 0 - X");
				AreaSquare hiddenArea_2_1 = new AreaSquare(nbPixels, true, "Pass by 0 - Y");
				Layer hiddenLayer_2 = new Layer(hiddenArea_2_0, hiddenArea_2_1);
				net.addLayer(hiddenLayer_2);
				
				AreaSquare hiddenArea_3 = new AreaSquare(nbPixels, true, "One to one fetch area - regular node");
				Layer hiddenLayer_3 = new Layer(hiddenArea_3);
				net.addLayer(hiddenLayer_3);
				
				Area outArea = new Area(1);
				Layer outLayer = new Layer(outArea);
				net.addLayer(outLayer);
				
				
				inArea.configureLinkage(ELinkage.ONE_TO_ONE, null, false).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
				
				hiddenArea_1.configureLinkage(ELinkage.LOG, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(pixelGaussianNodes);
				
				hiddenArea_2_0.configureLinkage(ELinkage.FIRST_DERIVATED_GAUSSIAN, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(pixelGaussianNodes);
				hiddenArea_2_0.getImageArea().scaleImage(2);
				
				hiddenArea_2_1.configureLinkage(ELinkage.FIRST_DERIVATED_GAUSSIAN, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(pixelGaussianNodes);
				hiddenArea_2_1.getImageArea().scaleImage(2);
				
				//hiddenArea_2.configureNode(false, EActivation.IDENTITY, ELinkage.GENERIC, false, ENodeType.PASSBY0).configureLinkageFunction(ESamples.G_Dxy_DE_MARR).createNodes(pixelGaussianNodes);
				
				hiddenArea_3.configureLinkage(ELinkage.ONE_TO_ONE, ELinkageBetweenAreas.MANY_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(pixelGaussianNodes);
				hiddenArea_2_1.getImageArea().scaleImage(2);

				outArea.configureLinkage(ELinkage.MANY_TO_MANY, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.PIXEL).createNodes(1);
				
				net.finalizeConnections();
				
				//Image noir et blanc en input
				System.out.println("Begin lecture image ...");
				PixelNode pixNode = null;
				Image image = new Image("file:./resources/logo-transparent.png");
				PixelReader pixelReader = image.getPixelReader();
				for(int idx = 0; idx < nbPixels; idx++){
					pixNode = (PixelNode) inArea.getNode(idx);
					Color color = pixelReader.getColor(pixNode.getX(), pixNode.getY());
					pixNode.getInput(0).setUnlinkedValue(color.getBrightness());
					
				}
				System.out.println("End lecture image.");
				
//				net.getNode(0, 0, 5050).setInnerNode(imageNode0);
//				net.getNode(1, 0, 5050).setInnerNode(imageNode1);
//				net.getNode(2, 0, 5050).setInnerNode(imageNode2);
//				net.getNode(2, 1, 5050).setInnerNode(imageNode3);
//				net.getNode(2, 2, 0).setInnerNode(imageNode4);
//				net.getNode(3, 0, 5050).setInnerNode(imageNode5);
//				net.getNode(4, 0, 0).setInnerNode(imageNode);
				
				try {
					net.propagation(false);
				} catch (Exception e) {
					e.printStackTrace();
				}
				
				//System.out.println(net.getNode(1, 0, 5050).getString());
				//System.out.println(net.getNode(2, 0, 5050).getString());
				System.out.println(net.getNode(3, 0, 5050).getString());
				//net.getNode(1, 0, 5050).getArea().filterToString(FilterLinkage.ID_FILTER_LOG_STATIC);
				//hiddenArea_1.imageToString();
				hiddenArea_3.imageToString();
				//hiddenArea_2_0.compareArea(hiddenArea_2_1);
				
				//net.getNode(1, 0, 5050).getArea().filterToString(1);
				
		
			}});

	}

	@Test
	public void testFinalizeConnections() {
		fail("Not yet implemented");
	}

	@Test
	public void testSublayerFanOutCrossLinkage() {
		fail("Not yet implemented");
	}

	@Test
	public void testNextLayerFanOutCrossLinkage() {
		fail("Not yet implemented");
	}

	@Test
	public void testLink() {
		fail("Not yet implemented");
	}

	@Test
	public void testDoubleLink() {
		fail("Not yet implemented");
	}

	@Test
	public void testSelfLink() throws Exception {
//		node.selfLink();
//		inputLink.setUnlinkedValue(1.0D);
//		node.computeOutput(false);
//		assertEquals(1.0D, node.getComputedOutput(), 0.0D);
//		node.computeOutput(false);
//		assertEquals(2.0D, node.getComputedOutput(), 0.0D);
//		node.computeOutput(false);
//		assertEquals(3.0D, node.getComputedOutput(), 0.0D);
//		node.computeOutput(false);
//		assertEquals(4.0D, node.getComputedOutput(), 0.0D);		
	}

	@Test
	public void testComputeOutput() throws Exception {
		
//		node.computeOutput(false);
//		assertEquals(0.0D, node.getComputedOutput(), 0.0D);
//		
//		inputLink.setUnlinkedValue(2.0D);
//		node.computeOutput(false);
//		assertEquals(2.0D, node.getComputedOutput(), 0.0D);
//		
//		node.setActivationFx(EActivation.SYGMOID_0_1);
//		inputLink.setUnlinkedValue(0.0D);
//		node.computeOutput(false);
//		assertEquals(0.5D, node.getComputedOutput(), 0.0D);
//		
//		node.setActivationFx(EActivation.SYGMOID_1_1);
//		inputLink.setUnlinkedValue(0.0D);
//		node.computeOutput(false);
//		assertEquals(0.0D, node.getComputedOutput(), 0.0D);
	}

	@Test
	public void testPerformActivationFunction() {
		fail("Not yet implemented");
	}

	@Test
	public void testPerformDerivativeFunction() {
		fail("Not yet implemented");
	}

	@Override
	public void start(Stage primaryStage) throws Exception {
		// TODO Auto-generated method stub
		
	}

}
package RN.tests;

import static org.junit.Assert.fail;
import junit.framework.Assert;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import RN.algoactivations.EActivation;
import RN.links.ELinkType;
import RN.links.Link;
import RN.nodes.LSTMNode;
import RN.nodes.Node;

public class TestLSTMNode {

	private LSTMNode node = null;
	private Link inputLink = null;
	private Link outputLink = null;
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
	}

	@Before
	public void setUp() throws Exception {
		node = new LSTMNode(1);
		inputLink = Link.getInstance(ELinkType.REGULAR, true);
		node.addInput(inputLink);
		outputLink = Link.getInstance(ELinkType.REGULAR, true);
		node.addOutput(outputLink);
	}

	@After
	public void tearDown() throws Exception {
		node = null;
	}

	@Test
	public void testDisconnect() {
//		Assert.assertTrue(node.getInputs().size() > 0);
//		Assert.assertTrue(node.getOutputs().size() > 0);
//		node.disconnect();
//		Assert.assertEquals(0, node.getInputs().size());
//		Assert.assertEquals(0, node.getOutputs().size());
	}

	@Test
	public void testFinalizeConnections() {
		fail("Not yet implemented");
	}

	@Test
	public void testSublayerFanOutCrossLinkage() {
		fail("Not yet implemented");
	}

	@Test
	public void testNextLayerFanOutCrossLinkage() {
		fail("Not yet implemented");
	}

	@Test
	public void testLink() {
		fail("Not yet implemented");
	}

	@Test
	public void testDoubleLink() {
		fail("Not yet implemented");
	}

	@Test
	public void testSelfLink() throws Exception {
//		node.selfLink();
//		inputLink.setUnlinkedValue(1.0D);
//		node.computeOutput(false);
//		Assert.assertEquals(1.0D, node.getComputedOutput(), 0.0D);
//		node.computeOutput(false);
//		Assert.assertEquals(2.0D, node.getComputedOutput(), 0.0D);
//		node.computeOutput(false);
//		Assert.assertEquals(3.0D, node.getComputedOutput(), 0.0D);
//		node.computeOutput(false);
//		Assert.assertEquals(4.0D, node.getComputedOutput(), 0.0D);		
	}

	@Test
	public void testComputeOutput() throws Exception {
		
		node.computeOutput(false);
		Assert.assertEquals(0.0D, node.getComputedOutput(), 0.0D);
		
		inputLink.setUnlinkedValue(2.0D);
		node.computeOutput(false);
		Assert.assertEquals(2.0D, node.getComputedOutput(), 0.0D);
		
		node.setActivationFx(EActivation.SYGMOID_0_1);
		inputLink.setUnlinkedValue(0.0D);
		node.computeOutput(false);
		Assert.assertEquals(0.5D, node.getComputedOutput(), 0.0D);
	}

	@Test
	public void testPerformActivationFunction() {
		fail("Not yet implemented");
	}

	@Test
	public void testPerformDerivativeFunction() {
		fail("Not yet implemented");
	}
	


	@Test
	public void testGetString() {
		fail("Not yet implemented");
	}

	@Test
	public void testLSTMNode() {
		fail("Not yet implemented");
	}

	@Test
	public void testGetInput() {
		fail("Not yet implemented");
	}

	@Test
	public void testGetInputGate() {
		fail("Not yet implemented");
	}

	@Test
	public void testGetForgetGate() {
		fail("Not yet implemented");
	}

	@Test
	public void testGetOutputGate() {
		fail("Not yet implemented");
	}

	@Test
	public void testIsBidirectional() {
		fail("Not yet implemented");
	}

	@Test
	public void testSetBidirectional() {
		fail("Not yet implemented");
	}

	@Test
	public void testGetMemory() {
		fail("Not yet implemented");
	}

	@Test
	public void testGetOutputProductUnit() {
		fail("Not yet implemented");
	}

}
package RN.tests;

import static org.junit.Assert.assertEquals;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import RN.Area;
import RN.Layer;
import RN.Network;
import RN.algoactivations.EActivation;
import RN.dataset.OutputData;
import RN.linkage.ELinkage;
import RN.links.ELinkType;
import RN.links.Link;
import RN.nodes.ENodeType;

public class TestNetworkClock {

	static Network net = null;
	static Layer layerIn = null;
	static Area area = null;
	static Layer layerHidden = null;
	static Layer layerOut = null;
	static Link lateralLink = null;
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
	}

	@Before
	public void setUp() throws Exception {
		
		net = Network.newInstance(null);
		
		layerIn = new Layer();
		net.addLayer(layerIn);
		area = new Area(2);
		layerIn.addArea(area);
		area.configureLinkage(ELinkage.ONE_TO_ONE, null, false).configureNode(false, EActivation.IDENTITY, ENodeType.REGULAR).createNodes(2);
		
		
		layerHidden = new Layer(EActivation.SYGMOID_0_1);
		area = new Area(2);
		layerHidden.addArea(area);
		net.addLayer(layerHidden);
		area.configureLinkage(ELinkage.MANY_TO_MANY, null, false).configureNode( true, EActivation.IDENTITY, ENodeType.REGULAR).createNodes(2);
		
		layerOut = new Layer(EActivation.SYGMOID_0_1);
		net.addLayer(layerOut);
		area = new Area(1);
		layerOut.addArea(area);
		area.configureLinkage(ELinkage.MANY_TO_MANY, null, false).configureNode( true, EActivation.IDENTITY, ENodeType.REGULAR).createNodes(1);
		
		
		lateralLink = net.getNode(0, 0, 0).link(net.getNode(0, 0, 1), ELinkType.RECURRENT_LATERAL_LINK);
		
		net.finalizeConnections();
		
	}

	@After
	public void tearDown() throws Exception {
		net.initContext();
	}

	@Test
	public void testPropagation() throws Exception {
		OutputData output = net.propagation(false);
		//assertEquals(0.92144305166011564706487433388853755619310805569255489568539596908292519094472012246622682774908194908331567855012601684D, output.getOutput(0), 0);
		//assertEquals(new SygmoidPerformer().perform(new SygmoidPerformer().perform(-1) * 2 - 1), output.getOutput(0), 0);
		output = net.propagation(false);
		assertEquals(0.92144305166011564706487433388853755619310805569255489568539596908292519094472012246622682774908194908331567855012601684D, output.getOutput(0), 0);
		output = net.propagation(false);
		assertEquals(0.92144305166011564706487433388853755619310805569255489568539596908292519094472012246622682774908194908331567855012601684D, output.getOutput(0), 0);
		
	}
	
	@Test
	public void testClock() throws Exception {
		
		net.getNode(0, 0, 0).getInput(0).setUnlinkedValue(3.0D);
		
		assertEquals(-1, net.getContext().getClock());
		assertEquals(0, lateralLink.getFireTimeT());
		
		net.propagation(false);
		
		assertEquals(0, net.getContext().getClock());		
		assertEquals(1, lateralLink.getFireTimeT());
		
		net.propagation(false);
		
		assertEquals(1, net.getContext().getClock());		
		assertEquals(2, lateralLink.getFireTimeT());

	}
	

}
package RN.tests;

import static org.junit.Assert.*;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import RN.algoactivations.EActivation;
import RN.links.ELinkType;
import RN.links.Link;
import RN.nodes.Node;

public class TestNode {

	private Node node = null;
	private Link inputLink = null;
	private Link outputLink = null;
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
	}

	@Before
	public void setUp() throws Exception {
		node = new Node(EActivation.IDENTITY);
		inputLink = Link.getInstance(ELinkType.REGULAR, true);
		node.addInput(inputLink);
		outputLink = Link.getInstance(ELinkType.REGULAR, true);
		node.addOutput(outputLink);
	}

	@After
	public void tearDown() throws Exception {
		node = null;
	}

	@Test
	public void testDisconnect() {
		assertTrue(node.getInputs().size() > 0);
		assertTrue(node.getOutputs().size() > 0);
		node.disconnect();
		assertEquals(0, node.getInputs().size());
		assertEquals(0, node.getOutputs().size());
	}

	@Test
	public void testFinalizeConnections() {
		fail("Not yet implemented");
	}

	@Test
	public void testSublayerFanOutCrossLinkage() {
		fail("Not yet implemented");
	}

	@Test
	public void testNextLayerFanOutCrossLinkage() {
		fail("Not yet implemented");
	}

	@Test
	public void testLink() {
		fail("Not yet implemented");
	}

	@Test
	public void testDoubleLink() {
		fail("Not yet implemented");
	}

	@Test
	public void testSelfLink() throws Exception {
		node.selfLink();
		inputLink.setUnlinkedValue(1.0D);
		node.computeOutput(false);
		assertEquals(1.0D, node.getComputedOutput(), 0.0D);
		node.computeOutput(false);
		assertEquals(2.0D, node.getComputedOutput(), 0.0D);
		node.computeOutput(false);
		assertEquals(3.0D, node.getComputedOutput(), 0.0D);
		node.computeOutput(false);
		assertEquals(4.0D, node.getComputedOutput(), 0.0D);		
	}

	@Test
	public void testComputeOutput() throws Exception {
		
		node.computeOutput(false);
		assertEquals(0.0D, node.getComputedOutput(), 0.0D);
		
		inputLink.setUnlinkedValue(2.0D);
		node.computeOutput(false);
		assertEquals(2.0D, node.getComputedOutput(), 0.0D);
		
		node.setActivationFx(EActivation.SYGMOID_0_1);
		inputLink.setUnlinkedValue(0.0D);
		node.computeOutput(false);
		assertEquals(0.5D, node.getComputedOutput(), 0.0D);
		
		node.setActivationFx(EActivation.SYGMOID_1_1);
		inputLink.setUnlinkedValue(0.0D);
		node.computeOutput(false);
		assertEquals(0.0D, node.getComputedOutput(), 0.0D);
	}

	@Test
	public void testPerformActivationFunction() {
		fail("Not yet implemented");
	}

	@Test
	public void testPerformDerivativeFunction() {
		
//		double d = 1234567890.123456;
//		int i = new Double(d).intValue(); //recuperer la partie entiere
//		double decimale = d-(new Double(i).doubleValue());
		
		int nbWidth = 10000;
		
		for(int n = 0; n < nbWidth; n+=100){
			int width = n;
			int x;
			int y;
			Double val;
			int index = 0;
			System.out.println("width="+n);
			for(int idy = 0; idy < width; idy++){
				for(int idx = 0; idx < width; idx++){
					
					val = new Double(index / width);
					y = val.intValue();
					x =  index - y * width;
					
					//System.out.println("reel (x,y) = ("+ idx+","+idy+")  ->   val=" + val + "  (x,y) = ("+x+","+y+")");
					
					assertEquals(x, idx, 0.0D);
					assertEquals(y, idy, 0.0D);
					
					index++;
				}
			}
		
		}
		
		
	}
	

}
package RN.tests;

import static org.junit.Assert.*;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import RN.algoactivations.EActivation;
import RN.links.ELinkType;
import RN.links.Link;
import RN.nodes.Node;

public class TestNodeWithBias {

	private Node node = null;
	private Link inputLink = null;
	private Link outputLink = null;
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
	}

	@Before
	public void setUp() throws Exception {
		node = new Node(EActivation.IDENTITY);
		node.createBias();
		inputLink = Link.getInstance(ELinkType.REGULAR, true);
		node.addInput(inputLink);
		outputLink = Link.getInstance(ELinkType.REGULAR, true);
		node.addOutput(outputLink);
	}

	@After
	public void tearDown() throws Exception {
		node = null;
	}

	@Test
	public void testDisconnect() {
		assertTrue(node.getInputs().size() == 1);
		assertTrue(node.getOutputs().size() == 1);
		node.disconnect();
		assertEquals(0, node.getInputs().size());
		assertEquals(0, node.getOutputs().size());
	}

	@Test
	public void testFinalizeConnections() {
		fail("Not yet implemented");
	}

	@Test
	public void testSublayerFanOutCrossLinkage() {
		fail("Not yet implemented");
	}

	@Test
	public void testNextLayerFanOutCrossLinkage() {
		fail("Not yet implemented");
	}

	@Test
	public void testLink() {
		fail("Not yet implemented");
	}

	@Test
	public void testDoubleLink() {
		fail("Not yet implemented");
	}

	@Test
	public void testSelfLink() throws Exception {
		node.selfLink();
		inputLink.setUnlinkedValue(2.0D);
		node.computeOutput(false);
		assertEquals(1.0D, node.getComputedOutput(), 0.0D);
		node.computeOutput(false);
		assertEquals(2.0D, node.getComputedOutput(), 0.0D);
		node.computeOutput(false);
		assertEquals(3.0D, node.getComputedOutput(), 0.0D);
		node.computeOutput(false);
		assertEquals(4.0D, node.getComputedOutput(), 0.0D);		
	}

	@Test
	public void testBias() {
		assertEquals(1D, node.getBiasInput().getValue(), 0D);
		assertEquals(1D, node.getBiasInput().getWeight(), 0D);
	}
	
	@Test
	public void testComputeOutput() throws Exception {
		
		node.computeOutput(false);
		assertEquals(-1.0D, node.getComputedOutput(), 0.0D);
		
		inputLink.setUnlinkedValue(2.0D);
		node.computeOutput(false);
		assertEquals(1.0D, node.getComputedOutput(), 0.0D);
		
		node.setActivationFx(EActivation.SYGMOID_0_1);
		inputLink.setUnlinkedValue(0.0D);
		node.computeOutput(false);
		assertEquals(0.2689D, node.getComputedOutput(), 0.00005D);
		
		inputLink.setUnlinkedValue(1.0D);
		node.computeOutput(false);
		assertEquals(0.5D, node.getComputedOutput(), 0.00005D);
		
		node.setActivationFx(EActivation.SYGMOID_1_1);
		inputLink.setUnlinkedValue(0.0D);
		node.computeOutput(false);
		assertEquals(-0.4621D, node.getComputedOutput(), 0.00005D);
		
		inputLink.setUnlinkedValue(1.0D);
		node.computeOutput(false);
		assertEquals(0D, node.getComputedOutput(), 0.00005D);
	}

	@Test
	public void testPerformActivationFunction() {
		fail("Not yet implemented");
	}

	@Test
	public void testPerformDerivativeFunction() {
		fail("Not yet implemented");
	}

}
package RN.tests;

import static org.junit.Assert.assertEquals;

import java.util.HashMap;
import java.util.Map;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import RN.Area;
import RN.AreaSquare;
import RN.ILayer;
import RN.Layer;
import RN.Network;
import RN.algoactivations.EActivation;
import RN.dataset.inputsamples.ESamples;
import RN.linkage.ContourLinkage;
import RN.linkage.ELinkage;
import RN.linkage.FullFanOutLinkage;
import RN.linkage.OneToOneLinkage;
import RN.links.Link;
import RN.nodes.ENodeType;
import RN.nodes.Node;
import RN.nodes.PixelNode;

public class TestPixelContourNode {
	
	Network net = null;

	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
	}

	@Before
	public void setUp() throws Exception {
		
		net = Network.newInstance(null);
		
		int nbPixels = 9;
		
		AreaSquare inArea = new AreaSquare(3, 3, false);
		//inArea.setLinkage(new OneToOneLinkage());
		inArea.configureLinkage(ELinkage.ONE_TO_ONE, null, true).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
		Layer inLayer = new Layer(inArea);
		
		AreaSquare hiddenArea = new AreaSquare(3, 3, false);
		//hiddenArea.setLinkage(new ContourLinkage());
		hiddenArea.configureLinkage(ELinkage.SIMPLE_CONTOUR, null, true).configureNode(true, ENodeType.PIXEL).createNodes(nbPixels);
		ILayer hiddenLayer = new Layer(hiddenArea);
		
		AreaSquare outArea = new AreaSquare(1);
		//outArea.setLinkage(new FullFanOutLinkage());
		outArea.configureLinkage(ELinkage.MANY_TO_MANY, null, true).configureNode(true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(1);
		ILayer outLayer = new Layer(outArea);
		
		net.addLayer(inLayer, hiddenLayer, outLayer);
		
//		Node outputNode = new Node(EActivation.SYGMOID_0_1);
//		
//		outputNode.createBias();
//		
//		outArea.addNode(outputNode);
//		
//		
//		PixelNode hiddenNode = null;
//		PixelNode pixNode = null;
//
//		for(double idx = 0; idx < nbPixels; idx++){
//			
//			pixNode = new PixelNode();
//			
//			inArea.addNode(pixNode);
//			
//			pixNode.initParameters(nbPixels);
//
//			hiddenNode = new PixelNode();
//			hiddenNode.createBias();
//			hiddenArea.addNode(hiddenNode);
//			hiddenNode.initParameters(nbPixels);
//			
//			
//		}
		
		net.finalizeConnections();
		
		System.out.println(net.getString());
		
	}

	@After
	public void tearDown() throws Exception {
		net.initContext();
		net = null;
	}

	@Test
	public void testSublayerFanOutCrossLinkageLayer() {
		
		
		
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for(Link linkIn : net.getNode(1, 0, 0).getInputs()){
			map.put(linkIn.getSourceNode().getNodeId(), map.get(linkIn.getSourceNode().getNodeId()) == null ? 1 : (int) map.get(linkIn.getSourceNode().getNodeId()) + 1); 
		}
		
		System.out.println(net.getNode(1, 0, 0).getString());
		//System.out.println(net.getString());
		
		assertEquals(4, (int) map.get(0), 0);
		assertEquals(2, (int) map.get(1), 0);
		assertEquals(2, (int) map.get(3), 0);
		assertEquals(1, (int) map.get(4), 0);
		
		
	}



}
package RN.tests;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.util.List;

import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;

import RN.Area;
import RN.AreaSquare;
import RN.ENetworkImplementation;
import RN.ILayer;
import RN.Layer;
import RN.Network;
import RN.algoactivations.EActivation;
import RN.linkage.ELinkage;
import RN.linkage.ELinkageBetweenAreas;
import RN.linkage.FilterLinkage;
import RN.links.ELinkType;
import RN.links.Link;
import RN.nodes.ENodeType;
import RN.nodes.INode;
import RN.nodes.ImageNode;
import RN.nodes.PixelNode;
import RN.utils.MathUtils;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.scene.image.Image;
import javafx.scene.image.PixelReader;
import javafx.scene.paint.Color;
import javafx.stage.Stage;

public class TestVisionNode extends Application{

	private ImageNode imageNode = null;
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		
		Thread t = new Thread("JavaFX Init Thread") {
	        public void run() {
	        	
	        	Application.launch(TestVisionNode.class, new String[0]);
	        }
	    };
	    t.setDaemon(true);
	    t.start();
	    Thread.sleep(1000);
	}

	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		System.out.println("Fin des tests....");
		Thread.sleep(100000);
	}

	@Before
	public void setUp() throws Exception {
		
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
				
				imageNode = new ImageNode(EActivation.IDENTITY);
				
			}
			
		});

	}

	@After
	public void tearDown() throws Exception {
		
		imageNode = null;
		System.out.println("----- Next test -----");
	}


	

	
	@Test
	public void testShowCenterPointImage() {
		
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
				
				int nbPixels = 10000;
				AreaSquare area = new AreaSquare(nbPixels);
				PixelNode centerPix = new PixelNode();
				Link in = Link.getInstance(ELinkType.REGULAR, true);
				in.setUnlinkedValue(1D);
				centerPix.addInput(in);
				area.addNode(centerPix);
				centerPix.setNodeId(5050);
				centerPix.initParameters();
				
				concentricCircleCenters(10D, 11D, area);
				

				assertEquals(50D, centerPix.getX(), 0.0D);
				assertEquals(50D, centerPix.getY(), 0.0D);
				assertEquals(100.0, area.getWidthPx(), 0.0D);
				assertEquals(area.getWidthPx(), area.getHeightPx(), 0.0D);
				
				AreaSquare area1 = new AreaSquare(1);
				PixelNode hiddenPix = new PixelNode();
				area1.addNode(hiddenPix);
				
				
				try {
					
					for(INode pix : area.getNodes()){
						pix.link(hiddenPix, ELinkType.REGULAR);
						pix.computeOutput(false);
					}
					
				} catch (Exception e) {
					e.printStackTrace();
				}
				
				imageNode.showImage(hiddenPix);
				
			}
		});
		
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
	}
	
	private void concentricCircleCenters(Double angleCount, Double scaleCount, Area area) {
		
		double base = 1 + (Math.PI / (Math.sqrt(3D) * angleCount));
		double arc = 2D * Math.PI / angleCount;
		
		double p_fovea = angleCount / (2D * Math.PI) + 2;
		
		Double p_r = null;
		
		//double t_radius = arc * 1/3;
		
		int idCircle = 0;
		double theta = 0D;
		
		for(int idScale=0; idScale <= scaleCount; idScale++){
			for(int idAngle=0; idAngle <= angleCount; idAngle++){
				
				theta = arc * (idAngle + MathUtils.odd(idScale) / 2D);
				p_r = p_fovea * Math.pow(base, idScale);
				
				theta = MathUtils.round(theta, 2);
				
				createPix(area, theta, p_r, base);
				
				idCircle++;
				
			}
		}
	}
	
	void createPix(Area area, Double theta, Double p_r, Double base){
		
		PixelNode pix = new PixelNode();
		Link in = Link.getInstance(ELinkType.REGULAR, true);
		in.setUnlinkedValue(1D);
		pix.addInput(in);
		area.addNode(pix);
		
		pix.setTheta(theta);
		pix.setP(p_r);
		pix.getCoordinate().setBase(base);
		pix.getCoordinate().setX0((double) pix.getAreaSquare().getNodeCenterX());
		pix.getCoordinate().setY0((double) pix.getAreaSquare().getNodeCenterY());
		
		pix.getCoordinate().logPolarToLinearSystem();
		
		pix.setNodeId(Math.max(0, pix.getAreaSquare().nodeXYToNodeId(pix.getCoordinate().getX().intValue(), pix.getCoordinate().getY().intValue())));
		pix.initParameters();
		
	}
	
	@Test
	public void testShowSimpleImage() {
		showImageSimple();
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
	
	private void showImageSimple(){
		
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
		
				AreaSquare areaOut = new AreaSquare(1);
				PixelNode outNode = new PixelNode();
				areaOut.addNode(outNode);
				//outNode.createBias();
				outNode.setActivationFx(EActivation.SYGMOID_0_1);
				outNode.setInnerNode(imageNode);
				
				int nbPixels = 10000;
				AreaSquare areaIn = new AreaSquare(nbPixels);
				PixelNode pixNode = null;
				Link link = null;
				double margeCarre = 5D;
				
				for(double idx = 1; idx <= nbPixels; idx++){
					
					pixNode = new PixelNode();
					areaIn.addNode(pixNode);
					pixNode.setNodeId((int) idx - 1);
					pixNode.initParameters(nbPixels);
					pixNode.link(outNode, ELinkType.REGULAR, false);
					link = Link.getInstance(ELinkType.REGULAR, false);
					pixNode.addInput(link);
					
					// les photorécepteurs sont continuellements activés même en l'absence de stimulis -> 0.5D
					if(pixNode.getX() > margeCarre && pixNode.getX() < (pixNode.getAreaSquare().getWidthPx() - margeCarre) && pixNode.getY() > margeCarre && pixNode.getY() < (pixNode.getAreaSquare().getHeightPx() - margeCarre))
						link.setUnlinkedValue(1D);
					else
						link.setUnlinkedValue(0D);
					
					
					try {
						pixNode.computeOutput(false);
					} catch (Exception e) {
						e.printStackTrace();
					}
				}

				imageNode.showImage(outNode);
		
			}});
		

	}
	
	

	
	@Test
	public void testLearningConvolImage() {
		
		
//		Le traitement repose sur cinq paramètres :
//		
//			N représente la taille du masque (matrice carrée) implantant le filtre LOG. N est impair.
//			σ permet d'ajuster la taille du chapeau mexicain.
//			∆x et ∆y sont les pas d'échantillonnage utilisés pour discrétiser h''(x,y). Généralement ∆x = ∆ y
//			S est le seuil qui permet de sélectionner les contours les plus marqués.
//		
//			Il est à noter que le choix des paramètres N, σ et ∆x ne doit pas se faire de façon indépendante. 
//  		En effet, le masque, même de taille réduite, doit ressembler à un chapeau mexicain. Le problème ici est le même que celui que l'on rencontre lors de l'échantillonnage d'une fonction gaussienne. 
//          Le nombre de points N à considérer doit être tel que l'étendue occupe l'intervalle [-3σ , 3σ].
//			En fonction du pas d'échantillonnage, l'étendue spatiale vaut : (N-1) ∆x  .
//			Cette étendue peut aussi s'écrire en fonction de σ : (N-1) ∆x = kσ  avec k entier.
//			En prenant par exemple  ∆x = 1 , il s'agit de choisir N et σ de sorte que l'étendue du chapeau mexicain soit pertinente. 
//  		Pour le chapeau mexicain, la valeur de k doit être au moins de 4.
		
		double N = 3D;
		double deltaX = 1;
		double k = 4D;
		double Ox = (N-1) * deltaX / k;
		double Oy = Ox;
		double alpha = 1D;
		double Mu = 0D;
		
		//showSimpleLogGaborVision(Ox, Oy, Mu, alpha);
		//showLogGaborVision(Ox, Oy, Mu, alpha);
		//showLogPolarRetina();
		showVision(Ox, Oy, Mu, alpha);
		//showVisionOnOff(Ox, Oy, Mu, alpha);
		
		
		try {
			Thread.sleep(10000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}

	}
	

	
	private void showVision( final double ox, final double oy, final double mu, final double alpha){
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
				
				Image image = new Image("file:./resources/a-16x16.png");
				int width = (int) image.getWidth();
				int height = (int) image.getHeight();
				
				int sampling = 1;
				int nbPixels = width * height;
				System.out.println("nb pixels inputs :" + nbPixels);
				
				
				Network net = Network.getInstance(ENetworkImplementation.UNLINKED);
				
				AreaSquare inArea = new AreaSquare(nbPixels, true);
				Layer inLayer = new Layer(inArea);
				
				AreaSquare hiddenArea = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer = new Layer(hiddenArea);
				
				AreaSquare hidden2Area = new AreaSquare(nbPixels, true);
				AreaSquare hidden2Area2 = new AreaSquare(nbPixels, true);
				AreaSquare hidden2Area3 = new AreaSquare(nbPixels, true);
				AreaSquare hidden2Area4 = new AreaSquare(nbPixels, true);
				ILayer hidden2Layer = new Layer(hidden2Area, hidden2Area2, hidden2Area3, hidden2Area4);
				
				AreaSquare hidden3Area = new AreaSquare(nbPixels, true);
				ILayer hidden3Layer = new Layer(hidden3Area);
				
				AreaSquare outArea = new AreaSquare(1);
				ILayer outLayer = new Layer(outArea);
				net.addLayer(inLayer, hiddenLayer, hidden2Layer, hidden3Layer, outLayer);
				
				
				inArea.configureLinkage(ELinkage.ONE_TO_ONE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
				inArea.getImageArea().scaleImage(2);
				
				hiddenArea.configureLinkage(ELinkage.ONE_TO_ONE, ELinkageBetweenAreas.ONE_TO_ONE, null, false, 3D, 3D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
				
				hidden2Area.configureLinkage(ELinkage.V1_ORIENTATIONS, ELinkageBetweenAreas.ONE_TO_MANY, null, false,  0D, 0.5D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
				hidden2Area.getImageArea().scaleImage(2);
				
				hidden2Area2.configureLinkage(ELinkage.V1_ORIENTATIONS, ELinkageBetweenAreas.ONE_TO_MANY, null, false,  45D, 0.5D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
				hidden2Area2.getImageArea().scaleImage(2);
				
				hidden2Area3.configureLinkage(ELinkage.V1_ORIENTATIONS, ELinkageBetweenAreas.ONE_TO_MANY, null, false,  90D, 0.5D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
				hidden2Area3.getImageArea().scaleImage(2);
				
				hidden2Area4.configureLinkage(ELinkage.V1_ORIENTATIONS, ELinkageBetweenAreas.ONE_TO_MANY, null, false,  135D, 0.5D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
				hidden2Area4.getImageArea().scaleImage(2);
				
				
				
				hidden3Area.configureLinkage(ELinkage.MAX, ELinkageBetweenAreas.MANY_TO_ONE, null, false, 3D, 1D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
				hidden3Area.getImageArea().scaleImage(2);
				
				
				outArea.configureLinkage(ELinkage.MANY_TO_MANY, ELinkageBetweenAreas.ONE_TO_ONE, null, true).configureNode( true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(10);
				
				
				net.finalizeConnections();
				
				
				//Image noir et blanc en input
				System.out.println("Begin lecture image ...");
				PixelNode pixNode = null;
				Color color = null;
				PixelReader pixelReader = image.getPixelReader();
				for(int y = 0; y < height; y+=sampling){
					for(int x = 0; x < width; x+=sampling){
							color = pixelReader.getColor(x, y);
							pixNode = (PixelNode) inArea.getNodeXY(x, y, sampling);
							pixNode.setEntry(color.getOpacity());
					}
				}
				System.out.println("End lecture image.");
				
				try {
					net.propagation(false);
					
				} catch (Exception e) {
					e.printStackTrace();
				}
				
				hidden2Area.getFilter(FilterLinkage.ID_FILTER_V1Orientation).filterToImage(8);
				hidden2Area2.getFilter(FilterLinkage.ID_FILTER_V1Orientation).filterToImage(8);
				hidden2Area3.getFilter(FilterLinkage.ID_FILTER_V1Orientation).filterToImage(8);
				hidden2Area4.getFilter(FilterLinkage.ID_FILTER_V1Orientation).filterToImage(8);
				
				//System.out.println(net.getNode(2, 0, 48).getString());
				//net.getNode(1, 0, 5050).getArea().getFilter().filterToString(0);
				//net.getNode(1, 0, 5050).getArea().filterToString(1);
				
		
			}});

	}
	
	
	@Test
	public void showVisionOnOff(){
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
		
				int nbPixels = 10000;
				
				ImageNode imageNodeON = new ImageNode(EActivation.IDENTITY);
				ImageNode imageNodeOFF = new ImageNode(EActivation.IDENTITY);
				
				ImageNode imageNodeBipL = new ImageNode(EActivation.IDENTITY);
				ImageNode imageNodeBipS = new ImageNode(EActivation.IDENTITY);
				ImageNode imageNode0 = new ImageNode(EActivation.IDENTITY);
				ImageNode imageNodeGangOFF = new ImageNode(EActivation.IDENTITY);
				ImageNode imageNodeGangON = new ImageNode(EActivation.IDENTITY);
				
				Network net = Network.newInstance(ENetworkImplementation.UNLINKED);
				
				Area inArea = new Area(nbPixels);
				Layer inLayer = new Layer(inArea);
				
				Area hiddenArea0 = new Area(nbPixels);
				Area hiddenArea1 = new Area(nbPixels);
				ILayer hiddenLayer = new Layer(hiddenArea0, hiddenArea1);
				
				Area hidden1Area0 = new Area(nbPixels);
				Area hidden1Area1 = new Area(nbPixels);
				ILayer hidden1Layer = new Layer(hidden1Area0, hidden1Area1);
				
				Area outArea0 = new Area(1);
				Area outArea1 = new Area(1);
				ILayer outLayer = new Layer(outArea0, outArea1);
				
				net.addLayer(inLayer, hiddenLayer, hidden1Layer, outLayer);
				
				
//				outArea0.configureNode( true, EActivation.SYGMOID_0_1, ELinkage.MANY_TO_MANY, false, ENodeType.REGULAR).createNodes(1);
//				outArea1.configureNode( true, EActivation.SYGMOID_0_1, ELinkage.MANY_TO_MANY, false, ENodeType.REGULAR).createNodes(1);
				
				PixelNode pixNode = null;
				
				System.out.println("Begin creation bipolars and ganglionaries nodes...");
				
				int pixelGanglionaryNodes = 10000;
				
//				hiddenArea0.configureNode( false, ELinkage.BIPOLAR, false, ENodeType.BIPOLAR_S).createNodes(pixelGanglionaryNodes);
//				hiddenArea1.configureNode( false, ELinkage.BIPOLAR, false, ENodeType.BIPOLAR_L).createNodes(pixelGanglionaryNodes);
//				
//				hidden1Area0.configureNode( false, ELinkage.GANGLIONARY, false, ENodeType.GANGLIONARY_OFF).createNodes(pixelGanglionaryNodes);
//				hidden1Area1.configureNode( false, ELinkage.GANGLIONARY, false, ENodeType.GANGLIONARY_ON).createNodes(pixelGanglionaryNodes);
//				
//				System.out.println("End creation bipolars and ganglionaries nodes.");
//				
//				net.getNode(1, 0, 5050).setInnerNode(imageNodeBipL);
//				net.getNode(1, 1, 5050).setInnerNode(imageNodeBipS);
//				
//				net.getNode(2, 0, 5050).setInnerNode(imageNodeGangON);
//				net.getNode(2, 1, 5050).setInnerNode(imageNodeGangOFF);
//
//				System.out.println("Begin creation input nodes...");
//				inArea.configureNode( false, ELinkage.ONE_TO_ONE, false, ENodeType.PIXEL).createNodes(pixelGanglionaryNodes);
				
				net.getNode(0, 0, 5050).setInnerNode(imageNode0);
				
				net.getNode(3, 0, 0).setInnerNode(imageNodeON);
				net.getNode(3, 1, 0).setInnerNode(imageNodeOFF);
				
				System.out.println("End creation input nodes.");
				
				net.finalizeConnections();
				
				//Image noir et blanc en input
				System.out.println("Begin lecture image ...");
				Image image = new Image("file:./resources/logo-transparent.png");
				PixelReader pixelReader = image.getPixelReader();
				for(int idx = 0; idx < nbPixels; idx++){
					pixNode = (PixelNode) inArea.getNode(idx);
					
					Color color = pixelReader.getColor(pixNode.getX(), pixNode.getY());
					pixNode.getInput(0).setUnlinkedValue(color.getBrightness());
					
				}
				System.out.println("End lecture image.");
				
				
				System.out.println("Begin propagation...");
				try {
					net.propagation(false);
				} catch (Exception e) {
					e.printStackTrace();
				}
				System.out.println("End propagation.");
				
				System.out.println(net.getNode(2, 0, 5050).getString());
				System.out.println(net.getNode(2, 1, 5050).getString());
		
			}});

	}
	
	@Test
	public void testSimpleLogGaborVision(){
		
		showSimpleLogGaborVision();
		
		try {
			Thread.sleep(10000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
	private void showSimpleLogGaborVision(){
		
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
				
				//Image image = new Image("file:./resources/empreinte.png");
				Image image = new Image("file:./resources/a-16x16.png");
				int width = (int) image.getWidth();
				int height = (int) image.getHeight();
				
				int sampling = 1;
				int nbPixels = (int) ((width / sampling) * (height / sampling)) ;
				System.out.println("nb pixels inputs :" + nbPixels);
				
				int samplingH = 1;
				int nbPixelsHidden = (int) ((width / samplingH) * (height / samplingH)) ;
				System.out.println("nb pixels hidden :" + nbPixelsHidden);
				
				int samplingH2 = 1;
				int nbPixelsHidden2 = 25;//(int) (nbPixelsHidden / Math.pow(samplingH2, 2));
				System.out.println("nb pixels hidden2 :" + nbPixelsHidden2);
				
				
				Network net = Network.getInstance(ENetworkImplementation.UNLINKED);
				
				AreaSquare inArea = new AreaSquare(nbPixels, true);
				Layer inLayer = new Layer(inArea);
				
				AreaSquare hiddenArea = new AreaSquare(width, height, true);
				AreaSquare hiddenArea2 = new AreaSquare(width, height, true);
				AreaSquare hiddenArea3 = new AreaSquare(width, height, true);

				ILayer hiddenLayer = new Layer(hiddenArea, hiddenArea2, hiddenArea3);
				
				AreaSquare hidden2Area = new AreaSquare(nbPixelsHidden2, true);
				ILayer hidden2Layer = new Layer(hidden2Area);
				
				AreaSquare outArea = new AreaSquare(10, 1, true);
				ILayer outLayer = new Layer(outArea);
				
				net.addLayer(inLayer, hiddenLayer, hidden2Layer, outLayer);
				
				
				inArea.configureLinkage(ELinkage.ONE_TO_ONE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
				inArea.getImageArea().scaleImage(2);
				
				hiddenArea.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false,  8D, 3D, 1D, 1D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea.getImageArea().scaleImage(2);
				hiddenArea2.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false,  8D, 3D, 2D, 1D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea2.getImageArea().scaleImage(2);
				hiddenArea3.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false,  8D, 3D, 3D, 1D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea3.getImageArea().scaleImage(2);

				
				
				hidden2Area.configureLinkage(ELinkage.MANY_TO_MANY, ELinkageBetweenAreas.MANY_TO_ONE, null, samplingH2, false).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden2);
				hidden2Area.getImageArea().scaleImage(2);
				
				
				outArea.configureLinkage(ELinkage.MANY_TO_MANY, ELinkageBetweenAreas.ONE_TO_ONE, null, true).configureNode( true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(10);
				outArea.getImageArea().scaleImage(2);
				
				net.finalizeConnections();
				
				
				//Image noir et blanc en input
				System.out.println("Begin lecture image ...");
				PixelNode pixNode = null;
				Color color = null;
				PixelReader pixelReader = image.getPixelReader();
				for(int y = 0; y < height; y+=sampling){
					for(int x = 0; x < width; x+=sampling){
							color = pixelReader.getColor(x, y);
							pixNode = (PixelNode) inArea.getNodeXY(x, y, sampling);
							pixNode.setEntry(color.getOpacity());
					}
				}
				System.out.println("End lecture image.");
				
				try {
					net.propagation(false);
					
				} catch (Exception e) {
					e.printStackTrace();
				}
				
				hiddenArea.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea2.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea3.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);

				
				//net.getNode(1, 0, 5050).getArea().getFilter().filterToString(0);
				//net.getNode(1, 0, 5050).getArea().filterToString(1);
				
		
			}});

	}
	
	@Test
	public void testSimpleMaxPooling(){
		
		showSimpleMaxPooling();
		
		try {
			Thread.sleep(10000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
	private void showSimpleMaxPooling(){
		
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
				
				Image image = new Image("file:./resources/icon_48x48.png");
				int width = (int) image.getWidth();
				int height = (int) image.getHeight();
				System.out.println("image :" + width + "x" + height);
				
				int sampling = 1;
				int nbPixels = (int) ((width / sampling) * (height / sampling)) ;
				System.out.println("nb pixels inputs :" + nbPixels);
				
				int samplingH = 2;
				int nbPixelsHidden = (int) ((width / samplingH) * (height / samplingH)) ;
				System.out.println("nb pixels hidden :" + nbPixelsHidden);
				
				
				Network net = Network.getInstance(ENetworkImplementation.UNLINKED);
				
				AreaSquare inArea = new AreaSquare(nbPixels, true);
				Layer inLayer = new Layer(inArea);
				
				AreaSquare hiddenArea = new AreaSquare((width / samplingH), (height / samplingH), true);
				AreaSquare hiddenArea2 = new AreaSquare((width / samplingH), (height / samplingH), true);

				ILayer hiddenLayer = new Layer(hiddenArea, hiddenArea2);
				
				AreaSquare outArea = new AreaSquare(10, 1, true);
				ILayer outLayer = new Layer(outArea);
				
				net.addLayer(inLayer, hiddenLayer, outLayer);
				
				
				inArea.configureLinkage(ELinkage.ONE_TO_ONE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
				inArea.getImageArea().scaleImage(2);
				
				hiddenArea.configureLinkage(ELinkage.MAX_POOLING, ELinkageBetweenAreas.ONE_TO_MANY, null, 1, false,  3D, 2D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea.getImageArea().scaleImage(2);
				hiddenArea2.configureLinkage(ELinkage.MAX_POOLING, ELinkageBetweenAreas.ONE_TO_MANY, null, 1, false,  2D, 2D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea2.getImageArea().scaleImage(2);

				
				outArea.configureLinkage(ELinkage.MANY_TO_MANY, ELinkageBetweenAreas.ONE_TO_ONE, null, true).configureNode( true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(10);
				outArea.getImageArea().scaleImage(2);
				
				net.finalizeConnections();
				
				
				//Image noir et blanc en input
				System.out.println("Begin lecture image ...");
				PixelNode pixNode = null;
				Color color = null;
				PixelReader pixelReader = image.getPixelReader();
				for(int y = 0; y < height; y+=sampling){
					for(int x = 0; x < width; x+=sampling){
							color = pixelReader.getColor(x, y);
							pixNode = (PixelNode) inArea.getNodeXY(x, y, sampling);
							pixNode.setEntry(color.getOpacity());
					}
				}
				System.out.println("End lecture image.");
				
				try {
					net.propagation(false);
					
				} catch (Exception e) {
					e.printStackTrace();
				}
				
//				hiddenArea.getFilter(FilterLinkage.ID_FILTER_MAX_POOLING).filterToImage(8);
//				hiddenArea2.getFilter(FilterLinkage.ID_FILTER_MAX_POOLING).filterToImage(8);

				
				//net.getNode(1, 0, 5050).getArea().getFilter().filterToString(0);
				//net.getNode(1, 0, 5050).getArea().filterToString(1);
				
		
			}});

	}
	
	@Test
	public void testLogGaborVision(){
		
		showLogGaborVision();
		
		try {
			Thread.sleep(10000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
	private void showLogGaborVision(){
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
				
				Image image = new Image("file:./resources/sinsum13.gif");
				int width = (int) image.getWidth();
				int height = (int) image.getHeight();
				
				int sampling = 1;
				int nbPixels = (int) ((width * height) / Math.pow(sampling, 2));
				System.out.println("nb pixels inputs :" + nbPixels);
				
				int samplingH = 4;
				int nbPixelsHidden = (int) (nbPixels / Math.pow(samplingH, 2));
				System.out.println("nb pixels hidden :" + nbPixelsHidden);
				
				int samplingH2 = 1;
				int nbPixelsHidden2 = 9;//(int) (nbPixelsHidden / Math.pow(samplingH2, 2));
				System.out.println("nb pixels hidden2 :" + nbPixelsHidden2);
				
				
				Network net = Network.getInstance(ENetworkImplementation.UNLINKED);
				
				AreaSquare inArea = new AreaSquare(nbPixels, true);
				Layer inLayer = new Layer(inArea);
				
				AreaSquare hiddenArea = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea2 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea3 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea4 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea5 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea6 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea7 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea8 = new AreaSquare(nbPixelsHidden, true);
				
				AreaSquare hiddenArea9 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea10 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea11 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea12 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea13 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea14 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea15 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea16 = new AreaSquare(nbPixelsHidden, true);
				
				AreaSquare hiddenArea17 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea18 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea19 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea20 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea21 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea22 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea23 = new AreaSquare(nbPixelsHidden, true);
				AreaSquare hiddenArea24 = new AreaSquare(nbPixelsHidden, true);
				ILayer hiddenLayer = new Layer(hiddenArea, hiddenArea2, hiddenArea3, hiddenArea4, hiddenArea5, hiddenArea6, hiddenArea7, hiddenArea8, 
						hiddenArea9,
						hiddenArea10,
						hiddenArea11,
						hiddenArea12,
						hiddenArea13,
						hiddenArea14,
						hiddenArea15,
						hiddenArea16,
						hiddenArea17, hiddenArea18, hiddenArea19, hiddenArea20, hiddenArea21, hiddenArea22, hiddenArea23, hiddenArea24);
				
				AreaSquare hidden2Area = new AreaSquare(nbPixelsHidden2, true);
				ILayer hidden2Layer = new Layer(hidden2Area);
				
				AreaSquare outArea = new AreaSquare(1);
				ILayer outLayer = new Layer(outArea);
				net.addLayer(inLayer, hiddenLayer, hidden2Layer, outLayer);
				
				
				inArea.configureLinkage(ELinkage.ONE_TO_ONE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
				inArea.getImageArea().scaleImage(2);
				
				hiddenArea.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false,  8D, 3D, 1D, 1D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea.getImageArea().scaleImage(2);
				hiddenArea2.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false,  8D, 3D, 2D, 1D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea2.getImageArea().scaleImage(2);
				hiddenArea3.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false,  8D, 3D, 3D, 1D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea3.getImageArea().scaleImage(2);
				hiddenArea4.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false,  8D, 3D, 4D, 1D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea4.getImageArea().scaleImage(2);
				hiddenArea5.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH,  false, 8D, 3D, 5D, 1D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea5.getImageArea().scaleImage(2);
				hiddenArea6.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false,  8D, 3D, 6D, 1D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea6.getImageArea().scaleImage(2);
				hiddenArea7.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false,  8D, 3D, 7D, 1D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea7.getImageArea().scaleImage(2);
				hiddenArea8.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false,  8D, 3D, 8D, 1D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea8.getImageArea().scaleImage(2);
				
				
				hiddenArea9.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false,  8D, 3D, 1D, 2D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea9.getImageArea().scaleImage(2);
				hiddenArea10.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false, 8D, 3D, 2D, 2D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea10.getImageArea().scaleImage(2);
				hiddenArea11.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false, 8D, 3D, 3D, 2D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea11.getImageArea().scaleImage(2);
				hiddenArea12.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false, 8D, 3D, 4D, 2D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea12.getImageArea().scaleImage(2);
				hiddenArea13.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false, 8D, 3D, 5D, 2D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea13.getImageArea().scaleImage(2);
				hiddenArea14.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false, 8D, 3D, 6D, 2D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea14.getImageArea().scaleImage(2);
				hiddenArea15.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false, 8D, 3D, 7D, 2D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea15.getImageArea().scaleImage(2);
				hiddenArea16.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false, 8D, 3D, 8D, 2D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea16.getImageArea().scaleImage(2);
				
				
				hiddenArea17.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false, 8D, 3D, 1D, 3D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea17.getImageArea().scaleImage(2);
				hiddenArea18.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false, 8D, 3D, 2D, 3D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea18.getImageArea().scaleImage(2);
				hiddenArea19.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false, 8D, 3D, 3D, 3D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea19.getImageArea().scaleImage(2);
				hiddenArea20.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false, 8D, 3D, 4D, 3D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea20.getImageArea().scaleImage(2);
				hiddenArea21.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false, 8D, 3D, 5D, 3D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea21.getImageArea().scaleImage(2);
				hiddenArea22.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false, 8D, 3D, 6D, 3D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea22.getImageArea().scaleImage(2);
				hiddenArea23.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false, 8D, 3D, 7D, 3D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea23.getImageArea().scaleImage(2);
				hiddenArea24.configureLinkage(ELinkage.LOG_GABOR2, ELinkageBetweenAreas.ONE_TO_MANY, null, samplingH, false, 8D, 3D, 8D, 3D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden);
				hiddenArea24.getImageArea().scaleImage(2);
				
				
				hidden2Area.configureLinkage(ELinkage.MANY_TO_MANY, ELinkageBetweenAreas.MANY_TO_ONE, null, samplingH2, false).configureNode(false, ENodeType.PIXEL).createNodes(nbPixelsHidden2);
				hidden2Area.getImageArea().scaleImage(2);
				
				
				outArea.configureLinkage(ELinkage.MANY_TO_MANY, ELinkageBetweenAreas.ONE_TO_ONE, null, true).configureNode( true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(10);
				
				
				net.finalizeConnections();
				
				
				//Image noir et blanc en input
				// it's a .gif => Brightness (no opacity)
				System.out.println("Begin lecture image ...");
				PixelNode pixNode = null;
				Color color = null;
				PixelReader pixelReader = image.getPixelReader();
				for(int y = 0; y < height; y+=sampling){
					for(int x = 0; x < width; x+=sampling){
							color = pixelReader.getColor(x, y);
							pixNode = (PixelNode) inArea.getNodeXY(x / sampling, y / sampling);
							pixNode.setEntry(color.getBrightness());
					}
				}
				System.out.println("End lecture image.");
				
				try {
					net.propagation(false);
					
				} catch (Exception e) {
					e.printStackTrace();
				}
				
				hiddenArea.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea2.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea3.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea4.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea5.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea6.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea7.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea8.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				
				hiddenArea9.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea10.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea11.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea12.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea13.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea14.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea15.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea16.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				
				hiddenArea17.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea18.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea19.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea20.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea21.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea22.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea23.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				hiddenArea24.getFilter(FilterLinkage.ID_FILTER_GABOR_LOG).filterToImage(8);
				
				//net.getNode(1, 0, 5050).getArea().getFilter().filterToString(0);
				//net.getNode(1, 0, 5050).getArea().filterToString(1);
				
		
			}});

	}
	
	
	@Test
	public void testLogPolarRetina(){
		
		showLogPolarRetina();
		
		try {
			Thread.sleep(10000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
	
	private void showLogPolarRetina(){
		Platform.runLater(new Runnable(){

			@Override
			public void run() {
				
				Image image = new Image("file:./resources/lena128.jpg");
				int width = (int) image.getWidth();
				int height = (int) image.getHeight();
				
				int sampling = 1;
				int nbPixels = (int) ((width * height) / Math.pow(sampling, 2));
				System.out.println("nb pixels inputs :" + nbPixels);
				
				
				Network net = Network.getInstance(ENetworkImplementation.UNLINKED);
				
				AreaSquare inArea = new AreaSquare(nbPixels, true);
				Layer inLayer = new Layer(inArea);
				
				AreaSquare hiddenArea = new AreaSquare(nbPixels, true);
				AreaSquare hiddenArea2 = new AreaSquare(nbPixels, true);
				ILayer hiddenLayer = new Layer(hiddenArea, hiddenArea2);
				
				AreaSquare hidden2Area = new AreaSquare(100, true);
				ILayer hidden2Layer = new Layer(hidden2Area);
				
				AreaSquare outArea = new AreaSquare(9, true);
				ILayer outLayer = new Layer(outArea);
				net.addLayer(inLayer, hiddenLayer, hidden2Layer, outLayer);
				
				
				inArea.configureLinkage(ELinkage.ONE_TO_ONE, ELinkageBetweenAreas.ONE_TO_ONE, null, false).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
				inArea.getImageArea().scaleImage(2);
				
				hiddenArea.configureLinkage(ELinkage.LOG_POLAR, ELinkageBetweenAreas.ONE_TO_MANY, null, false, 8D, 3D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea.getImageArea().scaleImage(2);
				
				hiddenArea2.configureLinkage(ELinkage.CARTESIAN_TO_POLAR, ELinkageBetweenAreas.ONE_TO_MANY, null, false, 8D, 3D).configureNode(false, ENodeType.PIXEL).createNodes(nbPixels);
				hiddenArea2.getImageArea().scaleImage(2);
				
				
				hidden2Area.configureLinkage(ELinkage.MANY_TO_MANY, ELinkageBetweenAreas.MANY_TO_ONE, null, false).configureNode(false, ENodeType.PIXEL).createNodes(100);
				hidden2Area.getImageArea().scaleImage(2);
				
				
				outArea.configureLinkage(ELinkage.MANY_TO_MANY, ELinkageBetweenAreas.ONE_TO_ONE, null, true).configureNode( true, EActivation.SYGMOID_0_1, ENodeType.PIXEL).createNodes(9);
				
				
				net.finalizeConnections();
				
				
				//Image noir et blanc en input
				System.out.println("Begin lecture image ...");
				PixelNode pixNode = null;
				Color color = null;
				PixelReader pixelReader = image.getPixelReader();
				for(int y = 0; y < height; y+=sampling){
					for(int x = 0; x < width; x+=sampling){
							color = pixelReader.getColor(x, y);
							pixNode = (PixelNode) inArea.getNodeXY(x / sampling, y / sampling);
							pixNode.setEntry(color.getBrightness());
					}
				}
				System.out.println("End lecture image.");
				
				try {
					net.propagation(false);
					
				} catch (Exception e) {
					e.printStackTrace();
				}
				
				//System.out.println(net.getNode(2, 0, 48).getString());
				//net.getNode(1, 0, 5050).getArea().getFilter().filterToString(0);
				//net.getNode(1, 0, 5050).getArea().filterToString(1);
				
		
			}});

	}
	
	
	private void showContoursHorizontaux( final double ox, final double oy, final double mu, final double alpha){


	}
	
	
	@Test
	public void testArchitecture() {
		fail("Not yet implemented");
	}

	@Test
	public void testFinalizeConnections() {
		fail("Not yet implemented");
	}

	@Test
	public void testSublayerFanOutCrossLinkage() {
		fail("Not yet implemented");
	}

	@Test
	public void testNextLayerFanOutCrossLinkage() {
		fail("Not yet implemented");
	}

	@Test
	public void testLink() {
		fail("Not yet implemented");
	}

	@Test
	public void testDoubleLink() {
		fail("Not yet implemented");
	}

	@Test
	public void testSelfLink() throws Exception {
//		node.selfLink();
//		inputLink.setUnlinkedValue(1.0D);
//		node.computeOutput(false);
//		assertEquals(1.0D, node.getComputedOutput(), 0.0D);
//		node.computeOutput(false);
//		assertEquals(2.0D, node.getComputedOutput(), 0.0D);
//		node.computeOutput(false);
//		assertEquals(3.0D, node.getComputedOutput(), 0.0D);
//		node.computeOutput(false);
//		assertEquals(4.0D, node.getComputedOutput(), 0.0D);		
	}

	@Test
	public void testComputeOutput() throws Exception {
		
//		node.computeOutput(false);
//		assertEquals(0.0D, node.getComputedOutput(), 0.0D);
//		
//		inputLink.setUnlinkedValue(2.0D);
//		node.computeOutput(false);
//		assertEquals(2.0D, node.getComputedOutput(), 0.0D);
//		
//		node.setActivationFx(EActivation.SYGMOID_0_1);
//		inputLink.setUnlinkedValue(0.0D);
//		node.computeOutput(false);
//		assertEquals(0.5D, node.getComputedOutput(), 0.0D);
//		
//		node.setActivationFx(EActivation.SYGMOID_1_1);
//		inputLink.setUnlinkedValue(0.0D);
//		node.computeOutput(false);
//		assertEquals(0.0D, node.getComputedOutput(), 0.0D);
	}

	@Test
	public void testPerformActivationFunction() {
		fail("Not yet implemented");
	}

	@Test
	public void testPerformDerivativeFunction() {
		fail("Not yet implemented");
	}

	@Override
	public void start(Stage primaryStage) throws Exception {
		// TODO Auto-generated method stub
		
	}

}
package RN.utils;

import java.math.BigDecimal;
import java.math.RoundingMode;

/**
 * @author Eric Marchand
 *
 */
public class MathUtils {

	public MathUtils() {
		// TODO Auto-generated constructor stub
	}
	
	
	public static int odd(int value){
		return value % 2 == 0 ? 0 : 1;
	}
	
	public static int even(int value){
		return value % 2 == 0 ? 1 : 0;
	}
	
	public static double round(double value, int places) {
	    if (places < 0) throw new IllegalArgumentException();

	    BigDecimal bd = new BigDecimal(value);
	    bd = bd.setScale(places, RoundingMode.HALF_UP);
	    return bd.doubleValue();
	}

}
package RN.utils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import RN.nodes.PixelNode;

/**
 * @author Eric Marchand
 *
 */
public class MatrixUtils {
	
	public static <T> List<T> toList(T[][] matrix) {
		
	    List<T> list = new ArrayList<T>();
	    for (T[] array : matrix) {
	        list.addAll(Arrays.asList(array));
	    }
	    return list;
	}
	
	public static <T> List<T> toList(T[][] matrix, int sampling) {
		List<T> list = new ArrayList<T>();
		List<T> row = null;
	    for (T[] array : matrix) {
	    	row = Arrays.asList(array).stream().filter(node -> ((PixelNode) node).getX() % sampling == 0 ).filter(node -> ((PixelNode) node).getY() % sampling == 0).collect(Collectors.toList());
	        if(!row.isEmpty())
	        	list.addAll(row);
	    }
	    return list;
		
	}
	

}
package RN.utils;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

/**
 * @author Eric Marchand
 *
 */
public class ReflexionUtils {
	
	public static <T>  T newClass(String classPath){
		return newClass(classPath, null, null);
	}
	
	public static <T>  T newClass(String classPath, Class[] paramClasses, Object... params){
		
		Class<T> classe = null;
		
		try {
			classe = (Class<T>) Class.forName(classPath);
		} catch (ClassNotFoundException e) {
			e.printStackTrace();
		}
		
		Constructor<T> constructeur = null;
		
		if(paramClasses != null && params != null){
			
			try {
				constructeur = classe.getConstructor(paramClasses);
			} catch (NoSuchMethodException | SecurityException e) {
				e.printStackTrace();
	//			try {
	//				constructeur = (Constructor<T>) classe.getSuperclass().getConstructor(paramClasses);
	//			} catch (NoSuchMethodException | SecurityException e1) {
	//				try {
	//					constructeur = (Constructor<T>) classe.getSuperclass().getSuperclass().getConstructor(paramClasses);
	//				} catch (NoSuchMethodException | SecurityException e2) {
	//					e2.printStackTrace();
	//				}
	//			}
			}
			
			try {
				return constructeur.newInstance(params);
			} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
				e.printStackTrace();
			}
			
		}else{
			
			try {
				constructeur = classe.getConstructor();
			} catch (NoSuchMethodException | SecurityException e) {
				e.printStackTrace();
			}
			
			try {
				return constructeur.newInstance();
			} catch (InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
				e.printStackTrace();
			}
			
		}
		
		return null;
		
	}

}
package RN.utils;

import java.text.DecimalFormat;
import java.util.Random;

/**
 * @author Eric Marchand
 *
 */
public class StatUtils {
	

	public static int randomize(int max){
		return (int) Math.floor(Math.random() * max + 0.5d);
	}
	
	public static double round(double value, int places) {
	    
		if (places < 0) throw new IllegalArgumentException();

	    long factor = (long) Math.pow(10, places);
	    value = value * factor;
	    long tmp = Math.round(value);
	    
	    return (double) tmp / factor;
	}
	
	public static String format(double value, String format){
		DecimalFormat df = new DecimalFormat(format);
		return df.format(value);
	}
	
	public static Double initValue(double min, double max) {
		Random random = new Random();
		return random.nextDouble() * (max - min) + min;
	}
	
	public static Double nextDouble() {
		Random random = new Random();
		return random.nextDouble();
	}

	public static double absoluteSum(Double[][] matrix) {
		Double sum = 0D;
		for(int i=0;i<matrix.length;i++){
			for(int j=0;j<matrix[i].length;j++){
				sum += Math.abs(matrix[i][j]);
			}
		}
		return sum;
	}
	
	
}
package RN.utils;

import java.util.Arrays;
import java.util.List;
import java.util.function.Function;
import java.util.function.IntFunction;
import java.util.stream.Collectors;

/**
 * @author Eric Marchand
 *
 */
public class StreamUtils {

	public StreamUtils() {
	}

//	use it like this:
//
//		//for lists
//		List<String> stringList = Arrays.asList("1","2","3");
//		List<Integer> integerList = convertList(stringList, s -> Integer.parseInt(s));
//
//		//for arrays
//		String[] stringArr = {"1","2","3"};
//		Double[] doubleArr = convertArray(stringArr, Double::parseDouble, Double[]::new);
//		Note that  s -> Integer.parseInt(s) could be replace with Integer::parseInt (see Method references)	
	
	// for lists
	public static <T, U> List<U> convertList(List<T> from, Function<T, U> func) {
		return from.stream().map(func).collect(Collectors.toList());
	}

	// for arrays
	public static <T, U> U[] convertArray(T[] from, Function<T, U> func, IntFunction<U[]> generator) {
		return Arrays.stream(from).map(func).toArray(generator);
	}

}
package RN;

import java.io.File;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.ConcurrentModificationException;
import java.util.HashSet;
import java.util.List;
import java.util.ListIterator;
import java.util.Set;

import RN.algoactivations.ActivationFx;
import RN.algoactivations.EActivation;
import RN.algotrainings.ITrainer;
import RN.dataset.inputsamples.ESamples;
import RN.dataset.inputsamples.InputSample;
import RN.nodes.INode;
import javafx.animation.KeyFrame;
import javafx.animation.SequentialTransition;
import javafx.animation.Timeline;
import javafx.application.Application;
import javafx.application.Platform;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.geometry.Insets;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.chart.LineChart;
import javafx.scene.chart.NumberAxis;
import javafx.scene.control.Button;
import javafx.scene.control.CheckBox;
import javafx.scene.control.ComboBox;
import javafx.scene.control.Label;
import javafx.scene.control.Slider;
import javafx.scene.control.Tab;
import javafx.scene.control.TabPane;
import javafx.scene.control.TextArea;
import javafx.scene.control.TextField;
import javafx.scene.layout.HBox;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.shape.Rectangle;
import javafx.stage.FileChooser;
import javafx.stage.Stage;
import javafx.util.Duration;

/**
 * @author Eric Marchand
 * 
 */
public class ViewerFX extends Application {

	public static NumberAxis xAxis = null;
	public static NumberAxis yAxis = null;
	public static LineChart<Number, Number> lineChart = null;
	public static LineChart.Series<Number, Number> series = null;

	public static List<ActivationFx> activations = new ArrayList<ActivationFx>();
	final ObservableList<ActivationFx> layerFx = FXCollections.observableArrayList(activations);
	private static ESamples selectedSample = ESamples.COSINUS;
	protected EActivation selectedFxNode = EActivation.SYGMOID_0_1;

	protected static ITester tester = null;
	protected static ITrainer trainer = null;

	final Button train = new Button("Train");
	final Button trainStop = new Button("Stop train");
	final Button run = new Button("Run");
	final Button runTest = new Button("Run test");
	final Button save = new Button("Save network");
	final Button load = new Button("Load network");
	final Button rand = new Button("Randomize network");
	final Button clear = new Button("Clear");
	final Button print = new Button("Print network");
	final Button printDeserializedNet = new Button("Print deserialized network");
	
	static TabPane tabPane = null;
	static Tab tabConsole = null;
	static Tab tabTraining = null;
	static Tab tabScaling = null;
	
	public final static int nbCycles = 500;


	public static CheckBox showLogs = null;

	private static int threadPoolDelay = 500000;

	public static volatile boolean stopPool = false;
	public static volatile Integer factor = 0;

	private static SequentialTransition animation = new SequentialTransition();
	private static Timeline timeline1 = new Timeline();

	public static ObservableList<InputSample> excelSheets = FXCollections
			.observableArrayList(new InputSample("Please select a dataset", ESamples.NONE));

	public static Rectangle clip = null;

	public static Pane scalingPane = new Pane();
	public static Pane netPane = null;
	private static TextArea consoleTextArea; // Référence globale pour l'area de texte de la console

	public static boolean showLinearSeparation = false;

	// Ajoutez un champ pour stocker la dernière valeur du cycle d'entraînement
	private static int lastTrainingCycle = 0;
	private static int origTrainingCycle = 0;
	
	
	static {
		activations.add(new ActivationFx("Cosinus", EActivation.COS));
		activations.add(new ActivationFx("Sinus", EActivation.SIN));
		activations.add(new ActivationFx("Identité", EActivation.IDENTITY));
		activations.add(new ActivationFx("Heaviside", EActivation.HEAVISIDE));
		activations.add(new ActivationFx("Sygmoide", EActivation.SYGMOID_0_1));
		activations.add(new ActivationFx("Tangente hyperbolique", EActivation.TANH));
	}

	@Override
	public void start(Stage stage) {
		
	    stage.setTitle("Error rate");

	    Group group = new Group();
	    StackPane root = new StackPane(group);
	    Scene scene = new Scene(root);
	    stage.setScene(scene);

	    createLineChart(); // Initialiser le lineChart
	    netPane = createNetPane();
	    scalingPane = createScaling(); // Initialiser le scalingPane
	    createConsoleTab(); // Initialiser le consoleTextArea

	    tabPane = createTabPane(); // Cette méthode va maintenant configurer correctement les onglets

	    Pane commandsPane = createCommands();

	    VBox vbox = new VBox(tabPane, commandsPane); // Utiliser tabPane directement sans le stack non nécessaire

	    root.getChildren().add(vbox);

	    // Configuration initiale des boutons
	    configureInitialButtonState();

	    stage.show();

	}
	
	private void configureInitialButtonState() {
	    train.setDisable(true);
	    trainStop.setDisable(true);
	    run.setDisable(true);
	    runTest.setDisable(true);
	    save.setDisable(true);
	    rand.setDisable(true);
	    clear.setDisable(true);
	    print.setDisable(true);
	    printDeserializedNet.setDisable(true);
	}

	
	private static void createConsoleTab() {
	    consoleTextArea = new TextArea(); // Initialiser l'area de texte de la console
	    consoleTextArea.setEditable(false); // Rendre non éditable
	    consoleTextArea.textProperty().addListener((observable, oldValue, newValue) -> {
			Platform.runLater(() -> {
		    	consoleTextArea.setScrollTop(Double.MAX_VALUE); // Défiler automatiquement vers le bas
			});
	    });

	    
	}

	private TabPane createTabPane() {
		
	    TabPane tabPane = new TabPane();

	    tabTraining = new Tab("Training", lineChart); // Ajouter le lineChart directement à l'onglet
	    tabTraining.setClosable(false);

	    tabScaling = new Tab("Scale network", scalingPane); // Ajouter le scalingPane directement à l'onglet
	    tabScaling.setClosable(false);

	    tabConsole = new Tab("Console", consoleTextArea); // Ajouter le consoleTextArea directement à l'onglet
	    tabConsole.setClosable(false);

	    tabPane.getTabs().addAll(tabTraining, tabScaling, tabConsole); // Ajouter tous les onglets au TabPane

	    return tabPane;
	}

	private void createLineChart() {
		xAxis = new NumberAxis(0, 500, 10);
		yAxis = new NumberAxis(-0.1, 1, 0.1);
		lineChart = new LineChart<Number, Number>(xAxis, yAxis);
		lineChart.setStyle("-fx-background-color: #ffffff;");

		xAxis.setLabel("Training cycles");
		yAxis.setLabel("Error level");
		xAxis.setAnimated(false);
		yAxis.setAnimated(false);
		xAxis.setAutoRanging(true);
		yAxis.setAutoRanging(true);
		lineChart.setAnimated(false);

		lineChart.setTitle(tester.getLineChartTitle());
		lineChart.setPrefSize(1000, 400);
	}

	public Pane createCommands() {

		Pane commandPane = new Pane();

		showLogs = new CheckBox("Logs");

		final VBox vbox = new VBox();
		final HBox hbox1 = new HBox();
		final HBox hbox2 = new HBox();
		vbox.getChildren().addAll(hbox1, hbox2);
		commandPane.getChildren().add(vbox);

		final ComboBox<InputSample> comboSamples = new ComboBox<InputSample>(excelSheets);
		comboSamples.getSelectionModel().selectFirst();
		comboSamples.getSelectionModel().selectedItemProperty().addListener(new ChangeListener<InputSample>() {

			@Override
			public void changed(ObservableValue<? extends InputSample> arg0, InputSample arg1, InputSample arg2) {

				if (arg2 != null) {
					selectedSample = arg2.getSample();

					// Activer le bouton "Train" si un dataset valide est sélectionné, sinon le
					// désactiver
					train.setDisable(selectedSample == ESamples.NONE);
					trainStop.setDisable(selectedSample == ESamples.NONE);
					run.setDisable(selectedSample == ESamples.NONE);
					runTest.setDisable(selectedSample == ESamples.NONE);
					save.setDisable(selectedSample == ESamples.NONE);
					rand.setDisable(selectedSample == ESamples.NONE);
					clear.setDisable(selectedSample == ESamples.NONE);
					print.setDisable(selectedSample == ESamples.NONE);
					printDeserializedNet.setDisable(selectedSample == ESamples.NONE);
					
		            lastTrainingCycle = 0; // Réinitialisez la dernière valeur du cycle d'entraînement
		            origTrainingCycle = 0;
		            if (!lineChart.getData().isEmpty())
		                lineChart.getData().clear(); // Nettoyez toutes les séries de données du graphique
		            series = null; // Réinitialisez la série
		            
	                xAxis.setAutoRanging(false); // Désactivez l'auto-range pour définir manuellement les limites
	                xAxis.setLowerBound(origTrainingCycle); // Démarrez à partir de la dernière valeur du cycle d'entraînement
	                xAxis.setUpperBound(lastTrainingCycle + nbCycles);

					if (ESamples.FILE == selectedSample) {

						trainer.initTrainer();

						// clean 3D graphics world
						Graphics3D.clearShapes();

						try {
							InputSample.setFileSample(tester, tester.getFilePath(), arg2.getFileSheetIdx());
						} catch (Exception e1) {
							e1.printStackTrace();
						}
						
						boolean isMLP = tester instanceof TestNetwork;

						if(isMLP) {
							lineChart.setTitle("MLP network : "
									+ tester.getNetwork().getLayers().size() + " layers, " 
									+ "  DataSerie : " + DataSeries.getInstance().getInputDataSet().size()
									+ " examples");		
						} else {
							lineChart.setTitle("LSTM network : "
									+ tester.getInputsCount() + " input(s), " + tester.getOutputsCount()
									+ " output(s)     DataSerie : " + DataSeries.getInstance().getInputDataSet().size()
									+ " examples");
						}

						Platform.runLater(() -> {
							tabPane.getSelectionModel().select(tabConsole);
						});
						consoleTextArea.setText(DataSeries.getInstance().getString()+ "\n");

						scalingPane = createScaling();

						if (lineChart.getData() != null && !lineChart.getData().isEmpty())
							lineChart.setData(null);

						trainer.setInputDataSetIterator(null);
						if (series != null && series.getData() != null)
							series.getData().clear();

						try {
							tester.launchRealCompute();
						} catch (Exception e) {
							e.printStackTrace();
						}

						// Weights are randomized here because first propagation create weights in the
						// 'unlinked' mode
						tester.initWeights(tester.getInitWeightRange(0), tester.getInitWeightRange(1));
						consoleTextArea.appendText("weigts randomized [ " + tester.getInitWeightRange(0) + ", "
								+ tester.getInitWeightRange(1) + "] !" + "\n");
						consoleTextArea.appendText("modèle chargé avec succès. "+ "\n");
						Platform.runLater(() -> {
					    	consoleTextArea.setScrollTop(Double.MAX_VALUE); // Défiler automatiquement vers le bas
						});

					}

				}
			}
		});

		final TextField learningRateField = new TextField(String.valueOf(trainer.getLearningRate()));
		learningRateField.setPrefColumnCount(4);
		final TextField momentumField = new TextField(String.valueOf(trainer.getAlphaDeltaWeight()));
		momentumField.setPrefColumnCount(4);
		final Button submit = new Button("Apply");

		showLogs.setSelected(true);

		hbox1.setSpacing(10);
		hbox1.getChildren().addAll(train, trainStop, run, runTest, rand, clear, print, save, new Label("Learning rate"),
				learningRateField, new Label("Momentum"), momentumField, submit, showLogs);

		hbox2.setSpacing(10);
		hbox2.getChildren().addAll(comboSamples, load, printDeserializedNet);

		hbox1.setPadding(new Insets(5, 20, 2, 20));
		hbox2.setPadding(new Insets(2, 20, 5, 20));

		animation.setOnFinished(new EventHandler<ActionEvent>() {

			@Override
			public void handle(ActionEvent arg0) {
				Platform.runLater(() -> {
					train.setDisable(false);
				});
			}

		});
		
		train.setOnAction(new EventHandler<ActionEvent>() {

			@Override
			public void handle(ActionEvent e) {

				try {
					
					tabPane.getSelectionModel().select(tabTraining);
					
					trainer.getErrorLevelLines().clear();

					animation.stop(); // Arrêtez l'animation avant de commencer l'entraînement
					Platform.runLater(() -> {
						train.setDisable(true);
					});
		            // S'il n'y a pas encore de données, initialisez l'axe des X en fonction de la dernière valeur de cycle d'entraînement
		            if (lineChart.getData() == null || lineChart.getData().isEmpty()) {
		                xAxis.setAutoRanging(false); // Désactivez l'auto-range pour définir manuellement les limites
		                xAxis.setLowerBound(origTrainingCycle); // Démarrez à partir de la dernière valeur du cycle d'entraînement
		            }
	                xAxis.setUpperBound(lastTrainingCycle + nbCycles); // Exemple: +500 pour définir une nouvelle plage

		            if (series == null) {
		                series = new LineChart.Series<Number, Number>();
		                lineChart.getData().add(series);
		            }

		            series.setName("Train " + (lineChart.getData().size() + 1));

					trainer.launchTrain(showLogs.isSelected(), consoleTextArea);

					timeline1.setCycleCount(trainer.getErrorLevelLines().size());
					animation.play();
					lastTrainingCycle = lastTrainingCycle + nbCycles;

				} catch (Exception e1) {
					e1.printStackTrace();
				}
			}
		});

		// create animation
		timeline1.getKeyFrames().add(

				new KeyFrame(Duration.millis(10), new EventHandler<ActionEvent>() {

					ListIterator<LineChart.Data<Number, Number>> errorItr = null;

					@Override
					public void handle(ActionEvent actionEvent) {

						if (!trainer.getErrorLevelLines().isEmpty()) {
							int nextIndex = 0;

							if (errorItr == null)
								errorItr = trainer.getErrorLevelLines().listIterator();
							else
								nextIndex = errorItr.nextIndex();

							try {
								if (errorItr.hasNext())
									series.getData().add(errorItr.next());
								else {
									errorItr = trainer.getErrorLevelLines().listIterator();
									if (errorItr.hasNext())
										series.getData().add(errorItr.next());
								}
							} catch (ConcurrentModificationException cme) {
								tabPane.getSelectionModel().select(tabConsole);
								consoleTextArea.setText("Concurrent modif KeyFrame :  nextIndex :" + nextIndex);
							}
						}
					}

				})

		);

		animation.getChildren().add(timeline1);

		trainStop.setOnAction(new EventHandler<ActionEvent>() {

			@Override
			public void handle(ActionEvent e) {

				try {
					trainer.setBreakTraining(true);
					train.setText("Train");
					factor = 0;
					Thread.sleep(500);

				} catch (Exception e1) {
					e1.printStackTrace();
				}
			}
		});

		run.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent e) {
				try {
					tester.launchRealCompute();
				} catch (Exception e1) {
					e1.printStackTrace();
				}
			}
		});

		runTest.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent e) {
				try {
					tester.launchTestCompute();
				} catch (Exception e1) {
					e1.printStackTrace();
				}
			}
		});

		// Setting an action for the Submit button
		submit.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent e) {
				if ((learningRateField.getText() != null && !learningRateField.getText().isEmpty())) {

					trainer.setLearningRate(Double.valueOf(learningRateField.getText()));
					trainer.setAlphaDeltaWeight(Double.valueOf(momentumField.getText()));
					tabPane.getSelectionModel().select(tabConsole);
					consoleTextArea.setText("learningRate set to " + learningRateField.getText());
					consoleTextArea.appendText("momentum set to " + momentumField.getText());
				} else {
					consoleTextArea.setText("nothing happened !");
				}
			}
		});

		save.setOnAction(new EventHandler<ActionEvent>() {
		    @Override
		    public void handle(ActionEvent e) {
		        // Format pour le timestamp
		        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmmss");
		        // Obtenir le timestamp actuel
		        String timestamp = LocalDateTime.now().format(formatter);

		        // Chemin du dossier models à la racine du projet
		        String cheminDossier = "models/";
		        // Vérifier l'existence du dossier et le créer si nécessaire
		        File dossier = new File(cheminDossier);
		        if (!dossier.exists()) {
		            dossier.mkdirs();
		        }

		        // Nom du fichier avec timestamp
		        String nomFichier = "deeper-net-model-" + timestamp + ".ser";
		        // Chemin complet du fichier de sauvegarde
		        String cheminFichier = cheminDossier + nomFichier;

		        // Obtenir le réseau de neurones à sauvegarder
		        Object reseauNeurone = tester.getNetwork();

		        // Appeler saveNetwork pour sauvegarder le réseau
		        saveNetwork(reseauNeurone, cheminFichier);
		        
				tabPane.getSelectionModel().select(tabConsole);
				consoleTextArea.setText("Réseau sauvegardé sous : " + cheminFichier);

		    }
		});
		
		
		load.setOnAction(new EventHandler<ActionEvent>() {
		    @Override
		    public void handle(ActionEvent event) {
		        FileChooser fileChooser = new FileChooser();
		        // Définir le filtre d'extension pour ne montrer que les fichiers .ser
		        FileChooser.ExtensionFilter extFilter = new FileChooser.ExtensionFilter("SER files (*.ser)", "*.ser");
		        fileChooser.getExtensionFilters().add(extFilter);

		        // Ouvrir la boîte de dialogue de sélection de fichier
		        File file = fileChooser.showOpenDialog(null);

		        if (file != null) {
		            // Charger le réseau de neurones depuis le fichier sélectionné

			        try {
			            Network network = NetworkService.loadNetwork(file.getPath());

			            if (network != null) {
			            	
			            	lineChart.setTitle(network.getName());
			            	
			                if (tester != null) {
			                    tester.setNetwork(network); // Suppose que tester a une méthode setNetwork pour configurer le réseau
				                // Update your application's state with the loaded network if necessary
				                // For example, set the loaded network as the current network in your application context
					            //Network.network = network;
				                // Assuming you have the network object loaded successfully
				                // Enable the Run and Print Network buttons here
				                run.setDisable(false);
				                print.setDisable(false);
				                rand.setDisable(false);
				                printDeserializedNet.setDisable(false);
								consoleTextArea.setText("Modèle \"" + network.getName() + "\" chargé avec succès.");
			                } else {
			                    // Gérer le cas où tester n'est pas initialisé
			                    // Peut-être initialiser tester ici ou loguer une erreur
								tabPane.getSelectionModel().select(tabConsole);
								consoleTextArea.setText("Le Testeur n'est pas initialisé.");
			                }

			            }
			            
			        } catch (Exception e) {
			            e.printStackTrace();
			            // You might want to keep the buttons disabled if loading fails
			            run.setDisable(true);
			            print.setDisable(true);
			        }
		        
		        }
		        
		        
		    }
		});
		




		rand.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent e) {
				tester.initWeights(tester.getInitWeightRange(0), tester.getInitWeightRange(1));
				tabPane.getSelectionModel().select(tabConsole);
				consoleTextArea.setText("weigts randomized [ " + tester.getInitWeightRange(0) + ", "
						+ tester.getInitWeightRange(1) + "] !");
			}
		});

		clear.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent e) {
				origTrainingCycle = lastTrainingCycle;
				if (!lineChart.getData().isEmpty())
			           lineChart.getData().clear(); // Utilisez clear() au lieu de setData(null)
		        series = null; // Réinitialisez la série pour être sûrs qu'une nouvelle série sera créée lors du prochain entraînement
			}
		});

		print.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent e) {
				String trace = tester.getNetwork().getString();
				tabPane.getSelectionModel().select(tabConsole);
				consoleTextArea.setText(trace); // Mettre à jour l'area de texte de la console avec les informations

			}
		});
		
		printDeserializedNet.setOnAction(new EventHandler<ActionEvent>() {
			@Override
			public void handle(ActionEvent e) {
				Object object = tester.getNetwork();
	            Set<Integer> seenObjects = new HashSet<>();
	            try {
					tabPane.getSelectionModel().select(tabConsole);
					consoleTextArea.setText(NetworkService.printObjectDetails(object, 0, seenObjects));
				} catch (IllegalAccessException e1) {
					e1.printStackTrace();
				}

			}
		});

		return commandPane;

	}

	public Pane createNetPane() {

		return new HBox();
	}

	public Pane createScaling() {

		final INetwork network = tester.getNetwork();

		scalingPane.setStyle("-fx-background-color: #ffffff;-fx-border-color: #ff0000;-fx-border-width: 1px;");
		scalingPane.getChildren().clear();
		VBox vbox = new VBox();

		Slider scaleNode = null;
		Label label = null;
		
		if(network != null) {
			
			for (int idxLayerHidden = 1; idxLayerHidden <= network.getLayers().size() - 2; idxLayerHidden++) {
				int nodecount = network.getLayer(idxLayerHidden).getNodeCount();
				scaleNode = new Slider(0D, nodecount * 10D + 1D, nodecount);
				double majTick = 100D;
				if(nodecount <= 10) majTick = 10; else if(nodecount > 10 && nodecount < 100) majTick = 100; else if(nodecount > 100 && nodecount < 1000) majTick = 1000; else majTick = 10000;
				label = new Label("Hidden layer #" + idxLayerHidden + " nodes: " + nodecount);
	
				scaleNode.setMinorTickCount(10);
				scaleNode.setMajorTickUnit(majTick);
				scaleNode.setSnapToTicks(false);
				scaleNode.setShowTickLabels(true);
				scaleNode.setShowTickMarks(true);
				scaleNode.setPrefWidth(scalingPane.getWidth() - 50D);
	
				final int currentIdxLayer = idxLayerHidden;
				scaleNode.valueProperty().addListener(new ChangeListener<Number>() {
					public void changed(ObservableValue<? extends Number> ov, Number old_val, Number new_val) {
	
						if (old_val == null || new_val == null)
							return;
	
	
						if (new_val.intValue() == 0)
							return;
	
						if (old_val.intValue() < new_val.intValue()) {
	
							for (int idx = 1; idx <= new_val.intValue() - old_val.intValue(); idx++) {
								INode node = network.getLayer(currentIdxLayer).getLayerNodes()
										.get(network.getLayer(currentIdxLayer).getNodeCount() - 1);
								INode nodeCopy = node.deepCopy();
								nodeCopy.randomizeWeights(tester.getInitWeightRange(0), tester.getInitWeightRange(1));
								node.getArea().addNode(nodeCopy);
							}
	
						} else if (old_val.intValue() > new_val.intValue()) {
	
							for (int idx = 1; idx <= old_val.intValue() - new_val.intValue(); idx++) {
								INode node = network.getLayer(currentIdxLayer).getLayerNodes()
										.get(network.getLayer(currentIdxLayer).getNodeCount() - 1);
								node.disconnect();
								((IArea) node.getArea()).removeNode(node);
							}
	
						}
	
					}
				});
				vbox.setPadding(new Insets(15,15,15,15));
				vbox.getChildren().addAll(label, scaleNode);
			}
		
		}

		scalingPane.getChildren().add(vbox);

		return scalingPane;
	}

	public static void viewError() {
		launch();
	}

	public static void startViewerFX() {
		new Thread(new Runnable() {

			@Override
			public void run() {
				ViewerFX.viewError();
			}
		}).start();
	}
	
	public void saveNetwork(Object reseauNeurone, String cheminFichier) {
	    try {
			NetworkService.saveNetwork(reseauNeurone, cheminFichier);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public void loadNetwork(String cheminFichier) {
	    try {
			NetworkService.loadNetwork(cheminFichier);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	


	public static ESamples getSelectedSample() {
		return selectedSample;
	}

	public static void setSelectedSample(ESamples selectedSample) {
		ViewerFX.selectedSample = selectedSample;
	}

	public static void setTester(ITester instance) {
		ViewerFX.tester = instance;

	}

	public static void setTrainer(ITrainer trainer) {
		ViewerFX.trainer = trainer;
	}

	public static void addSeriesToLineChart() {
	}

	public static int getThreadPoolDelay() {
		return threadPoolDelay;
	}

	public static void setThreadPoolDelay(int threadPoolDelay) {
		ViewerFX.threadPoolDelay = threadPoolDelay;
	}

}